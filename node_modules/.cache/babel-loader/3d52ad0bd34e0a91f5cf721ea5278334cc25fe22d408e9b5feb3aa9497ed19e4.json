{"ast":null,"code":"// Copyright (c) 2016, 2024, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst AqQueue = require('./aqQueue.js');\nconst BaseDbObject = require('./dbObject.js');\nconst {\n  Buffer\n} = require('buffer');\nconst Lob = require('./lob.js');\nconst ResultSet = require('./resultset.js');\nconst SodaDatabase = require('./sodaDatabase.js');\nconst EventEmitter = require('events');\nconst QueryStream = require('./queryStream.js');\nconst errors = require('./errors.js');\nconst nodbUtil = require('./util.js');\nconst impl = require('./impl');\nconst process = require('process');\nconst util = require('util');\nconst constants = require('./constants.js');\nconst settings = require('./settings.js');\nconst transformer = require('./transformer.js');\nconst types = require('./types.js');\nconst oson = require('./impl/datahandlers/oson.js');\n\n// global mapping of subscriptions; these cannot be tied to a particular\n// connection or pool since subscriptions can be created with one connection\n// and destroyed with another!\nconst _subscriptions = new Map();\n\n// define class\nclass Connection extends EventEmitter {\n  constructor() {\n    super();\n    this._dbObjectClasses = new Map();\n    this._closing = false;\n  }\n\n  //---------------------------------------------------------------------------\n  // _addDefaultsToExecOpts()\n  //\n  // Add values to the execute options from the global settings, if needed.\n  //---------------------------------------------------------------------------\n  _addDefaultsToExecOpts(options) {\n    options.connection = this;\n    if (options.keepInStmtCache === undefined) options.keepInStmtCache = true;\n    settings.addToOptions(options, \"autoCommit\", \"dbObjectAsPojo\", \"fetchArraySize\", \"fetchTypeHandler\", \"maxRows\", \"outFormat\", \"prefetchRows\");\n  }\n\n  //---------------------------------------------------------------------------\n  // _buildDbObjectClass()\n  //\n  // Builds and returns a database object class given the object type\n  // information supplied by the implementation.\n  //---------------------------------------------------------------------------\n  _buildDbObjectClass(objType) {\n    const DbObject = function (initialValue) {\n      this._impl = new impl.DbObjectImpl(objType);\n      if (this.isCollection) {\n        const proxy = new Proxy(this, BaseDbObject._collectionProxyHandler);\n        if (initialValue !== undefined) {\n          for (let i = 0; i < initialValue.length; i++) {\n            this.append(initialValue[i]);\n          }\n        }\n        return proxy;\n      } else if (initialValue !== undefined) {\n        Object.assign(this, initialValue);\n      }\n    };\n    DbObject.prototype = Object.create(BaseDbObject.prototype);\n    DbObject.prototype.constructor = DbObject;\n    DbObject.prototype._objType = objType;\n    if (objType.elementTypeClass) {\n      const cls = this._getDbObjectClass(objType.elementTypeClass);\n      objType.elementTypeClass = cls;\n    }\n    if (objType.isCollection) {\n      nodbUtil.addTypeProperties(objType, \"elementType\");\n      objType.elementTypeInfo.type = objType.elementType;\n    }\n    if (objType.attributes) {\n      const props = {};\n      for (const attr of objType.attributes) {\n        if (attr.typeClass) {\n          attr.typeClass = this._getDbObjectClass(attr.typeClass);\n        }\n        nodbUtil.addTypeProperties(attr, \"type\");\n        const prop = {\n          get() {\n            return this._getAttrValue(attr);\n          },\n          set(value) {\n            this._setAttrValue(attr, value);\n          }\n        };\n        props[attr.name] = prop;\n      }\n      Object.defineProperties(DbObject.prototype, props);\n    }\n    DbObject.toString = function () {\n      return 'DbObjectClass [' + objType.fqn + ']';\n    };\n    return DbObject;\n  }\n\n  //---------------------------------------------------------------------------\n  // _getDbObjectClass()\n  //\n  // Returns the database object class given the object type information\n  // supplied by the implementation. The cache is searched first to see if an\n  // object class has already been built.\n  //---------------------------------------------------------------------------\n  _getDbObjectClass(objType) {\n    if (objType.prototype instanceof BaseDbObject) return objType;\n    let cls = this._dbObjectClasses.get(objType);\n    if (!cls) {\n      cls = this._buildDbObjectClass(objType);\n      cls._connection = this;\n      cls._objType = objType;\n      objType._connection = this._impl;\n      this._dbObjectClasses.set(objType, cls);\n    }\n    return cls;\n  }\n\n  //---------------------------------------------------------------------------\n  // _getDbObjectClassForName()\n  //\n  // Returns the database object class given the name of the database object\n  // type. The cache is searched first to see if an object class has already\n  // been built.\n  //---------------------------------------------------------------------------\n  async _getDbObjectClassForName(name) {\n    let cls = this._dbObjectClasses.get(name);\n    if (!cls) {\n      const objType = await this._impl.getDbObjectClass(name);\n      cls = this._getDbObjectClass(objType);\n      this._dbObjectClasses.set(name, cls);\n    }\n    return cls;\n  }\n\n  //---------------------------------------------------------------------------\n  // _isBindDir()\n  //\n  // Returns a boolean indicating if the supplied value is a valid bind\n  // direction.\n  //---------------------------------------------------------------------------\n  _isBindDir(value) {\n    return value === constants.BIND_IN || value === constants.BIND_OUT || value === constants.BIND_INOUT;\n  }\n\n  //---------------------------------------------------------------------------\n  // _isBindValue()\n  //\n  // Returns a boolean indicating if the supplied value is one that can be\n  // bound.\n  //---------------------------------------------------------------------------\n  _isBindValue(value) {\n    return value === null || value === undefined || typeof value === 'number' || typeof value === 'string' || typeof value === 'boolean' || typeof value === 'bigint' || Array.isArray(value) || nodbUtil.isVectorValue(value) || Buffer.isBuffer(value) || util.types.isDate(value) || value instanceof Lob || value instanceof ResultSet || value instanceof BaseDbObject;\n  }\n\n  //---------------------------------------------------------------------------\n  // _processBindUnit()\n  //\n  // Processes a bind unit (object) supplied by the user and returns the value\n  // stored in it (if one is).\n  //---------------------------------------------------------------------------\n  async _processBindUnit(bindInfo, bindUnit, inExecuteMany) {\n    let okBindUnit = false;\n\n    // get and validate bind direction; if not specified, IN is assumed\n    if (bindUnit.dir === undefined) {\n      bindInfo.dir = constants.BIND_IN;\n    } else {\n      errors.assert(this._isBindDir(bindUnit.dir), errors.ERR_INVALID_BIND_DIRECTION);\n      bindInfo.dir = bindUnit.dir;\n      okBindUnit = true;\n    }\n\n    // get and validate bind type; it must be one of the integer constants\n    // identifying types, a string identifying an object type or a constructor\n    // function identifying an object type\n    if (bindUnit.type !== undefined) {\n      if (typeof bindUnit.type === 'string') {\n        bindInfo.type = types.DB_TYPE_OBJECT;\n        bindInfo.typeClass = await this._getDbObjectClassForName(bindUnit.type);\n        bindInfo.objType = bindInfo.typeClass._objType;\n      } else if (bindUnit.type.prototype instanceof BaseDbObject) {\n        bindInfo.type = types.DB_TYPE_OBJECT;\n        bindInfo.typeClass = bindUnit.type;\n        bindInfo.objType = bindInfo.typeClass._objType;\n      } else {\n        errors.assert(bindUnit.type instanceof types.DbType, errors.ERR_INVALID_BIND_DATA_TYPE, 2);\n        bindInfo.type = bindUnit.type;\n      }\n      okBindUnit = true;\n\n      // when calling executeMany(), bind type is mandatory\n    } else if (inExecuteMany) {\n      if (bindInfo.name) errors.throwErr(errors.ERR_MISSING_TYPE_BY_NAME, bindInfo.name);\n      errors.throwErr(errors.ERR_MISSING_TYPE_BY_POS, bindInfo.pos);\n    }\n\n    // get and validate the maximum size for strings/buffers; this value is\n    // used for IN/OUT and OUT binds in execute() and at all times for\n    // executeMany()\n    if (bindInfo.dir !== constants.BIND_IN || inExecuteMany) {\n      if (bindUnit.maxSize !== undefined) {\n        errors.assertParamPropValue(Number.isInteger(bindUnit.maxSize) && bindUnit.maxSize > 0, 2, \"maxSize\");\n        bindInfo.maxSize = bindUnit.maxSize;\n        bindInfo.checkSize = true;\n        okBindUnit = true;\n      } else if (inExecuteMany) {\n        if (bindInfo.type === types.DB_TYPE_VARCHAR || bindInfo.type === types.DB_TYPE_RAW) {\n          if (bindInfo.name) errors.throwErr(errors.ERR_MISSING_MAX_SIZE_BY_NAME, bindInfo.name);\n          errors.throwErr(errors.ERR_MISSING_MAX_SIZE_BY_POS, bindInfo.pos);\n        }\n      } else {\n        bindInfo.maxSize = constants.DEFAULT_MAX_SIZE_FOR_OUT_BINDS;\n      }\n    }\n\n    // get max array size (for array binds, not possible in executeMany())\n    bindInfo.isArray = false;\n    if (!inExecuteMany) {\n      if (bindUnit.maxArraySize !== undefined) {\n        errors.assertParamPropValue(Number.isInteger(bindUnit.maxArraySize) && bindUnit.maxArraySize > 0, 2, \"maxArraySize\");\n        bindInfo.maxArraySize = bindUnit.maxArraySize;\n        bindInfo.isArray = true;\n      }\n    }\n\n    // get the value, if specified (not used in executeMany())\n    if (!inExecuteMany && bindUnit.val !== undefined) {\n      return bindUnit.val;\n    }\n    if (!okBindUnit) errors.throwErr(errors.ERR_INVALID_BIND_UNIT);\n  }\n\n  //---------------------------------------------------------------------------\n  // _processBindValue()\n  //\n  // Processes the bind value supplied by the caller. This performs all checks\n  // on the value and normalizes it for use by the implementation class. If no\n  // bind info has been defined yet, the value defines that.\n  //---------------------------------------------------------------------------\n  async _processBindValue(bindInfo, value, options) {\n    const transformed = transformer.transformValueIn(bindInfo, value, options);\n    if (bindInfo.isArray) {\n      bindInfo.values = transformed.concat(bindInfo.values.slice(transformed.length));\n    } else {\n      bindInfo.values[options.pos] = transformed;\n    }\n    if (bindInfo.type === types.DB_TYPE_OBJECT && bindInfo.typeClass === undefined) {\n      bindInfo.typeClass = await this._getDbObjectClass(value._objType);\n      bindInfo.objType = bindInfo.typeClass._objType;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _processExecuteBind()\n  //\n  // Processes a single execute bind supplied by the caller. This performs all\n  // checks on the bind and normalizes it for use by the implementation class.\n  //---------------------------------------------------------------------------\n  async _processExecuteBind(bindInfo, bindData) {\n    // setup defaults\n    bindInfo.isArray = false;\n\n    // if bind data is a value that can be bound directly, use it; otherwise,\n    // scan the bind unit for bind information and its value\n    let bindValue;\n    if (this._isBindValue(bindData)) {\n      bindInfo.dir = constants.BIND_IN;\n      bindValue = bindData;\n    } else {\n      bindValue = await this._processBindUnit(bindInfo, bindData, false);\n    }\n\n    // for IN and IN/OUT binds, process the value\n    if (bindInfo.dir !== constants.BIND_OUT) {\n      const options = {\n        pos: 0,\n        allowArray: true\n      };\n      await this._processBindValue(bindInfo, bindValue, options);\n    }\n\n    // if only null values were found (or an OUT bind was specified), type\n    // information may not be set, so complete bind information as a string\n    // and set the maxSize to 1 if it has not already been set\n    if (bindInfo.type === undefined) {\n      bindInfo.type = types.DB_TYPE_VARCHAR;\n      if (bindInfo.maxSize === undefined) bindInfo.maxSize = 1;\n    }\n\n    // check valid bind type for array binds\n    if (bindInfo.isArray && bindInfo.type !== types.DB_TYPE_VARCHAR && bindInfo.type !== types.DB_TYPE_NVARCHAR && bindInfo.type !== types.DB_TYPE_CHAR && bindInfo.type !== types.DB_TYPE_NCHAR && bindInfo.type !== types.DB_TYPE_NUMBER && bindInfo.type !== types.DB_TYPE_BINARY_FLOAT && bindInfo.type !== types.DB_TYPE_BINARY_DOUBLE && bindInfo.type !== types.DB_TYPE_DATE && bindInfo.type !== types.DB_TYPE_TIMESTAMP && bindInfo.type !== types.DB_TYPE_TIMESTAMP_LTZ && bindInfo.type !== types.DB_TYPE_TIMESTAMP_TZ && bindInfo.type !== types.DB_TYPE_RAW) {\n      errors.throwErr(errors.ERR_INVALID_TYPE_FOR_ARRAY_BIND);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _processExecuteBinds()\n  //\n  // Processes the binds supplied by the caller. This performs all checks on\n  // the binds and normalizes them for use by the implementation class.\n  //---------------------------------------------------------------------------\n  async _processExecuteBinds(binds) {\n    const normBinds = [];\n    if (Array.isArray(binds)) {\n      for (let i = 0; i < binds.length; i++) {\n        const bindInfo = normBinds[i] = {\n          pos: i + 1,\n          values: []\n        };\n        await this._processExecuteBind(bindInfo, binds[i]);\n      }\n    } else {\n      errors.assertParamValue(nodbUtil.isObject(binds), 2);\n      const bindNames = Object.getOwnPropertyNames(binds);\n      for (let i = 0; i < bindNames.length; i++) {\n        const bindInfo = normBinds[i] = {\n          name: bindNames[i],\n          values: []\n        };\n        await this._processExecuteBind(bindInfo, binds[bindNames[i]]);\n      }\n    }\n    return normBinds;\n  }\n\n  //---------------------------------------------------------------------------\n  // _processExecuteManyBinds()\n  //\n  // Processes the binds supplied by the caller. This performs all checks on\n  // the binds and normalizes them for use by the implementation class.\n  //---------------------------------------------------------------------------\n  async _processExecuteManyBinds(binds, bindDefs) {\n    const normBinds = [];\n    let byPosition;\n\n    // transform bindDefs into normalized binds, if available\n    if (bindDefs !== undefined) {\n      if (Array.isArray(bindDefs)) {\n        byPosition = true;\n        for (let i = 0; i < bindDefs.length; i++) {\n          const bindInfo = normBinds[i] = {\n            pos: i + 1,\n            values: []\n          };\n          await this._processBindUnit(bindInfo, bindDefs[i], true);\n        }\n      } else {\n        byPosition = false;\n        const bindNames = Object.getOwnPropertyNames(bindDefs);\n        for (let i = 0; i < bindNames.length; i++) {\n          const bindInfo = normBinds[i] = {\n            name: bindNames[i],\n            values: []\n          };\n          await this._processBindUnit(bindInfo, bindDefs[bindNames[i]], true);\n        }\n      }\n\n      // otherwise, use the first row to determine the binds to use\n    } else {\n      const row = binds[0];\n      errors.assertParamValue(nodbUtil.isObjectOrArray(row), 2);\n      if (Array.isArray(row)) {\n        byPosition = true;\n        for (let i = 0; i < row.length; i++) {\n          normBinds[i] = {\n            pos: i + 1\n          };\n        }\n      } else {\n        byPosition = false;\n        const bindNames = Object.getOwnPropertyNames(row);\n        for (let i = 0; i < bindNames.length; i++) {\n          normBinds[i] = {\n            name: bindNames[i]\n          };\n        }\n      }\n      for (let i = 0; i < normBinds.length; i++) {\n        normBinds[i].dir = constants.BIND_IN;\n        normBinds[i].isArray = false;\n        normBinds[i].values = [];\n      }\n    }\n\n    // process each of the rows\n    for (let i = 0; i < binds.length; i++) {\n      const row = binds[i];\n      const options = {\n        pos: i,\n        allowArray: false\n      };\n      errors.assert(byPosition && Array.isArray(row) || !byPosition && nodbUtil.isObject(row), errors.ERR_MIXED_BIND);\n      for (let j = 0; j < normBinds.length; j++) {\n        const bindInfo = normBinds[j];\n        const value = byPosition ? row[j] : row[bindInfo.name];\n        await this._processBindValue(bindInfo, value, options);\n      }\n    }\n\n    // set bind type and size to a string of size 1 if no bind type was\n    // specified (and all values are null)\n    for (let i = 0; i < normBinds.length; i++) {\n      const bindInfo = normBinds[i];\n      if (bindInfo.type === undefined) {\n        bindInfo.type = types.DB_TYPE_VARCHAR;\n        bindInfo.maxSize = 1;\n      }\n    }\n    return normBinds;\n  }\n\n  //---------------------------------------------------------------------------\n  // _transformOutBind()\n  //\n  // Transform an output bind value from an implementation value to a user\n  // facing value (for result sets and LOBs). DML returning output variables\n  // are always an array of values.\n  //---------------------------------------------------------------------------\n  _transformOutBind(val, options) {\n    let outVal = val;\n    if (Array.isArray(val)) {\n      outVal = [];\n      for (let i = 0; i < val.length; i++) outVal.push(this._transformOutBind(val[i], options));\n    } else if (val instanceof impl.ResultSetImpl) {\n      outVal = new ResultSet();\n      outVal._setup(this, val);\n    } else if (val instanceof impl.LobImpl) {\n      outVal = new Lob();\n      outVal._setup(val, true);\n    } else if (val instanceof impl.DbObjectImpl) {\n      const cls = this._dbObjectClasses.get(val._objType);\n      outVal = Object.create(cls.prototype);\n      outVal._impl = val;\n      if (options.dbObjectAsPojo) {\n        outVal = outVal._toPojo();\n      } else if (outVal.isCollection) {\n        outVal = new Proxy(outVal, BaseDbObject._collectionProxyHandler);\n      }\n    }\n    return outVal;\n  }\n\n  //---------------------------------------------------------------------------\n  // _verifyExecOpts\n  //\n  // Verify that the value passed by the user for binds is acceptable. Perform\n  // any transformations necessary.\n  //---------------------------------------------------------------------------\n  _verifyExecOpts(options, inExecuteMany) {\n    // define normalized options (value returned to caller)\n    const outOptions = {};\n\n    // handle common options\n    errors.assertParamValue(nodbUtil.isObject(options), 3);\n\n    // autoCommit must be a boolean value\n    if (options.autoCommit !== undefined) {\n      errors.assertParamPropValue(typeof options.autoCommit === 'boolean', 3, \"autoCommit\");\n      outOptions.autoCommit = options.autoCommit;\n    }\n\n    // dbObjectAsPojo must be a boolean value\n    if (options.dbObjectAsPojo !== undefined) {\n      errors.assertParamPropValue(typeof options.dbObjectAsPojo === 'boolean', 3, \"dbObjectAsPojo\");\n      outOptions.dbObjectAsPojo = options.dbObjectAsPojo;\n    }\n\n    // keepInStmtCache must be a boolean value\n    if (options.keepInStmtCache !== undefined) {\n      errors.assertParamPropValue(typeof options.keepInStmtCache === 'boolean', 3, \"keepInStmtCache\");\n      outOptions.keepInStmtCache = options.keepInStmtCache;\n    }\n\n    // handle options specific to executeMany()\n    if (inExecuteMany) {\n      // bindDefs must be an object or array\n      if (options.bindDefs !== undefined) {\n        errors.assertParamPropValue(nodbUtil.isObjectOrArray(options.bindDefs), 3, \"bindDefs\");\n        outOptions.bindDefs = options.bindDefs;\n      }\n\n      // batchErrors must be a boolean value\n      if (options.batchErrors !== undefined) {\n        errors.assertParamPropValue(typeof options.batchErrors === 'boolean', 3, \"batchErrors\");\n        outOptions.batchErrors = options.batchErrors;\n      }\n\n      // dmlRowCounts must be a boolean value\n      if (options.dmlRowCounts !== undefined) {\n        errors.assertParamPropValue(typeof options.dmlRowCounts === 'boolean', 3, \"dmlRowCounts\");\n        outOptions.dmlRowCounts = options.dmlRowCounts;\n      }\n\n      // handle options specific to execute()\n    } else {\n      // fetchArraySize must be a positive integer\n      errors.assertParamPropUnsignedIntNonZero(options, 3, \"fetchArraySize\");\n      outOptions.fetchArraySize = options.fetchArraySize;\n\n      // fetchInfo must be an object with keys containing an object with a\n      // \"type\" property; these are converted to an array of objects for ease\n      // of processing by the implementation\n      if (options.fetchInfo !== undefined) {\n        errors.assertParamPropValue(nodbUtil.isObject(options.fetchInfo), 3, \"fetchInfo\");\n        const names = Object.getOwnPropertyNames(options.fetchInfo);\n        const map = new Map(settings.fetchTypeMap);\n        for (const name of names) {\n          const info = options.fetchInfo[name];\n          if (info.type === undefined) errors.throwErr(errors.ERR_NO_TYPE_FOR_CONVERSION);\n          if (info.type !== constants.DEFAULT && info.type !== types.DB_TYPE_VARCHAR && info.type !== types.DB_TYPE_RAW) {\n            errors.throwErr(errors.ERR_INVALID_TYPE_FOR_CONVERSION);\n          }\n          map.set(name, info.type);\n        }\n        outOptions.fetchTypeMap = map;\n      }\n\n      // fetchTypeHandler must be a function which is called for each column to\n      // be fetched and accepts the metadata for a column\n      if (options.fetchTypeHandler !== undefined) {\n        const type = typeof options.fetchTypeHandler;\n        errors.assertParamPropValue(type === 'function', 3, \"fetchTypeHandler\");\n        outOptions.fetchTypeHandler = options.fetchTypeHandler;\n      }\n\n      // maxRows must be a positive integer (or 0)\n      if (options.maxRows !== undefined) {\n        errors.assertParamPropValue(Number.isInteger(options.maxRows) && options.maxRows >= 0, 3, \"maxRows\");\n        outOptions.maxRows = options.maxRows;\n      }\n\n      // outFormat must be one of the two possible constants\n      if (options.outFormat !== undefined) {\n        errors.assertParamPropValue(options.outFormat === constants.OUT_FORMAT_ARRAY || options.outFormat === constants.OUT_FORMAT_OBJECT, 3, \"outFormat\");\n        outOptions.outFormat = options.outFormat;\n      }\n\n      // prefetchRows must be a positive integer (or 0)\n      if (options.prefetchRows !== undefined) {\n        errors.assertParamPropValue(Number.isInteger(options.prefetchRows) && options.prefetchRows >= 0, 3, \"prefetchRows\");\n        outOptions.prefetchRows = options.prefetchRows;\n      }\n\n      // resultSet must be a boolean value\n      if (options.resultSet !== undefined) {\n        errors.assertParamPropValue(typeof options.resultSet === 'boolean', 3, \"resultSet\");\n        outOptions.resultSet = options.resultSet;\n      }\n    }\n    return outOptions;\n  }\n\n  //---------------------------------------------------------------------------\n  // action\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get action() {\n    return null;\n  }\n  set action(value) {\n    errors.assertPropValue(typeof value === 'string', \"action\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setAction(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // breakExecution()\n  //\n  // Breaks execution of a running statement.\n  //---------------------------------------------------------------------------\n  async breakExecution() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.breakExecution();\n  }\n\n  //---------------------------------------------------------------------------\n  // callTimeout\n  //\n  // Property for round-trip timeouts.\n  //---------------------------------------------------------------------------\n  get callTimeout() {\n    if (this._impl) return this._impl.getCallTimeout();\n    return undefined;\n  }\n  set callTimeout(value) {\n    errors.assertPropValue(Number.isInteger(value) && value >= 0, \"callTimeout\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setCallTimeout(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // changePassword()\n  //\n  // Changes the password of the specified user.\n  //---------------------------------------------------------------------------\n  async changePassword(user, password, newPassword) {\n    errors.assertArgCount(arguments, 3, 3);\n    errors.assertParamValue(typeof user === 'string', 1);\n    errors.assertParamValue(typeof password === 'string', 2);\n    errors.assertParamValue(typeof newPassword === 'string', 3);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.changePassword(user, password, newPassword);\n  }\n\n  //---------------------------------------------------------------------------\n  // clientId\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get clientId() {\n    return null;\n  }\n  set clientId(value) {\n    errors.assertPropValue(typeof value === 'string', \"clientId\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setClientId(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // clientInfo\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get clientInfo() {\n    return null;\n  }\n  set clientInfo(value) {\n    errors.assertPropValue(typeof value === 'string', \"clientInfo\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setClientInfo(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // close()\n  //\n  // Closes the connection and makes it unusable for further work.\n  //---------------------------------------------------------------------------\n  async close(a1) {\n    let options = {};\n    errors.assertArgCount(arguments, 0, 1);\n    if (arguments.length == 1) {\n      errors.assertParamValue(nodbUtil.isObject(a1), 1);\n      options = a1;\n      errors.assertParamPropBool(options, 1, \"drop\");\n    }\n    errors.assert(this._impl && !this._closing, errors.ERR_INVALID_CONNECTION);\n    this._closing = true;\n    try {\n      await this._impl.close(options);\n    } finally {\n      this._closing = false;\n    }\n    delete this._impl;\n    this._dbObjectClasses.clear();\n    this.emit('_afterConnClose');\n  }\n\n  //---------------------------------------------------------------------------\n  // commit()\n  //\n  // Commits the current transaction.\n  //---------------------------------------------------------------------------\n  async commit() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.commit();\n  }\n\n  //---------------------------------------------------------------------------\n  // createLob()\n  //\n  // Creates a temporary LOB and returns it to the caller.\n  //---------------------------------------------------------------------------\n  async createLob(type) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(type === types.DB_TYPE_CLOB || type === types.DB_TYPE_BLOB || type === types.DB_TYPE_NCLOB, 1);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const lob = new Lob();\n    lob._setup(await this._impl.createLob(type), false);\n    return lob;\n  }\n\n  //---------------------------------------------------------------------------\n  // currentSchema\n  //\n  // Property for identifying the current schema to use in the database.\n  //---------------------------------------------------------------------------\n  get currentSchema() {\n    if (this._impl) return this._impl.getCurrentSchema();\n    return undefined;\n  }\n  set currentSchema(value) {\n    errors.assertPropValue(typeof value === 'string', \"currentSchema\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setCurrentSchema(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // dbOp\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get dbOp() {\n    return null;\n  }\n  set dbOp(value) {\n    errors.assertPropValue(typeof value === 'string', \"dbOp\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setDbOp(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // thin()\n  //\n  // return true, if driver mode is thin while acquiring connection\n  // return false, if driver mode is thick while acquiring connection\n  //---------------------------------------------------------------------------\n  get thin() {\n    return settings.thin;\n  }\n\n  //---------------------------------------------------------------------------\n  // ecid\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get ecid() {\n    return null;\n  }\n  set ecid(value) {\n    errors.assertPropValue(typeof value === 'string', \"ecid\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setECID(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // decode()\n  //\n  // Decodes OSON Buffer to JS data type.\n  //---------------------------------------------------------------------------\n  decodeOSON(buf) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(Buffer.isBuffer(buf), 1);\n    const decoder = new oson.OsonDecoder(buf);\n    return decoder.decode();\n  }\n\n  //---------------------------------------------------------------------------\n  // encode()\n  //\n  // Encodes the JS value into OSON bytes.\n  //---------------------------------------------------------------------------\n  encodeOSON(value) {\n    const encoder = new oson.OsonEncoder();\n    return encoder.encode(transformer.transformJsonValue(value), this._impl._osonMaxFieldNameSize);\n  }\n\n  //---------------------------------------------------------------------------\n  // execute()\n  //\n  // Executes a SQL statement and returns the results.\n  //---------------------------------------------------------------------------\n  async execute(sql, a2, a3) {\n    const numIters = 1;\n    let binds = [];\n    let options = {};\n\n    // process arguments\n    if (nodbUtil.isObject(sql) && typeof sql.statement === 'string') {\n      errors.assertArgCount(arguments, 1, 2);\n      if (sql.values) {\n        binds = await this._processExecuteBinds(sql.values);\n      }\n      sql = sql.statement;\n      if (arguments.length == 2) {\n        options = this._verifyExecOpts(a2, false);\n      }\n    } else {\n      errors.assertArgCount(arguments, 1, 3);\n      errors.assertParamValue(typeof sql === 'string', 1);\n      if (arguments.length >= 2) {\n        binds = await this._processExecuteBinds(a2);\n      }\n      if (arguments.length == 3) {\n        options = this._verifyExecOpts(a3, false);\n      }\n    }\n    this._addDefaultsToExecOpts(options);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    // perform actual execute\n    let result;\n    try {\n      result = await this._impl.execute(sql, numIters, binds, options, false);\n    } catch (err) {\n      if (err.errorNum === 1406) errors.throwErr(errors.ERR_INSUFFICIENT_BUFFER_FOR_BINDS);\n      throw err;\n    }\n\n    // convert ORA errors to NJS\n    if (result.warning) {\n      result.warning = errors.transformErr(result.warning);\n    }\n\n    // process queries; if a result set is not desired, fetch all of the rows\n    // from the result set and then destroy the result set\n    if (result.resultSet !== undefined) {\n      const resultSet = new ResultSet();\n      resultSet._setup(this, result.resultSet);\n      result.metaData = resultSet._impl.metaData;\n      if (options.resultSet) {\n        result.resultSet = resultSet;\n      } else {\n        result.rows = await resultSet._getAllRows();\n        delete result.resultSet;\n      }\n    }\n\n    // process output binds\n    if (result.outBinds !== undefined) {\n      for (const [key, value] of Object.entries(result.outBinds)) {\n        const val = this._transformOutBind(value, options);\n        result.outBinds[key] = val;\n      }\n    }\n\n    // process implicit results; ensure all implicit results have their fetch\n    // array size fixed, or, if a result set is not requested, that all rows\n    // are fetched\n    if (result.implicitResults) {\n      for (const [key, impl] of Object.entries(result.implicitResults)) {\n        const resultSet = new ResultSet();\n        resultSet._setup(this, impl);\n        if (options.resultSet) {\n          result.implicitResults[key] = resultSet;\n        } else {\n          result.implicitResults[key] = await resultSet._getAllRows();\n        }\n      }\n    }\n    return result;\n  }\n\n  //---------------------------------------------------------------------------\n  // executeMany()\n  //\n  // Executes a SQL statement multiple times and returns the results.\n  //---------------------------------------------------------------------------\n  async executeMany(sql, bindsOrNumIters, a3) {\n    let options = {};\n    let binds = [];\n    let numIters;\n    errors.assertArgCount(arguments, 2, 3);\n    errors.assertParamValue(typeof sql === 'string', 1);\n    if (arguments.length == 3) {\n      options = this._verifyExecOpts(a3, true);\n    }\n    this._addDefaultsToExecOpts(options);\n    if (typeof bindsOrNumIters === 'number') {\n      errors.assertParamValue(Number.isInteger(bindsOrNumIters) && bindsOrNumIters > 0, 2);\n      numIters = bindsOrNumIters;\n      if (options.bindDefs !== undefined) {\n        binds = await this._processExecuteManyBinds([], options.bindDefs);\n      }\n    } else {\n      errors.assertParamValue(Array.isArray(bindsOrNumIters) && bindsOrNumIters.length > 0, 2);\n      numIters = bindsOrNumIters.length;\n      binds = await this._processExecuteManyBinds(bindsOrNumIters, options.bindDefs);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const result = await this._impl.execute(sql, numIters, binds, options, true);\n\n    // convert ORA warnings to NJS\n    if (result.warning) {\n      result.warning = errors.transformErr(result.warning);\n    }\n\n    // process output binds\n    if (result.outBinds !== undefined) {\n      for (let i = 0; i < result.outBinds.length; i++) {\n        const outBind = result.outBinds[i];\n        for (const [key, value] of Object.entries(outBind)) {\n          outBind[key] = this._transformOutBind(value, options);\n        }\n      }\n    }\n    return result;\n  }\n\n  //---------------------------------------------------------------------------\n  // externalName\n  //\n  // Property for identifying the external name to use in TPC logging.\n  //---------------------------------------------------------------------------\n  get externalName() {\n    if (this._impl) return this._impl.getExternalName();\n    return undefined;\n  }\n  set externalName(value) {\n    errors.assertPropValue(typeof value === 'string', \"externalName\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setExternalName(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // dbDomain (READONLY)\n  //\n  // Property for identifying the dbDomain of the Oracle Database.\n  //---------------------------------------------------------------------------\n  get dbDomain() {\n    return this._impl && this._impl.getDbDomain();\n  }\n\n  //---------------------------------------------------------------------------\n  // dbName (READONLY)\n  //\n  // Property for identifying the dbName of the Oracle Database.\n  //---------------------------------------------------------------------------\n  get dbName() {\n    return this._impl && this._impl.getDbName();\n  }\n\n  //---------------------------------------------------------------------------\n  // getDbObjectClass()\n  //\n  // Returns a database object class given its name. The cache is searched\n  // first, but if not found, the database is queried and the result is cached\n  // using the type information (as well as the name for easier lookup later).\n  //---------------------------------------------------------------------------\n  async getDbObjectClass(name) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(typeof name === 'string', 1);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    return await this._getDbObjectClassForName(name);\n  }\n\n  //---------------------------------------------------------------------------\n  // getQueue()\n  //\n  // Returns a queue with the specified name.\n  //---------------------------------------------------------------------------\n  async getQueue(name, a2) {\n    let options = {};\n    errors.assertArgCount(arguments, 1, 2);\n    errors.assertParamValue(typeof name === 'string', 1);\n    if (arguments.length == 2) {\n      errors.assertParamValue(nodbUtil.isObject(a2), 2);\n      options = {\n        ...a2\n      };\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const queue = new AqQueue();\n    await queue.create(this, name, options);\n    return queue;\n  }\n\n  //---------------------------------------------------------------------------\n  // getSodaDatabase()\n  //\n  // Returns a SodaDatabase object (high-level SODA object associated with\n  // the current connection).\n  //---------------------------------------------------------------------------\n  getSodaDatabase() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const sodaDb = new SodaDatabase();\n    sodaDb._impl = this._impl.getSodaDatabase();\n    return sodaDb;\n  }\n\n  //---------------------------------------------------------------------------\n  // getStatementInfo()\n  //\n  // Returns information about the statement.\n  //---------------------------------------------------------------------------\n  async getStatementInfo(sql) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(typeof sql === 'string', 1);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const info = await this._impl.getStatementInfo(sql);\n    if (info.metaData) {\n      for (let i = 0; i < info.metaData.length; i++) {\n        const m = info.metaData[i];\n        nodbUtil.addTypeProperties(m, \"dbType\");\n        m.fetchType = types.DB_TYPE_FETCH_TYPE_MAP.get(m.dbType);\n      }\n    }\n    return info;\n  }\n\n  //---------------------------------------------------------------------------\n  // instanceName\n  //\n  // Returns the Oracle Database instance name associated with the connection.\n  // This is the equivalent of the SQL expression:\n  // sys_context('userenv', 'instance_name')\n  //---------------------------------------------------------------------------\n  get instanceName() {\n    if (this._impl) return this._impl.getInstanceName();\n    return undefined;\n  }\n\n  //---------------------------------------------------------------------------\n  // internalName\n  //\n  // Property for identifying the internal name to use in TPC logging.\n  //---------------------------------------------------------------------------\n  get internalName() {\n    if (this._impl) return this._impl.getInternalName();\n    return undefined;\n  }\n  set internalName(value) {\n    errors.assertPropValue(typeof value === 'string', \"internalName\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setInternalName(value);\n  }\n\n  //--------------------------------------------------------------------------\n  // isHealthy()\n  //\n  // Returns the health status of the connection. If this function returns\n  // false, the caller should close the connection.\n  //---------------------------------------------------------------------------\n  isHealthy() {\n    return this._impl !== undefined && !this._closing && this._impl.isHealthy();\n  }\n\n  //---------------------------------------------------------------------------\n  // maxOpenCursors\n  //\n  // Returns maximum number of cursors that can be opened in one session.\n  //---------------------------------------------------------------------------\n  get maxOpenCursors() {\n    return this._impl && this._impl.getMaxOpenCursors();\n  }\n\n  //---------------------------------------------------------------------------\n  // warning\n  //\n  // Returns warningInfo.\n  //---------------------------------------------------------------------------\n  get warning() {\n    let warning = this._impl.getWarning();\n    if (warning) {\n      // Make sure that warning code attribute is populated and ORA error\n      // is converted to NJS, if required\n      warning = errors.transformErr(warning);\n    }\n    return this._impl && warning;\n  }\n\n  //---------------------------------------------------------------------------\n  // module\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get module() {\n    return null;\n  }\n  set module(value) {\n    errors.assertPropValue(typeof value === 'string', \"module\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setModule(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // oracleServerVersion\n  //\n  // Returns an integer identifying the Oracle Server version.\n  //---------------------------------------------------------------------------\n  get oracleServerVersion() {\n    if (this._impl) return this._impl.getOracleServerVersion();\n    return undefined;\n  }\n\n  //---------------------------------------------------------------------------\n  // oracleServerVersionString\n  //\n  // Returns a string identifying the Oracle Server version.\n  //---------------------------------------------------------------------------\n  get oracleServerVersionString() {\n    if (this._impl) return this._impl.getOracleServerVersionString();\n    return undefined;\n  }\n\n  //---------------------------------------------------------------------------\n  // serviceName\n  //\n  // Returns the Oracle Database service name associated with the connection.\n  //---------------------------------------------------------------------------\n  get serviceName() {\n    return this._impl && this._impl.getServiceName();\n  }\n\n  //---------------------------------------------------------------------------\n  // transactionInProgress\n  //\n  // Returns a boolean value based on the presence of an active transaction\n  // on the connection\n  //---------------------------------------------------------------------------\n  get transactionInProgress() {\n    return this._impl && this._impl.getTransactionInProgress();\n  }\n\n  //---------------------------------------------------------------------------\n  // ping()\n  //\n  // Sends a \"ping\" to the database to see if it is \"alive\".\n  //---------------------------------------------------------------------------\n  async ping() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.ping();\n  }\n\n  //--------------------------------------------------------------------------\n  // queryStream()\n  //\n  // Similar to execute() except that it immediately returns a QueryStream\n  // object.\n  // ---------------------------------------------------------------------------\n  queryStream(sql, binds, options) {\n    errors.assertArgCount(arguments, 1, 3);\n    errors.assertParamValue(typeof sql === 'string', 1);\n    if (arguments.length == 3) {\n      errors.assertParamValue(nodbUtil.isObject(options), 3);\n      options = {\n        ...options\n      };\n    } else {\n      options = {};\n    }\n    options.resultSet = true;\n    const stream = new QueryStream();\n\n    // calling execute() via nextTick to ensure that handlers are registered\n    // prior to the events being emitted\n    process.nextTick(async () => {\n      try {\n        const result = await this.execute(sql, binds || [], options);\n        if (!result.resultSet) errors.throwErr(errors.ERR_NOT_A_QUERY);\n        stream._open(result.resultSet);\n      } catch (err) {\n        stream.destroy(err);\n        return;\n      }\n    });\n    return stream;\n  }\n\n  //---------------------------------------------------------------------------\n  // rollback()\n  //\n  // Rolls back the current transaction.\n  //---------------------------------------------------------------------------\n  async rollback() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.rollback();\n  }\n\n  //---------------------------------------------------------------------------\n  // shutdown()\n  //   Shuts down the database instance.\n  //---------------------------------------------------------------------------\n  async shutdown(a1) {\n    let mode = constants.SHUTDOWN_MODE_DEFAULT;\n    errors.assertArgCount(arguments, 0, 1);\n    if (a1 !== undefined) {\n      errors.assertParamValue(typeof mode === 'number', 1);\n      mode = a1;\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.shutdown(mode);\n  }\n\n  //---------------------------------------------------------------------------\n  // startup()\n  //   Starts up the database instance.\n  //---------------------------------------------------------------------------\n  async startup(a1) {\n    let options = {};\n    errors.assertArgCount(arguments, 0, 1);\n    if (arguments.length == 1) {\n      errors.assertParamValue(typeof options === 'object', 1);\n      options = a1;\n      errors.assertParamPropBool(options, 1, \"force\");\n      errors.assertParamPropBool(options, 1, \"restrict\");\n      errors.assertParamPropString(options, 1, \"pfile\");\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.startup(options);\n  }\n\n  //---------------------------------------------------------------------------\n  // stmtCacheSize\n  //\n  // Property for statement cache size.\n  //---------------------------------------------------------------------------\n  get stmtCacheSize() {\n    if (this._impl) return this._impl.getStmtCacheSize();\n    return undefined;\n  }\n  set stmtCacheSize(value) {\n    errors.assertPropValue(Number.isInteger(value) && value >= 0, \"stmtCacheSize\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setStmtCacheSize(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // subscribe()\n  //\n  // Creates a subscription which can be used to get notifications of database\n  // changes or of AQ messages available to dequeue.\n  //---------------------------------------------------------------------------\n  async subscribe(name, options) {\n    errors.assertArgCount(arguments, 2, 2);\n    errors.assertParamValue(typeof name === 'string', 1);\n    errors.assertParamValue(nodbUtil.isObject(options), 2);\n    options = {\n      name: name,\n      ...options\n    };\n    errors.assertParamPropUnsignedInt(options, 2, \"namespace\");\n    if (options.namespace === undefined) options.namespace = constants.SUBSCR_NAMESPACE_DBCHANGE;\n    errors.assertParamPropString(options, 2, \"ipAddress\");\n    errors.assertParamPropUnsignedInt(options, 2, \"port\");\n    errors.assertParamPropUnsignedInt(options, 2, \"timeout\");\n    errors.assertParamPropUnsignedInt(options, 2, \"operations\");\n    errors.assertParamPropUnsignedInt(options, 2, \"qos\");\n    errors.assertParamPropUnsignedInt(options, 2, \"groupingClass\");\n    errors.assertParamPropUnsignedInt(options, 2, \"groupingValue\");\n    errors.assertParamPropUnsignedInt(options, 2, \"groupingType\");\n    errors.assertParamPropBool(options, 2, \"clientInitiated\");\n    errors.assertParamPropFunction(options, 2, \"callback\");\n    errors.assert(options.callback, errors.ERR_MISSING_SUBSCR_CALLBACK);\n    if (options.namespace === constants.SUBSCR_NAMESPACE_DBCHANGE) {\n      errors.assertParamPropString(options, 2, \"sql\");\n      errors.assert(options.sql && options.sql.length > 0, errors.ERR_MISSING_SUBSCR_SQL);\n      if (options.binds !== undefined) {\n        options.binds = await this._processExecuteBinds(options.binds);\n      }\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const inSubscr = _subscriptions.get(name);\n    const outValue = await this._impl.subscribe(inSubscr, options);\n    let subscription;\n    if (options.namespace === constants.SUBSCR_NAMESPACE_DBCHANGE) {\n      subscription = outValue.subscription;\n      delete outValue.subscription;\n    } else {\n      subscription = outValue;\n    }\n    _subscriptions.set(name, subscription);\n    return outValue;\n  }\n\n  //---------------------------------------------------------------------------\n  // tag\n  //\n  // Property for tag to associate with the connection.\n  //---------------------------------------------------------------------------\n  get tag() {\n    if (this._impl) return this._impl.getTag();\n    return undefined;\n  }\n  set tag(value) {\n    errors.assertPropValue(typeof value === 'string', \"tag\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setTag(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcBegin()\n  //\n  // Starts a two-phase-commit transaction.\n  //--------------------------------------------------------------------------\n  async tpcBegin(xid, flag, timeout) {\n    errors.assertArgCount(arguments, 1, 3);\n    errors.assertParamValue(nodbUtil.isXid(xid), 1);\n    const normalizedXid = nodbUtil.normalizeXid(xid);\n    if (arguments.length < 3) {\n      timeout = 60; // seconds\n    } else {\n      errors.assertParamValue(typeof timeout === 'number', 3);\n    }\n    if (arguments.length < 2) {\n      flag = constants.TPC_BEGIN_NEW;\n    } else {\n      errors.assertParamValue(typeof flag === 'number', 2);\n      const options = [constants.TPC_BEGIN_NEW, constants.TPC_BEGIN_JOIN, constants.TPC_BEGIN_RESUME, constants.TPC_BEGIN_PROMOTE];\n      if (options.indexOf(flag) < 0) {\n        errors.throwErr(errors.ERR_INVALID_TPC_BEGIN_FLAGS);\n      }\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.tpcBegin(normalizedXid, flag, timeout);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcCommit()\n  //\n  // Commits a two-phase-commit transaction.\n  //---------------------------------------------------------------------------\n  async tpcCommit(xid, onePhase) {\n    errors.assertArgCount(arguments, 0, 2);\n    if (arguments.length < 2) {\n      onePhase = false;\n    } else {\n      errors.assertParamValue(typeof onePhase === 'boolean', 2);\n    }\n    let normalizedXid;\n    if (arguments.length >= 1) {\n      errors.assertParamValue(nodbUtil.isXid(xid), 1);\n      normalizedXid = nodbUtil.normalizeXid(xid);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.tpcCommit(normalizedXid, onePhase);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcEnd()\n  //\n  // Ends a two-phase-commit transaction.\n  //---------------------------------------------------------------------------\n  async tpcEnd(xid, flag) {\n    errors.assertArgCount(arguments, 0, 2);\n    if (arguments.length < 2) {\n      flag = constants.TPC_END_NORMAL;\n    } else {\n      errors.assertParamValue(typeof flag === 'number', 2);\n      const options = [constants.TPC_END_NORMAL, constants.TPC_END_SUSPEND];\n      if (!options.includes(flag)) {\n        errors.throwErr(errors.ERR_INVALID_TPC_END_FLAGS);\n      }\n    }\n    let normalizedXid;\n    if (arguments.length >= 1) {\n      errors.assertParamValue(nodbUtil.isXid(xid), 1);\n      normalizedXid = nodbUtil.normalizeXid(xid);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.tpcEnd(normalizedXid, flag);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcForget()\n  //\n  // Causes the server to forget a heuristically completed two-phase-commit\n  // transaction.\n  // ---------------------------------------------------------------------------\n  async tpcForget(xid) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(nodbUtil.isXid(xid), 1);\n    const normalizedXid = nodbUtil.normalizeXid(xid);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.tpcForget(normalizedXid);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcPrepare()\n  //\n  // Prepares a two-phase-commit transaction for commit.\n  //---------------------------------------------------------------------------\n  async tpcPrepare(xid) {\n    errors.assertArgCount(arguments, 0, 1);\n    let normalizedXid;\n    if (arguments.length >= 1) {\n      errors.assertParamValue(nodbUtil.isXid(xid), 1);\n      normalizedXid = nodbUtil.normalizeXid(xid);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    return await this._impl.tpcPrepare(normalizedXid);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcRecover()\n  //\n  // Returns a list of pending two-phase-commit transactions.\n  //---------------------------------------------------------------------------\n  async tpcRecover(asString) {\n    errors.assertArgCount(arguments, 0, 1);\n    if (arguments.length == 1) {\n      errors.assertParamValue(typeof asString === 'boolean', 1);\n    } else {\n      asString = true;\n    }\n    const sqlStr = `\n      SELECT\n          formatid as \"formatId\",\n          UTL_RAW.CAST_TO_VARCHAR2(globalid) as \"globalTransactionId\",\n          UTL_RAW.CAST_TO_VARCHAR2(branchid) as \"branchQualifier\"\n      FROM DBA_PENDING_TRANSACTIONS`;\n    const sqlBuf = `\n      SELECT\n          formatid as \"formatId\",\n          globalid as \"globalTransactionId\",\n          branchid as \"branchQualifier\"\n      FROM DBA_PENDING_TRANSACTIONS`;\n    const options = {\n      outFormat: constants.OUT_FORMAT_OBJECT,\n      resultSet: false\n    };\n    const result = await this.execute(asString ? sqlStr : sqlBuf, {}, options);\n    return result.rows;\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcRollback()\n  //\n  // Rolls back the current changes in a two-phase-commit transaction.\n  //---------------------------------------------------------------------------\n  async tpcRollback(xid) {\n    errors.assertArgCount(arguments, 0, 1);\n    let normalizedXid;\n    if (arguments.length == 1) {\n      errors.assertParamValue(nodbUtil.isXid(xid), 1);\n      normalizedXid = nodbUtil.normalizeXid(xid);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.tpcRollback(normalizedXid);\n  }\n\n  //---------------------------------------------------------------------------\n  // unsubscribe()\n  //\n  // Destroy a subscription which was earlier created using subscribe().\n  //---------------------------------------------------------------------------\n  async unsubscribe(name) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(typeof name === 'string', 1);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    errors.assert(_subscriptions.has(name), errors.ERR_INVALID_SUBSCR);\n    await this._impl.unsubscribe(_subscriptions.get(name));\n    _subscriptions.delete(name);\n  }\n}\n\n// adjust functions to support the old callback style and to serialize calls\n// that cannot take place concurrently\n// NOTE: breakExecution() should not be serialized\nConnection.prototype.break = nodbUtil.callbackify(Connection.prototype.breakExecution);\nConnection.prototype.tpcRecover = nodbUtil.callbackify(Connection.prototype.tpcRecover);\nnodbUtil.wrapFns(Connection.prototype, \"changePassword\", \"close\", \"commit\", \"createLob\", \"execute\", \"executeMany\", \"getDbObjectClass\", \"getQueue\", \"getStatementInfo\", \"ping\", \"rollback\", \"shutdown\", \"startup\", \"subscribe\", \"tpcBegin\", \"tpcCommit\", \"tpcEnd\", \"tpcForget\", \"tpcPrepare\", \"tpcRollback\", \"unsubscribe\");\n\n// add alias for release()\nConnection.prototype.release = Connection.prototype.close;\n\n// export just the Connection class\nmodule.exports = Connection;","map":{"version":3,"names":["AqQueue","require","BaseDbObject","Buffer","Lob","ResultSet","SodaDatabase","EventEmitter","QueryStream","errors","nodbUtil","impl","process","util","constants","settings","transformer","types","oson","_subscriptions","Map","Connection","constructor","_dbObjectClasses","_closing","_addDefaultsToExecOpts","options","connection","keepInStmtCache","undefined","addToOptions","_buildDbObjectClass","objType","DbObject","initialValue","_impl","DbObjectImpl","isCollection","proxy","Proxy","_collectionProxyHandler","i","length","append","Object","assign","prototype","create","_objType","elementTypeClass","cls","_getDbObjectClass","addTypeProperties","elementTypeInfo","type","elementType","attributes","props","attr","typeClass","prop","get","_getAttrValue","set","value","_setAttrValue","name","defineProperties","toString","fqn","_connection","_getDbObjectClassForName","getDbObjectClass","_isBindDir","BIND_IN","BIND_OUT","BIND_INOUT","_isBindValue","Array","isArray","isVectorValue","isBuffer","isDate","_processBindUnit","bindInfo","bindUnit","inExecuteMany","okBindUnit","dir","assert","ERR_INVALID_BIND_DIRECTION","DB_TYPE_OBJECT","DbType","ERR_INVALID_BIND_DATA_TYPE","throwErr","ERR_MISSING_TYPE_BY_NAME","ERR_MISSING_TYPE_BY_POS","pos","maxSize","assertParamPropValue","Number","isInteger","checkSize","DB_TYPE_VARCHAR","DB_TYPE_RAW","ERR_MISSING_MAX_SIZE_BY_NAME","ERR_MISSING_MAX_SIZE_BY_POS","DEFAULT_MAX_SIZE_FOR_OUT_BINDS","maxArraySize","val","ERR_INVALID_BIND_UNIT","_processBindValue","transformed","transformValueIn","values","concat","slice","_processExecuteBind","bindData","bindValue","allowArray","DB_TYPE_NVARCHAR","DB_TYPE_CHAR","DB_TYPE_NCHAR","DB_TYPE_NUMBER","DB_TYPE_BINARY_FLOAT","DB_TYPE_BINARY_DOUBLE","DB_TYPE_DATE","DB_TYPE_TIMESTAMP","DB_TYPE_TIMESTAMP_LTZ","DB_TYPE_TIMESTAMP_TZ","ERR_INVALID_TYPE_FOR_ARRAY_BIND","_processExecuteBinds","binds","normBinds","assertParamValue","isObject","bindNames","getOwnPropertyNames","_processExecuteManyBinds","bindDefs","byPosition","row","isObjectOrArray","ERR_MIXED_BIND","j","_transformOutBind","outVal","push","ResultSetImpl","_setup","LobImpl","dbObjectAsPojo","_toPojo","_verifyExecOpts","outOptions","autoCommit","batchErrors","dmlRowCounts","assertParamPropUnsignedIntNonZero","fetchArraySize","fetchInfo","names","map","fetchTypeMap","info","ERR_NO_TYPE_FOR_CONVERSION","DEFAULT","ERR_INVALID_TYPE_FOR_CONVERSION","fetchTypeHandler","maxRows","outFormat","OUT_FORMAT_ARRAY","OUT_FORMAT_OBJECT","prefetchRows","resultSet","action","assertPropValue","ERR_INVALID_CONNECTION","setAction","breakExecution","assertArgCount","arguments","callTimeout","getCallTimeout","setCallTimeout","changePassword","user","password","newPassword","clientId","setClientId","clientInfo","setClientInfo","close","a1","assertParamPropBool","clear","emit","commit","createLob","DB_TYPE_CLOB","DB_TYPE_BLOB","DB_TYPE_NCLOB","lob","currentSchema","getCurrentSchema","setCurrentSchema","dbOp","setDbOp","thin","ecid","setECID","decodeOSON","buf","decoder","OsonDecoder","decode","encodeOSON","encoder","OsonEncoder","encode","transformJsonValue","_osonMaxFieldNameSize","execute","sql","a2","a3","numIters","statement","result","err","errorNum","ERR_INSUFFICIENT_BUFFER_FOR_BINDS","warning","transformErr","metaData","rows","_getAllRows","outBinds","key","entries","implicitResults","executeMany","bindsOrNumIters","outBind","externalName","getExternalName","setExternalName","dbDomain","getDbDomain","dbName","getDbName","getQueue","queue","getSodaDatabase","sodaDb","getStatementInfo","m","fetchType","DB_TYPE_FETCH_TYPE_MAP","dbType","instanceName","getInstanceName","internalName","getInternalName","setInternalName","isHealthy","maxOpenCursors","getMaxOpenCursors","getWarning","module","setModule","oracleServerVersion","getOracleServerVersion","oracleServerVersionString","getOracleServerVersionString","serviceName","getServiceName","transactionInProgress","getTransactionInProgress","ping","queryStream","stream","nextTick","ERR_NOT_A_QUERY","_open","destroy","rollback","shutdown","mode","SHUTDOWN_MODE_DEFAULT","startup","assertParamPropString","stmtCacheSize","getStmtCacheSize","setStmtCacheSize","subscribe","assertParamPropUnsignedInt","namespace","SUBSCR_NAMESPACE_DBCHANGE","assertParamPropFunction","callback","ERR_MISSING_SUBSCR_CALLBACK","ERR_MISSING_SUBSCR_SQL","inSubscr","outValue","subscription","tag","getTag","setTag","tpcBegin","xid","flag","timeout","isXid","normalizedXid","normalizeXid","TPC_BEGIN_NEW","TPC_BEGIN_JOIN","TPC_BEGIN_RESUME","TPC_BEGIN_PROMOTE","indexOf","ERR_INVALID_TPC_BEGIN_FLAGS","tpcCommit","onePhase","tpcEnd","TPC_END_NORMAL","TPC_END_SUSPEND","includes","ERR_INVALID_TPC_END_FLAGS","tpcForget","tpcPrepare","tpcRecover","asString","sqlStr","sqlBuf","tpcRollback","unsubscribe","has","ERR_INVALID_SUBSCR","delete","break","callbackify","wrapFns","release","exports"],"sources":["C:/Users/Koliv/Desktop/Software/my-react-app/node_modules/oracledb/lib/connection.js"],"sourcesContent":["// Copyright (c) 2016, 2024, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst AqQueue = require('./aqQueue.js');\nconst BaseDbObject = require('./dbObject.js');\nconst { Buffer } = require('buffer');\nconst Lob = require('./lob.js');\nconst ResultSet = require('./resultset.js');\nconst SodaDatabase = require('./sodaDatabase.js');\nconst EventEmitter = require('events');\nconst QueryStream = require('./queryStream.js');\nconst errors = require('./errors.js');\nconst nodbUtil = require('./util.js');\nconst impl = require('./impl');\nconst process = require('process');\nconst util = require('util');\nconst constants = require('./constants.js');\nconst settings = require('./settings.js');\nconst transformer = require('./transformer.js');\nconst types = require('./types.js');\nconst oson = require('./impl/datahandlers/oson.js');\n\n// global mapping of subscriptions; these cannot be tied to a particular\n// connection or pool since subscriptions can be created with one connection\n// and destroyed with another!\nconst _subscriptions = new Map();\n\n// define class\nclass Connection extends EventEmitter {\n\n  constructor() {\n    super();\n    this._dbObjectClasses = new Map();\n    this._closing = false;\n  }\n\n  //---------------------------------------------------------------------------\n  // _addDefaultsToExecOpts()\n  //\n  // Add values to the execute options from the global settings, if needed.\n  //---------------------------------------------------------------------------\n  _addDefaultsToExecOpts(options) {\n    options.connection = this;\n    if (options.keepInStmtCache === undefined)\n      options.keepInStmtCache = true;\n    settings.addToOptions(options,\n      \"autoCommit\",\n      \"dbObjectAsPojo\",\n      \"fetchArraySize\",\n      \"fetchTypeHandler\",\n      \"maxRows\",\n      \"outFormat\",\n      \"prefetchRows\");\n  }\n\n  //---------------------------------------------------------------------------\n  // _buildDbObjectClass()\n  //\n  // Builds and returns a database object class given the object type\n  // information supplied by the implementation.\n  //---------------------------------------------------------------------------\n  _buildDbObjectClass(objType) {\n    const DbObject = function(initialValue) {\n      this._impl = new impl.DbObjectImpl(objType);\n      if (this.isCollection) {\n        const proxy = new Proxy(this, BaseDbObject._collectionProxyHandler);\n        if (initialValue !== undefined) {\n          for (let i = 0; i < initialValue.length; i++) {\n            this.append(initialValue[i]);\n          }\n        }\n        return (proxy);\n      } else if (initialValue !== undefined) {\n        Object.assign(this, initialValue);\n      }\n    };\n    DbObject.prototype = Object.create(BaseDbObject.prototype);\n    DbObject.prototype.constructor = DbObject;\n    DbObject.prototype._objType = objType;\n    if (objType.elementTypeClass) {\n      const cls = this._getDbObjectClass(objType.elementTypeClass);\n      objType.elementTypeClass = cls;\n    }\n    if (objType.isCollection) {\n      nodbUtil.addTypeProperties(objType, \"elementType\");\n      objType.elementTypeInfo.type = objType.elementType;\n    }\n    if (objType.attributes) {\n      const props = {};\n      for (const attr of objType.attributes) {\n        if (attr.typeClass) {\n          attr.typeClass = this._getDbObjectClass(attr.typeClass);\n        }\n        nodbUtil.addTypeProperties(attr, \"type\");\n        const prop = {\n          get() {\n            return this._getAttrValue(attr);\n          },\n          set(value) {\n            this._setAttrValue(attr, value);\n          }\n        };\n        props[attr.name] = prop;\n      }\n      Object.defineProperties(DbObject.prototype, props);\n    }\n    DbObject.toString = function() {\n      return ('DbObjectClass [' + objType.fqn + ']');\n    };\n    return (DbObject);\n  }\n\n  //---------------------------------------------------------------------------\n  // _getDbObjectClass()\n  //\n  // Returns the database object class given the object type information\n  // supplied by the implementation. The cache is searched first to see if an\n  // object class has already been built.\n  //---------------------------------------------------------------------------\n  _getDbObjectClass(objType) {\n    if (objType.prototype instanceof BaseDbObject)\n      return objType;\n    let cls = this._dbObjectClasses.get(objType);\n    if (!cls) {\n      cls = this._buildDbObjectClass(objType);\n      cls._connection = this;\n      cls._objType = objType;\n      objType._connection = this._impl;\n      this._dbObjectClasses.set(objType, cls);\n    }\n    return (cls);\n  }\n\n  //---------------------------------------------------------------------------\n  // _getDbObjectClassForName()\n  //\n  // Returns the database object class given the name of the database object\n  // type. The cache is searched first to see if an object class has already\n  // been built.\n  //---------------------------------------------------------------------------\n  async _getDbObjectClassForName(name) {\n    let cls = this._dbObjectClasses.get(name);\n    if (!cls) {\n      const objType = await this._impl.getDbObjectClass(name);\n      cls = this._getDbObjectClass(objType);\n      this._dbObjectClasses.set(name, cls);\n    }\n    return cls;\n  }\n\n  //---------------------------------------------------------------------------\n  // _isBindDir()\n  //\n  // Returns a boolean indicating if the supplied value is a valid bind\n  // direction.\n  //---------------------------------------------------------------------------\n  _isBindDir(value) {\n    return (\n      value === constants.BIND_IN ||\n      value === constants.BIND_OUT ||\n      value === constants.BIND_INOUT\n    );\n  }\n\n  //---------------------------------------------------------------------------\n  // _isBindValue()\n  //\n  // Returns a boolean indicating if the supplied value is one that can be\n  // bound.\n  //---------------------------------------------------------------------------\n  _isBindValue(value) {\n    return (\n      value === null ||\n      value === undefined ||\n      typeof value === 'number' ||\n      typeof value === 'string' ||\n      typeof value === 'boolean' ||\n      typeof value === 'bigint' ||\n      Array.isArray(value) ||\n      nodbUtil.isVectorValue(value) ||\n      Buffer.isBuffer(value) ||\n      util.types.isDate(value) ||\n      value instanceof Lob ||\n      value instanceof ResultSet ||\n      value instanceof BaseDbObject\n    );\n  }\n\n  //---------------------------------------------------------------------------\n  // _processBindUnit()\n  //\n  // Processes a bind unit (object) supplied by the user and returns the value\n  // stored in it (if one is).\n  //---------------------------------------------------------------------------\n  async _processBindUnit(bindInfo, bindUnit, inExecuteMany) {\n    let okBindUnit = false;\n\n    // get and validate bind direction; if not specified, IN is assumed\n    if (bindUnit.dir === undefined) {\n      bindInfo.dir = constants.BIND_IN;\n    } else {\n      errors.assert(this._isBindDir(bindUnit.dir),\n        errors.ERR_INVALID_BIND_DIRECTION);\n      bindInfo.dir = bindUnit.dir;\n      okBindUnit = true;\n    }\n\n    // get and validate bind type; it must be one of the integer constants\n    // identifying types, a string identifying an object type or a constructor\n    // function identifying an object type\n    if (bindUnit.type !== undefined) {\n      if (typeof bindUnit.type === 'string') {\n        bindInfo.type = types.DB_TYPE_OBJECT;\n        bindInfo.typeClass = await this._getDbObjectClassForName(bindUnit.type);\n        bindInfo.objType = bindInfo.typeClass._objType;\n      } else if (bindUnit.type.prototype instanceof BaseDbObject) {\n        bindInfo.type = types.DB_TYPE_OBJECT;\n        bindInfo.typeClass = bindUnit.type;\n        bindInfo.objType = bindInfo.typeClass._objType;\n      } else {\n        errors.assert(bindUnit.type instanceof types.DbType,\n          errors.ERR_INVALID_BIND_DATA_TYPE, 2);\n        bindInfo.type = bindUnit.type;\n      }\n      okBindUnit = true;\n\n    // when calling executeMany(), bind type is mandatory\n    } else if (inExecuteMany) {\n      if (bindInfo.name)\n        errors.throwErr(errors.ERR_MISSING_TYPE_BY_NAME, bindInfo.name);\n      errors.throwErr(errors.ERR_MISSING_TYPE_BY_POS, bindInfo.pos);\n    }\n\n    // get and validate the maximum size for strings/buffers; this value is\n    // used for IN/OUT and OUT binds in execute() and at all times for\n    // executeMany()\n    if (bindInfo.dir !== constants.BIND_IN || inExecuteMany) {\n      if (bindUnit.maxSize !== undefined) {\n        errors.assertParamPropValue(Number.isInteger(bindUnit.maxSize) &&\n          bindUnit.maxSize > 0, 2, \"maxSize\");\n        bindInfo.maxSize = bindUnit.maxSize;\n        bindInfo.checkSize = true;\n        okBindUnit = true;\n      } else if (inExecuteMany) {\n        if (bindInfo.type === types.DB_TYPE_VARCHAR ||\n            bindInfo.type === types.DB_TYPE_RAW) {\n          if (bindInfo.name)\n            errors.throwErr(errors.ERR_MISSING_MAX_SIZE_BY_NAME, bindInfo.name);\n          errors.throwErr(errors.ERR_MISSING_MAX_SIZE_BY_POS, bindInfo.pos);\n        }\n      } else {\n        bindInfo.maxSize = constants.DEFAULT_MAX_SIZE_FOR_OUT_BINDS;\n      }\n    }\n\n    // get max array size (for array binds, not possible in executeMany())\n    bindInfo.isArray = false;\n    if (!inExecuteMany) {\n      if (bindUnit.maxArraySize !== undefined) {\n        errors.assertParamPropValue(Number.isInteger(bindUnit.maxArraySize) &&\n          bindUnit.maxArraySize > 0, 2, \"maxArraySize\");\n        bindInfo.maxArraySize = bindUnit.maxArraySize;\n        bindInfo.isArray = true;\n      }\n    }\n\n    // get the value, if specified (not used in executeMany())\n    if (!inExecuteMany && bindUnit.val !== undefined) {\n      return bindUnit.val;\n    }\n\n    if (!okBindUnit)\n      errors.throwErr(errors.ERR_INVALID_BIND_UNIT);\n  }\n\n  //---------------------------------------------------------------------------\n  // _processBindValue()\n  //\n  // Processes the bind value supplied by the caller. This performs all checks\n  // on the value and normalizes it for use by the implementation class. If no\n  // bind info has been defined yet, the value defines that.\n  //---------------------------------------------------------------------------\n  async _processBindValue(bindInfo, value, options) {\n    const transformed = transformer.transformValueIn(bindInfo, value, options);\n    if (bindInfo.isArray) {\n      bindInfo.values = transformed.concat(bindInfo.values.slice(transformed.length));\n    } else {\n      bindInfo.values[options.pos] = transformed;\n    }\n    if (bindInfo.type === types.DB_TYPE_OBJECT &&\n        bindInfo.typeClass === undefined) {\n      bindInfo.typeClass = await this._getDbObjectClass(value._objType);\n      bindInfo.objType = bindInfo.typeClass._objType;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _processExecuteBind()\n  //\n  // Processes a single execute bind supplied by the caller. This performs all\n  // checks on the bind and normalizes it for use by the implementation class.\n  //---------------------------------------------------------------------------\n  async _processExecuteBind(bindInfo, bindData) {\n\n    // setup defaults\n    bindInfo.isArray = false;\n\n    // if bind data is a value that can be bound directly, use it; otherwise,\n    // scan the bind unit for bind information and its value\n    let bindValue;\n    if (this._isBindValue(bindData)) {\n      bindInfo.dir = constants.BIND_IN;\n      bindValue = bindData;\n    } else {\n      bindValue = await this._processBindUnit(bindInfo, bindData, false);\n    }\n\n    // for IN and IN/OUT binds, process the value\n    if (bindInfo.dir !== constants.BIND_OUT) {\n      const options = {pos: 0, allowArray: true};\n      await this._processBindValue(bindInfo, bindValue, options);\n    }\n\n    // if only null values were found (or an OUT bind was specified), type\n    // information may not be set, so complete bind information as a string\n    // and set the maxSize to 1 if it has not already been set\n    if (bindInfo.type === undefined) {\n      bindInfo.type = types.DB_TYPE_VARCHAR;\n      if (bindInfo.maxSize === undefined)\n        bindInfo.maxSize = 1;\n    }\n\n    // check valid bind type for array binds\n    if (bindInfo.isArray &&\n        bindInfo.type !== types.DB_TYPE_VARCHAR &&\n        bindInfo.type !== types.DB_TYPE_NVARCHAR &&\n        bindInfo.type !== types.DB_TYPE_CHAR &&\n        bindInfo.type !== types.DB_TYPE_NCHAR &&\n        bindInfo.type !== types.DB_TYPE_NUMBER &&\n        bindInfo.type !== types.DB_TYPE_BINARY_FLOAT &&\n        bindInfo.type !== types.DB_TYPE_BINARY_DOUBLE &&\n        bindInfo.type !== types.DB_TYPE_DATE &&\n        bindInfo.type !== types.DB_TYPE_TIMESTAMP &&\n        bindInfo.type !== types.DB_TYPE_TIMESTAMP_LTZ &&\n        bindInfo.type !== types.DB_TYPE_TIMESTAMP_TZ &&\n        bindInfo.type !== types.DB_TYPE_RAW) {\n      errors.throwErr(errors.ERR_INVALID_TYPE_FOR_ARRAY_BIND);\n    }\n\n  }\n\n  //---------------------------------------------------------------------------\n  // _processExecuteBinds()\n  //\n  // Processes the binds supplied by the caller. This performs all checks on\n  // the binds and normalizes them for use by the implementation class.\n  //---------------------------------------------------------------------------\n  async _processExecuteBinds(binds) {\n    const normBinds = [];\n    if (Array.isArray(binds)) {\n      for (let i = 0; i < binds.length; i++) {\n        const bindInfo = normBinds[i] = {pos: i + 1, values: []};\n        await this._processExecuteBind(bindInfo, binds[i]);\n      }\n    } else {\n      errors.assertParamValue(nodbUtil.isObject(binds), 2);\n      const bindNames = Object.getOwnPropertyNames(binds);\n      for (let i = 0; i < bindNames.length; i++) {\n        const bindInfo = normBinds[i] = {name: bindNames[i], values: []};\n        await this._processExecuteBind(bindInfo, binds[bindNames[i]]);\n      }\n    }\n    return normBinds;\n  }\n\n  //---------------------------------------------------------------------------\n  // _processExecuteManyBinds()\n  //\n  // Processes the binds supplied by the caller. This performs all checks on\n  // the binds and normalizes them for use by the implementation class.\n  //---------------------------------------------------------------------------\n  async _processExecuteManyBinds(binds, bindDefs) {\n    const normBinds = [];\n    let byPosition;\n\n    // transform bindDefs into normalized binds, if available\n    if (bindDefs !== undefined) {\n      if (Array.isArray(bindDefs)) {\n        byPosition = true;\n        for (let i = 0; i < bindDefs.length; i++) {\n          const bindInfo = normBinds[i] = {pos: i + 1, values: []};\n          await this._processBindUnit(bindInfo, bindDefs[i], true);\n        }\n      } else {\n        byPosition = false;\n        const bindNames = Object.getOwnPropertyNames(bindDefs);\n        for (let i = 0; i < bindNames.length; i++) {\n          const bindInfo = normBinds[i] = {name: bindNames[i], values: []};\n          await this._processBindUnit(bindInfo, bindDefs[bindNames[i]], true);\n        }\n      }\n\n    // otherwise, use the first row to determine the binds to use\n    } else {\n      const row = binds[0];\n      errors.assertParamValue(nodbUtil.isObjectOrArray(row), 2);\n      if (Array.isArray(row)) {\n        byPosition = true;\n        for (let i = 0; i < row.length; i++) {\n          normBinds[i] = {pos: i + 1};\n        }\n      } else {\n        byPosition = false;\n        const bindNames = Object.getOwnPropertyNames(row);\n        for (let i = 0; i < bindNames.length; i++) {\n          normBinds[i] = {name: bindNames[i]};\n        }\n      }\n      for (let i = 0; i < normBinds.length; i++) {\n        normBinds[i].dir = constants.BIND_IN;\n        normBinds[i].isArray = false;\n        normBinds[i].values = [];\n      }\n    }\n\n    // process each of the rows\n    for (let i = 0; i < binds.length; i++) {\n      const row = binds[i];\n      const options = {pos: i, allowArray: false};\n      errors.assert((byPosition && Array.isArray(row)) ||\n        (!byPosition && nodbUtil.isObject(row)), errors.ERR_MIXED_BIND);\n      for (let j = 0; j < normBinds.length; j++) {\n        const bindInfo = normBinds[j];\n        const value = (byPosition) ? row[j] : row[bindInfo.name];\n        await this._processBindValue(bindInfo, value, options);\n      }\n    }\n\n    // set bind type and size to a string of size 1 if no bind type was\n    // specified (and all values are null)\n    for (let i = 0; i < normBinds.length; i++) {\n      const bindInfo = normBinds[i];\n      if (bindInfo.type === undefined) {\n        bindInfo.type = types.DB_TYPE_VARCHAR;\n        bindInfo.maxSize = 1;\n      }\n    }\n\n    return normBinds;\n  }\n\n  //---------------------------------------------------------------------------\n  // _transformOutBind()\n  //\n  // Transform an output bind value from an implementation value to a user\n  // facing value (for result sets and LOBs). DML returning output variables\n  // are always an array of values.\n  //---------------------------------------------------------------------------\n  _transformOutBind(val, options) {\n    let outVal = val;\n    if (Array.isArray(val)) {\n      outVal = [];\n      for (let i = 0; i < val.length; i++)\n        outVal.push(this._transformOutBind(val[i], options));\n    } else if (val instanceof impl.ResultSetImpl) {\n      outVal = new ResultSet();\n      outVal._setup(this, val);\n    } else if (val instanceof impl.LobImpl) {\n      outVal = new Lob();\n      outVal._setup(val, true);\n    } else if (val instanceof impl.DbObjectImpl) {\n      const cls = this._dbObjectClasses.get(val._objType);\n      outVal = Object.create(cls.prototype);\n      outVal._impl = val;\n      if (options.dbObjectAsPojo) {\n        outVal = outVal._toPojo();\n      } else if (outVal.isCollection) {\n        outVal = new Proxy(outVal, BaseDbObject._collectionProxyHandler);\n      }\n    }\n    return outVal;\n  }\n\n  //---------------------------------------------------------------------------\n  // _verifyExecOpts\n  //\n  // Verify that the value passed by the user for binds is acceptable. Perform\n  // any transformations necessary.\n  //---------------------------------------------------------------------------\n  _verifyExecOpts(options, inExecuteMany) {\n\n    // define normalized options (value returned to caller)\n    const outOptions = {};\n\n    // handle common options\n    errors.assertParamValue(nodbUtil.isObject(options), 3);\n\n    // autoCommit must be a boolean value\n    if (options.autoCommit !== undefined) {\n      errors.assertParamPropValue(typeof options.autoCommit === 'boolean', 3,\n        \"autoCommit\");\n      outOptions.autoCommit = options.autoCommit;\n    }\n\n    // dbObjectAsPojo must be a boolean value\n    if (options.dbObjectAsPojo !== undefined) {\n      errors.assertParamPropValue(typeof options.dbObjectAsPojo === 'boolean',\n        3, \"dbObjectAsPojo\");\n      outOptions.dbObjectAsPojo = options.dbObjectAsPojo;\n    }\n\n    // keepInStmtCache must be a boolean value\n    if (options.keepInStmtCache !== undefined) {\n      errors.assertParamPropValue(typeof options.keepInStmtCache === 'boolean',\n        3, \"keepInStmtCache\");\n      outOptions.keepInStmtCache = options.keepInStmtCache;\n    }\n\n    // handle options specific to executeMany()\n    if (inExecuteMany) {\n\n      // bindDefs must be an object or array\n      if (options.bindDefs !== undefined) {\n        errors.assertParamPropValue(nodbUtil.isObjectOrArray(options.bindDefs),\n          3, \"bindDefs\");\n        outOptions.bindDefs = options.bindDefs;\n      }\n\n      // batchErrors must be a boolean value\n      if (options.batchErrors !== undefined) {\n        errors.assertParamPropValue(typeof options.batchErrors === 'boolean',\n          3, \"batchErrors\");\n        outOptions.batchErrors = options.batchErrors;\n      }\n\n      // dmlRowCounts must be a boolean value\n      if (options.dmlRowCounts !== undefined) {\n        errors.assertParamPropValue(typeof options.dmlRowCounts === 'boolean',\n          3, \"dmlRowCounts\");\n        outOptions.dmlRowCounts = options.dmlRowCounts;\n      }\n\n    // handle options specific to execute()\n    } else {\n\n      // fetchArraySize must be a positive integer\n      errors.assertParamPropUnsignedIntNonZero(options, 3, \"fetchArraySize\");\n      outOptions.fetchArraySize = options.fetchArraySize;\n\n      // fetchInfo must be an object with keys containing an object with a\n      // \"type\" property; these are converted to an array of objects for ease\n      // of processing by the implementation\n      if (options.fetchInfo !== undefined) {\n        errors.assertParamPropValue(nodbUtil.isObject(options.fetchInfo), 3,\n          \"fetchInfo\");\n        const names = Object.getOwnPropertyNames(options.fetchInfo);\n        const map = new Map(settings.fetchTypeMap);\n        for (const name of names) {\n          const info = options.fetchInfo[name];\n          if (info.type === undefined)\n            errors.throwErr(errors.ERR_NO_TYPE_FOR_CONVERSION);\n          if (info.type !== constants.DEFAULT &&\n              info.type !== types.DB_TYPE_VARCHAR &&\n              info.type !== types.DB_TYPE_RAW) {\n            errors.throwErr(errors.ERR_INVALID_TYPE_FOR_CONVERSION);\n          }\n          map.set(name, info.type);\n        }\n        outOptions.fetchTypeMap = map;\n      }\n\n      // fetchTypeHandler must be a function which is called for each column to\n      // be fetched and accepts the metadata for a column\n      if (options.fetchTypeHandler !== undefined) {\n        const type = (typeof options.fetchTypeHandler);\n        errors.assertParamPropValue(type === 'function', 3, \"fetchTypeHandler\");\n        outOptions.fetchTypeHandler = options.fetchTypeHandler;\n      }\n\n      // maxRows must be a positive integer (or 0)\n      if (options.maxRows !== undefined) {\n        errors.assertParamPropValue(Number.isInteger(options.maxRows) &&\n          options.maxRows >= 0, 3, \"maxRows\");\n        outOptions.maxRows = options.maxRows;\n      }\n\n      // outFormat must be one of the two possible constants\n      if (options.outFormat !== undefined) {\n        errors.assertParamPropValue(\n          options.outFormat === constants.OUT_FORMAT_ARRAY ||\n          options.outFormat === constants.OUT_FORMAT_OBJECT, 3, \"outFormat\");\n        outOptions.outFormat = options.outFormat;\n      }\n\n      // prefetchRows must be a positive integer (or 0)\n      if (options.prefetchRows !== undefined) {\n        errors.assertParamPropValue(Number.isInteger(options.prefetchRows) &&\n          options.prefetchRows >= 0, 3, \"prefetchRows\");\n        outOptions.prefetchRows = options.prefetchRows;\n      }\n\n      // resultSet must be a boolean value\n      if (options.resultSet !== undefined) {\n        errors.assertParamPropValue(typeof options.resultSet === 'boolean', 3,\n          \"resultSet\");\n        outOptions.resultSet = options.resultSet;\n      }\n\n    }\n\n    return outOptions;\n  }\n\n  //---------------------------------------------------------------------------\n  // action\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get action() {\n    return null;\n  }\n\n  set action(value) {\n    errors.assertPropValue(typeof value === 'string', \"action\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setAction(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // breakExecution()\n  //\n  // Breaks execution of a running statement.\n  //---------------------------------------------------------------------------\n  async breakExecution() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.breakExecution();\n  }\n\n  //---------------------------------------------------------------------------\n  // callTimeout\n  //\n  // Property for round-trip timeouts.\n  //---------------------------------------------------------------------------\n  get callTimeout() {\n    if (this._impl)\n      return this._impl.getCallTimeout();\n    return undefined;\n  }\n\n  set callTimeout(value) {\n    errors.assertPropValue(Number.isInteger(value) && value >= 0,\n      \"callTimeout\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setCallTimeout(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // changePassword()\n  //\n  // Changes the password of the specified user.\n  //---------------------------------------------------------------------------\n  async changePassword(user, password, newPassword) {\n    errors.assertArgCount(arguments, 3, 3);\n    errors.assertParamValue(typeof user === 'string', 1);\n    errors.assertParamValue(typeof password === 'string', 2);\n    errors.assertParamValue(typeof newPassword === 'string', 3);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.changePassword(user, password, newPassword);\n  }\n\n  //---------------------------------------------------------------------------\n  // clientId\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get clientId() {\n    return null;\n  }\n\n  set clientId(value) {\n    errors.assertPropValue(typeof value === 'string', \"clientId\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setClientId(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // clientInfo\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get clientInfo() {\n    return null;\n  }\n\n  set clientInfo(value) {\n    errors.assertPropValue(typeof value === 'string', \"clientInfo\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setClientInfo(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // close()\n  //\n  // Closes the connection and makes it unusable for further work.\n  //---------------------------------------------------------------------------\n  async close(a1) {\n    let options = {};\n\n    errors.assertArgCount(arguments, 0, 1);\n    if (arguments.length == 1) {\n      errors.assertParamValue(nodbUtil.isObject(a1), 1);\n      options = a1;\n      errors.assertParamPropBool(options, 1, \"drop\");\n    }\n    errors.assert(this._impl && !this._closing, errors.ERR_INVALID_CONNECTION);\n\n    this._closing = true;\n    try {\n      await this._impl.close(options);\n    } finally {\n      this._closing = false;\n    }\n\n    delete this._impl;\n    this._dbObjectClasses.clear();\n    this.emit('_afterConnClose');\n  }\n\n  //---------------------------------------------------------------------------\n  // commit()\n  //\n  // Commits the current transaction.\n  //---------------------------------------------------------------------------\n  async commit() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.commit();\n  }\n\n  //---------------------------------------------------------------------------\n  // createLob()\n  //\n  // Creates a temporary LOB and returns it to the caller.\n  //---------------------------------------------------------------------------\n  async createLob(type) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(type === types.DB_TYPE_CLOB ||\n      type === types.DB_TYPE_BLOB ||\n      type === types.DB_TYPE_NCLOB, 1);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const lob = new Lob();\n    lob._setup(await this._impl.createLob(type), false);\n    return lob;\n  }\n\n  //---------------------------------------------------------------------------\n  // currentSchema\n  //\n  // Property for identifying the current schema to use in the database.\n  //---------------------------------------------------------------------------\n  get currentSchema() {\n    if (this._impl)\n      return this._impl.getCurrentSchema();\n    return undefined;\n  }\n\n  set currentSchema(value) {\n    errors.assertPropValue(typeof value === 'string', \"currentSchema\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setCurrentSchema(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // dbOp\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get dbOp() {\n    return null;\n  }\n\n  set dbOp(value) {\n    errors.assertPropValue(typeof value === 'string', \"dbOp\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setDbOp(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // thin()\n  //\n  // return true, if driver mode is thin while acquiring connection\n  // return false, if driver mode is thick while acquiring connection\n  //---------------------------------------------------------------------------\n  get thin() {\n    return settings.thin;\n  }\n\n  //---------------------------------------------------------------------------\n  // ecid\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get ecid() {\n    return null;\n  }\n\n  set ecid(value) {\n    errors.assertPropValue(typeof value === 'string', \"ecid\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setECID(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // decode()\n  //\n  // Decodes OSON Buffer to JS data type.\n  //---------------------------------------------------------------------------\n  decodeOSON(buf) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(Buffer.isBuffer(buf), 1);\n    const decoder = new oson.OsonDecoder(buf);\n    return decoder.decode();\n  }\n\n\n  //---------------------------------------------------------------------------\n  // encode()\n  //\n  // Encodes the JS value into OSON bytes.\n  //---------------------------------------------------------------------------\n  encodeOSON(value) {\n    const encoder = new oson.OsonEncoder();\n    return encoder.encode(transformer.transformJsonValue(value), this._impl._osonMaxFieldNameSize);\n  }\n\n  //---------------------------------------------------------------------------\n  // execute()\n  //\n  // Executes a SQL statement and returns the results.\n  //---------------------------------------------------------------------------\n  async execute(sql, a2, a3) {\n    const numIters = 1;\n    let binds = [];\n    let options = {};\n\n    // process arguments\n    if (nodbUtil.isObject(sql) && typeof sql.statement === 'string') {\n      errors.assertArgCount(arguments, 1, 2);\n      if (sql.values) {\n        binds = await this._processExecuteBinds(sql.values);\n      }\n      sql = sql.statement;\n      if (arguments.length == 2) {\n        options = this._verifyExecOpts(a2, false);\n      }\n    } else {\n      errors.assertArgCount(arguments, 1, 3);\n      errors.assertParamValue(typeof sql === 'string', 1);\n      if (arguments.length >= 2) {\n        binds = await this._processExecuteBinds(a2);\n      }\n      if (arguments.length == 3) {\n        options = this._verifyExecOpts(a3, false);\n      }\n    }\n    this._addDefaultsToExecOpts(options);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    // perform actual execute\n    let result;\n    try {\n      result = await this._impl.execute(sql, numIters, binds, options, false);\n    } catch (err) {\n      if (err.errorNum === 1406)\n        errors.throwErr(errors.ERR_INSUFFICIENT_BUFFER_FOR_BINDS);\n      throw err;\n    }\n\n    // convert ORA errors to NJS\n    if (result.warning) {\n      result.warning = errors.transformErr(result.warning);\n    }\n\n    // process queries; if a result set is not desired, fetch all of the rows\n    // from the result set and then destroy the result set\n    if (result.resultSet !== undefined) {\n      const resultSet = new ResultSet();\n      resultSet._setup(this, result.resultSet);\n      result.metaData = resultSet._impl.metaData;\n      if (options.resultSet) {\n        result.resultSet = resultSet;\n      } else {\n        result.rows = await resultSet._getAllRows();\n        delete result.resultSet;\n      }\n    }\n\n    // process output binds\n    if (result.outBinds !== undefined) {\n      for (const [key, value] of Object.entries(result.outBinds)) {\n        const val = this._transformOutBind(value, options);\n        result.outBinds[key] = val;\n      }\n    }\n\n    // process implicit results; ensure all implicit results have their fetch\n    // array size fixed, or, if a result set is not requested, that all rows\n    // are fetched\n    if (result.implicitResults) {\n      for (const [key, impl] of Object.entries(result.implicitResults)) {\n        const resultSet = new ResultSet();\n        resultSet._setup(this, impl);\n        if (options.resultSet) {\n          result.implicitResults[key] = resultSet;\n        } else {\n          result.implicitResults[key] = await resultSet._getAllRows();\n        }\n      }\n    }\n\n    return (result);\n  }\n\n  //---------------------------------------------------------------------------\n  // executeMany()\n  //\n  // Executes a SQL statement multiple times and returns the results.\n  //---------------------------------------------------------------------------\n  async executeMany(sql, bindsOrNumIters, a3) {\n    let options = {};\n    let binds = [];\n    let numIters;\n\n    errors.assertArgCount(arguments, 2, 3);\n    errors.assertParamValue(typeof sql === 'string', 1);\n    if (arguments.length == 3) {\n      options = this._verifyExecOpts(a3, true);\n    }\n    this._addDefaultsToExecOpts(options);\n    if (typeof bindsOrNumIters === 'number') {\n      errors.assertParamValue(Number.isInteger(bindsOrNumIters) &&\n        bindsOrNumIters > 0, 2);\n      numIters = bindsOrNumIters;\n      if (options.bindDefs !== undefined) {\n        binds = await this._processExecuteManyBinds([], options.bindDefs);\n      }\n    } else {\n      errors.assertParamValue(Array.isArray(bindsOrNumIters) &&\n        bindsOrNumIters.length > 0, 2);\n      numIters = bindsOrNumIters.length;\n      binds = await this._processExecuteManyBinds(bindsOrNumIters,\n        options.bindDefs);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    const result = await this._impl.execute(sql, numIters, binds, options,\n      true);\n\n    // convert ORA warnings to NJS\n    if (result.warning) {\n      result.warning = errors.transformErr(result.warning);\n    }\n\n    // process output binds\n    if (result.outBinds !== undefined) {\n      for (let i = 0; i < result.outBinds.length; i++) {\n        const outBind = result.outBinds[i];\n        for (const [key, value] of Object.entries(outBind)) {\n          outBind[key] = this._transformOutBind(value, options);\n        }\n      }\n    }\n\n    return result;\n  }\n\n  //---------------------------------------------------------------------------\n  // externalName\n  //\n  // Property for identifying the external name to use in TPC logging.\n  //---------------------------------------------------------------------------\n  get externalName() {\n    if (this._impl)\n      return this._impl.getExternalName();\n    return undefined;\n  }\n\n  set externalName(value) {\n    errors.assertPropValue(typeof value === 'string', \"externalName\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setExternalName(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // dbDomain (READONLY)\n  //\n  // Property for identifying the dbDomain of the Oracle Database.\n  //---------------------------------------------------------------------------\n  get dbDomain() {\n    return this._impl && this._impl.getDbDomain();\n  }\n\n  //---------------------------------------------------------------------------\n  // dbName (READONLY)\n  //\n  // Property for identifying the dbName of the Oracle Database.\n  //---------------------------------------------------------------------------\n  get dbName() {\n    return this._impl && this._impl.getDbName();\n  }\n\n  //---------------------------------------------------------------------------\n  // getDbObjectClass()\n  //\n  // Returns a database object class given its name. The cache is searched\n  // first, but if not found, the database is queried and the result is cached\n  // using the type information (as well as the name for easier lookup later).\n  //---------------------------------------------------------------------------\n  async getDbObjectClass(name) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(typeof name === 'string', 1);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    return await this._getDbObjectClassForName(name);\n  }\n\n  //---------------------------------------------------------------------------\n  // getQueue()\n  //\n  // Returns a queue with the specified name.\n  //---------------------------------------------------------------------------\n  async getQueue(name, a2) {\n    let options = {};\n\n    errors.assertArgCount(arguments, 1, 2);\n    errors.assertParamValue(typeof name === 'string', 1);\n    if (arguments.length == 2) {\n      errors.assertParamValue(nodbUtil.isObject(a2), 2);\n      options = {...a2};\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const queue = new AqQueue();\n    await queue.create(this, name, options);\n    return queue;\n  }\n\n  //---------------------------------------------------------------------------\n  // getSodaDatabase()\n  //\n  // Returns a SodaDatabase object (high-level SODA object associated with\n  // the current connection).\n  //---------------------------------------------------------------------------\n  getSodaDatabase() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const sodaDb = new SodaDatabase();\n    sodaDb._impl = this._impl.getSodaDatabase();\n    return sodaDb;\n  }\n\n  //---------------------------------------------------------------------------\n  // getStatementInfo()\n  //\n  // Returns information about the statement.\n  //---------------------------------------------------------------------------\n  async getStatementInfo(sql) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(typeof sql === 'string', 1);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    const info = await this._impl.getStatementInfo(sql);\n    if (info.metaData) {\n      for (let i = 0; i < info.metaData.length; i++) {\n        const m = info.metaData[i];\n        nodbUtil.addTypeProperties(m, \"dbType\");\n        m.fetchType = types.DB_TYPE_FETCH_TYPE_MAP.get(m.dbType);\n      }\n    }\n    return info;\n  }\n\n  //---------------------------------------------------------------------------\n  // instanceName\n  //\n  // Returns the Oracle Database instance name associated with the connection.\n  // This is the equivalent of the SQL expression:\n  // sys_context('userenv', 'instance_name')\n  //---------------------------------------------------------------------------\n  get instanceName() {\n    if (this._impl)\n      return this._impl.getInstanceName();\n    return undefined;\n  }\n\n  //---------------------------------------------------------------------------\n  // internalName\n  //\n  // Property for identifying the internal name to use in TPC logging.\n  //---------------------------------------------------------------------------\n  get internalName() {\n    if (this._impl)\n      return this._impl.getInternalName();\n    return undefined;\n  }\n\n  set internalName(value) {\n    errors.assertPropValue(typeof value === 'string', \"internalName\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setInternalName(value);\n  }\n\n  //--------------------------------------------------------------------------\n  // isHealthy()\n  //\n  // Returns the health status of the connection. If this function returns\n  // false, the caller should close the connection.\n  //---------------------------------------------------------------------------\n  isHealthy() {\n    return (this._impl !== undefined && !this._closing &&\n      this._impl.isHealthy());\n  }\n\n  //---------------------------------------------------------------------------\n  // maxOpenCursors\n  //\n  // Returns maximum number of cursors that can be opened in one session.\n  //---------------------------------------------------------------------------\n  get maxOpenCursors() {\n    return this._impl && this._impl.getMaxOpenCursors();\n  }\n\n  //---------------------------------------------------------------------------\n  // warning\n  //\n  // Returns warningInfo.\n  //---------------------------------------------------------------------------\n  get warning() {\n    let warning = this._impl.getWarning();\n    if (warning) {\n      // Make sure that warning code attribute is populated and ORA error\n      // is converted to NJS, if required\n      warning = errors.transformErr(warning);\n    }\n    return this._impl && warning;\n  }\n\n  //---------------------------------------------------------------------------\n  // module\n  //\n  // Property for end-to-end tracing attribute.\n  //---------------------------------------------------------------------------\n  get module() {\n    return null;\n  }\n\n  set module(value) {\n    errors.assertPropValue(typeof value === 'string', \"module\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setModule(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // oracleServerVersion\n  //\n  // Returns an integer identifying the Oracle Server version.\n  //---------------------------------------------------------------------------\n  get oracleServerVersion() {\n    if (this._impl)\n      return this._impl.getOracleServerVersion();\n    return undefined;\n  }\n\n  //---------------------------------------------------------------------------\n  // oracleServerVersionString\n  //\n  // Returns a string identifying the Oracle Server version.\n  //---------------------------------------------------------------------------\n  get oracleServerVersionString() {\n    if (this._impl)\n      return this._impl.getOracleServerVersionString();\n    return undefined;\n  }\n\n  //---------------------------------------------------------------------------\n  // serviceName\n  //\n  // Returns the Oracle Database service name associated with the connection.\n  //---------------------------------------------------------------------------\n  get serviceName() {\n    return this._impl && this._impl.getServiceName();\n  }\n\n  //---------------------------------------------------------------------------\n  // transactionInProgress\n  //\n  // Returns a boolean value based on the presence of an active transaction\n  // on the connection\n  //---------------------------------------------------------------------------\n  get transactionInProgress() {\n    return this._impl && this._impl.getTransactionInProgress();\n  }\n\n  //---------------------------------------------------------------------------\n  // ping()\n  //\n  // Sends a \"ping\" to the database to see if it is \"alive\".\n  //---------------------------------------------------------------------------\n  async ping() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.ping();\n  }\n\n  //--------------------------------------------------------------------------\n  // queryStream()\n  //\n  // Similar to execute() except that it immediately returns a QueryStream\n  // object.\n  // ---------------------------------------------------------------------------\n  queryStream(sql, binds, options) {\n    errors.assertArgCount(arguments, 1, 3);\n    errors.assertParamValue(typeof sql === 'string', 1);\n    if (arguments.length == 3) {\n      errors.assertParamValue(nodbUtil.isObject(options), 3);\n      options = {...options};\n    } else {\n      options = {};\n    }\n    options.resultSet = true;\n\n    const stream = new QueryStream();\n\n    // calling execute() via nextTick to ensure that handlers are registered\n    // prior to the events being emitted\n    process.nextTick(async () => {\n      try {\n        const result = await this.execute(sql, binds || [], options);\n        if (!result.resultSet)\n          errors.throwErr(errors.ERR_NOT_A_QUERY);\n        stream._open(result.resultSet);\n      } catch (err) {\n        stream.destroy(err);\n        return;\n      }\n    });\n\n    return (stream);\n  }\n\n  //---------------------------------------------------------------------------\n  // rollback()\n  //\n  // Rolls back the current transaction.\n  //---------------------------------------------------------------------------\n  async rollback() {\n    errors.assertArgCount(arguments, 0, 0);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.rollback();\n  }\n\n  //---------------------------------------------------------------------------\n  // shutdown()\n  //   Shuts down the database instance.\n  //---------------------------------------------------------------------------\n  async shutdown(a1) {\n    let mode = constants.SHUTDOWN_MODE_DEFAULT;\n\n    errors.assertArgCount(arguments, 0, 1);\n    if (a1 !== undefined) {\n      errors.assertParamValue(typeof mode === 'number', 1);\n      mode = a1;\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    await this._impl.shutdown(mode);\n  }\n\n  //---------------------------------------------------------------------------\n  // startup()\n  //   Starts up the database instance.\n  //---------------------------------------------------------------------------\n  async startup(a1) {\n    let options = {};\n\n    errors.assertArgCount(arguments, 0, 1);\n    if (arguments.length == 1) {\n      errors.assertParamValue(typeof options === 'object', 1);\n      options = a1;\n      errors.assertParamPropBool(options, 1, \"force\");\n      errors.assertParamPropBool(options, 1, \"restrict\");\n      errors.assertParamPropString(options, 1, \"pfile\");\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    await this._impl.startup(options);\n  }\n\n  //---------------------------------------------------------------------------\n  // stmtCacheSize\n  //\n  // Property for statement cache size.\n  //---------------------------------------------------------------------------\n  get stmtCacheSize() {\n    if (this._impl)\n      return this._impl.getStmtCacheSize();\n    return undefined;\n  }\n\n  set stmtCacheSize(value) {\n    errors.assertPropValue(Number.isInteger(value) && value >= 0,\n      \"stmtCacheSize\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setStmtCacheSize(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // subscribe()\n  //\n  // Creates a subscription which can be used to get notifications of database\n  // changes or of AQ messages available to dequeue.\n  //---------------------------------------------------------------------------\n  async subscribe(name, options) {\n    errors.assertArgCount(arguments, 2, 2);\n    errors.assertParamValue(typeof name === 'string', 1);\n    errors.assertParamValue(nodbUtil.isObject(options), 2);\n    options = {name: name, ...options};\n    errors.assertParamPropUnsignedInt(options, 2, \"namespace\");\n    if (options.namespace === undefined)\n      options.namespace = constants.SUBSCR_NAMESPACE_DBCHANGE;\n    errors.assertParamPropString(options, 2, \"ipAddress\");\n    errors.assertParamPropUnsignedInt(options, 2, \"port\");\n    errors.assertParamPropUnsignedInt(options, 2, \"timeout\");\n    errors.assertParamPropUnsignedInt(options, 2, \"operations\");\n    errors.assertParamPropUnsignedInt(options, 2, \"qos\");\n    errors.assertParamPropUnsignedInt(options, 2, \"groupingClass\");\n    errors.assertParamPropUnsignedInt(options, 2, \"groupingValue\");\n    errors.assertParamPropUnsignedInt(options, 2, \"groupingType\");\n    errors.assertParamPropBool(options, 2, \"clientInitiated\");\n    errors.assertParamPropFunction(options, 2, \"callback\");\n    errors.assert(options.callback, errors.ERR_MISSING_SUBSCR_CALLBACK);\n    if (options.namespace === constants.SUBSCR_NAMESPACE_DBCHANGE) {\n      errors.assertParamPropString(options, 2, \"sql\");\n      errors.assert(options.sql && options.sql.length > 0,\n        errors.ERR_MISSING_SUBSCR_SQL);\n      if (options.binds !== undefined) {\n        options.binds = await this._processExecuteBinds(options.binds);\n      }\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    const inSubscr = _subscriptions.get(name);\n    const outValue = await this._impl.subscribe(inSubscr, options);\n    let subscription;\n    if (options.namespace === constants.SUBSCR_NAMESPACE_DBCHANGE) {\n      subscription = outValue.subscription;\n      delete outValue.subscription;\n    } else {\n      subscription = outValue;\n    }\n    _subscriptions.set(name, subscription);\n    return outValue;\n  }\n\n  //---------------------------------------------------------------------------\n  // tag\n  //\n  // Property for tag to associate with the connection.\n  //---------------------------------------------------------------------------\n  get tag() {\n    if (this._impl)\n      return this._impl.getTag();\n    return undefined;\n  }\n\n  set tag(value) {\n    errors.assertPropValue(typeof value === 'string', \"tag\");\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    this._impl.setTag(value);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcBegin()\n  //\n  // Starts a two-phase-commit transaction.\n  //--------------------------------------------------------------------------\n  async tpcBegin(xid, flag, timeout) {\n    errors.assertArgCount(arguments, 1, 3);\n    errors.assertParamValue(nodbUtil.isXid(xid), 1);\n    const normalizedXid = nodbUtil.normalizeXid(xid);\n    if (arguments.length < 3) {\n      timeout = 60;   // seconds\n    } else {\n      errors.assertParamValue(typeof timeout === 'number', 3);\n    }\n\n    if (arguments.length < 2) {\n      flag = constants.TPC_BEGIN_NEW;\n    } else {\n      errors.assertParamValue(typeof flag === 'number', 2);\n      const options = [constants.TPC_BEGIN_NEW, constants.TPC_BEGIN_JOIN,\n        constants.TPC_BEGIN_RESUME, constants.TPC_BEGIN_PROMOTE];\n      if (options.indexOf(flag) < 0) {\n        errors.throwErr(errors.ERR_INVALID_TPC_BEGIN_FLAGS);\n      }\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.tpcBegin(normalizedXid, flag, timeout);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcCommit()\n  //\n  // Commits a two-phase-commit transaction.\n  //---------------------------------------------------------------------------\n  async tpcCommit(xid, onePhase) {\n    errors.assertArgCount(arguments, 0, 2);\n\n    if (arguments.length < 2) {\n      onePhase = false;\n    } else {\n      errors.assertParamValue(typeof onePhase === 'boolean', 2);\n    }\n    let normalizedXid;\n    if (arguments.length >= 1) {\n      errors.assertParamValue(nodbUtil.isXid(xid), 1);\n      normalizedXid = nodbUtil.normalizeXid(xid);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    await this._impl.tpcCommit(normalizedXid, onePhase);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcEnd()\n  //\n  // Ends a two-phase-commit transaction.\n  //---------------------------------------------------------------------------\n  async tpcEnd(xid, flag) {\n    errors.assertArgCount(arguments, 0, 2);\n\n    if (arguments.length < 2) {\n      flag = constants.TPC_END_NORMAL;\n    } else {\n      errors.assertParamValue(typeof flag === 'number', 2);\n      const options = [constants.TPC_END_NORMAL, constants.TPC_END_SUSPEND];\n      if (!options.includes(flag)) {\n        errors.throwErr(errors.ERR_INVALID_TPC_END_FLAGS);\n      }\n    }\n    let normalizedXid;\n    if (arguments.length >= 1) {\n      errors.assertParamValue(nodbUtil.isXid(xid), 1);\n      normalizedXid = nodbUtil.normalizeXid(xid);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    await this._impl.tpcEnd(normalizedXid, flag);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcForget()\n  //\n  // Causes the server to forget a heuristically completed two-phase-commit\n  // transaction.\n  // ---------------------------------------------------------------------------\n  async tpcForget(xid) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(nodbUtil.isXid(xid), 1);\n    const normalizedXid = nodbUtil.normalizeXid(xid);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    await this._impl.tpcForget(normalizedXid);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcPrepare()\n  //\n  // Prepares a two-phase-commit transaction for commit.\n  //---------------------------------------------------------------------------\n  async tpcPrepare(xid) {\n    errors.assertArgCount(arguments, 0, 1);\n    let normalizedXid;\n    if (arguments.length >= 1) {\n      errors.assertParamValue(nodbUtil.isXid(xid), 1);\n      normalizedXid = nodbUtil.normalizeXid(xid);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    return await this._impl.tpcPrepare(normalizedXid);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcRecover()\n  //\n  // Returns a list of pending two-phase-commit transactions.\n  //---------------------------------------------------------------------------\n  async tpcRecover(asString) {\n    errors.assertArgCount(arguments, 0, 1);\n\n    if (arguments.length == 1) {\n      errors.assertParamValue(typeof asString === 'boolean', 1);\n    } else {\n      asString = true;\n    }\n\n    const sqlStr = `\n      SELECT\n          formatid as \"formatId\",\n          UTL_RAW.CAST_TO_VARCHAR2(globalid) as \"globalTransactionId\",\n          UTL_RAW.CAST_TO_VARCHAR2(branchid) as \"branchQualifier\"\n      FROM DBA_PENDING_TRANSACTIONS`;\n    const sqlBuf = `\n      SELECT\n          formatid as \"formatId\",\n          globalid as \"globalTransactionId\",\n          branchid as \"branchQualifier\"\n      FROM DBA_PENDING_TRANSACTIONS`;\n    const options = {\n      outFormat: constants.OUT_FORMAT_OBJECT,\n      resultSet: false\n    };\n\n    const result = await this.execute(asString ? sqlStr : sqlBuf, {}, options);\n    return result.rows;\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcRollback()\n  //\n  // Rolls back the current changes in a two-phase-commit transaction.\n  //---------------------------------------------------------------------------\n  async tpcRollback(xid) {\n    errors.assertArgCount(arguments, 0, 1);\n    let normalizedXid;\n    if (arguments.length == 1) {\n      errors.assertParamValue(nodbUtil.isXid(xid), 1);\n      normalizedXid = nodbUtil.normalizeXid(xid);\n    }\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n\n    await this._impl.tpcRollback(normalizedXid);\n  }\n\n  //---------------------------------------------------------------------------\n  // unsubscribe()\n  //\n  // Destroy a subscription which was earlier created using subscribe().\n  //---------------------------------------------------------------------------\n  async unsubscribe(name) {\n    errors.assertArgCount(arguments, 1, 1);\n    errors.assertParamValue(typeof name === 'string', 1);\n    errors.assert(this._impl, errors.ERR_INVALID_CONNECTION);\n    errors.assert(_subscriptions.has(name), errors.ERR_INVALID_SUBSCR);\n    await this._impl.unsubscribe(_subscriptions.get(name));\n    _subscriptions.delete(name);\n  }\n\n}\n\n// adjust functions to support the old callback style and to serialize calls\n// that cannot take place concurrently\n// NOTE: breakExecution() should not be serialized\nConnection.prototype.break =\n    nodbUtil.callbackify(Connection.prototype.breakExecution);\nConnection.prototype.tpcRecover =\n    nodbUtil.callbackify(Connection.prototype.tpcRecover);\nnodbUtil.wrapFns(Connection.prototype,\n  \"changePassword\",\n  \"close\",\n  \"commit\",\n  \"createLob\",\n  \"execute\",\n  \"executeMany\",\n  \"getDbObjectClass\",\n  \"getQueue\",\n  \"getStatementInfo\",\n  \"ping\",\n  \"rollback\",\n  \"shutdown\",\n  \"startup\",\n  \"subscribe\",\n  \"tpcBegin\",\n  \"tpcCommit\",\n  \"tpcEnd\",\n  \"tpcForget\",\n  \"tpcPrepare\",\n  \"tpcRollback\",\n  \"unsubscribe\");\n\n// add alias for release()\nConnection.prototype.release = Connection.prototype.close;\n\n// export just the Connection class\nmodule.exports = Connection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}