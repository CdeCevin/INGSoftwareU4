{"ast":null,"code":"// Copyright (c) 2022, 2024, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst {\n  BaseBuffer\n} = require('../../impl/datahandlers/buffer.js');\nconst {\n  Buffer\n} = require('buffer');\nconst constants = require('./constants.js');\nconst oson = require('../../impl/datahandlers/oson.js');\nconst utils = require('./utils.js');\nconst vector = require('../../impl/datahandlers/vector.js');\nconst errors = require(\"../../errors.js\");\nconst TNS_BASE64_ALPHABET_ARRAY = Buffer.from(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", 'utf8');\nconst FAST_AUTH_END_OF_RPC_VALUE = 0x800;\nconst FAST_AUTH_END_OF_RPC_OFFSET = 0x8;\nconst MSG_TYPE_OFFSET = 11;\n\n/**\n * Class used for byte chunks used in the ChunkedBytesBuffer.\n */\nclass BytesChunk {\n  /**\n   * Constructor.\n   * @param {Number} number of bytes to add to the chunk (rounded to the\n   * nearest chunk size to avoid unnecessary allocations and copies)\n   */\n  constructor(numBytes) {\n    this.allocLen = numBytes;\n    const remainder = numBytes % constants.CHUNKED_BYTES_CHUNK_SIZE;\n    if (remainder > 0) {\n      this.allocLen += constants.CHUNKED_BYTES_CHUNK_SIZE - remainder;\n    }\n    this.buf = Buffer.allocUnsafe(this.allocLen);\n    this.actualLen = 0;\n  }\n}\n\n/**\n * Class used for handling chunked reads.\n */\nclass ChunkedBytesBuffer {\n  /**\n   * Constructor.\n   */\n  constructor() {\n    this.chunks = [];\n  }\n\n  /**\n   * End the chunked read and return a consolidated buffer.\n   */\n  endChunkedRead() {\n    if (this.chunks.length > 1) {\n      let totalNumBytes = 0;\n      for (const chunk of this.chunks) {\n        totalNumBytes += chunk.actualLen;\n      }\n      let pos = 0;\n      const consolidatedChunk = new BytesChunk(totalNumBytes);\n      for (const chunk of this.chunks) {\n        chunk.buf.copy(consolidatedChunk.buf, pos, 0, chunk.actualLen);\n        pos += chunk.actualLen;\n      }\n      consolidatedChunk.actualLen = totalNumBytes;\n      this.chunks = [consolidatedChunk];\n    }\n    const chunk = this.chunks[0];\n    return chunk.buf.subarray(0, chunk.actualLen);\n  }\n\n  /**\n   * Constructor.\n   */\n  getBuf(numBytes) {\n    let chunk;\n    if (this.chunks.length > 0) {\n      chunk = this.chunks[this.chunks.length - 1];\n      if (chunk.allocLen - chunk.actualLen < numBytes) {\n        chunk = undefined;\n      }\n    }\n    if (!chunk) {\n      chunk = new BytesChunk(numBytes);\n      this.chunks.push(chunk);\n    }\n    const buf = chunk.buf.subarray(chunk.actualLen, chunk.actualLen + numBytes);\n    chunk.actualLen += numBytes;\n    return buf;\n  }\n\n  /**\n   * Start a chunked read. This ensures that only one chunk is available and\n   * its actual length is set to zero.\n   */\n  startChunkedRead() {\n    if (this.chunks.length > 0) {\n      this.chunks = this.chunks.splice(0, 1);\n      this.chunks[0].actualLen = 0;\n    }\n  }\n}\n\n/**\n * Encapsulates the Network Read Buffer\n *\n * @class ReadPacket\n */\n\nclass ReadPacket extends BaseBuffer {\n  /**\n   * Constructor.\n   * @param {Object} adapter used for sending/receiving data\n   * @param {Object} capabilities\n   */\n\n  constructor(nsi, caps) {\n    super();\n    this.nsi = nsi;\n    this.caps = caps;\n    this.chunkedBytesBuf = new ChunkedBytesBuffer();\n  }\n\n  /**\n   * Helper function that processes the length. If the length is defined as\n   * TNS_LONG_LENGTH_INDICATOR, a chunked read is performed.\n   */\n  _readBytesWithLength(numBytes) {\n    if (numBytes !== constants.TNS_LONG_LENGTH_INDICATOR) {\n      return this.readBytes(numBytes);\n    }\n    this.chunkedBytesBuf.startChunkedRead();\n    while (true) {\n      // eslint-disable-line\n      const numBytesInChunk = this.readUB4();\n      if (numBytesInChunk === 0) {\n        break;\n      }\n      this.readBytes(numBytesInChunk, true);\n    }\n    return this.chunkedBytesBuf.endChunkedRead();\n  }\n  skipBytes(numBytes) {\n    // if no bytes are left in the buffer, a new packet needs to be fetched\n    // before anything else can take place\n    if (this.pos === this.size) {\n      this.receivePacket();\n    }\n\n    // if there is enough room in the buffer to satisfy the number of bytes\n    // requested, return the buffer directly\n    const numBytesLeft = this.numBytesLeft();\n    if (numBytes <= numBytesLeft) {\n      this.pos += numBytes;\n      return;\n    }\n    numBytes -= numBytesLeft;\n\n    // acquire packets until the requested number of bytes is satisfied\n    while (numBytes > 0) {\n      this.receivePacket();\n      const numSplitBytes = Math.min(numBytes, this.size - this.pos);\n      this.pos += numSplitBytes;\n      numBytes -= numSplitBytes;\n    }\n  }\n\n  /**\n   * Returns a buffer containing the specified number of bytes. If an\n   * insufficient number of bytes are available, a new packet is read.\n   * @param {Number} specifies the number of bytes to read from the buffer\n   */\n  readBytes(numBytes, inChunkedRead = false) {\n    // if no bytes are left in the buffer, a new packet needs to be fetched\n    // before anything else can take place\n    if (this.pos === this.size) {\n      this.receivePacket();\n    }\n\n    // if there is enough room in the buffer to satisfy the number of bytes\n    // requested, return the buffer directly\n    const numBytesLeft = this.numBytesLeft();\n    if (numBytes <= numBytesLeft) {\n      let buf;\n      if (inChunkedRead) {\n        buf = this.chunkedBytesBuf.getBuf(numBytes);\n        this.buf.copy(buf, 0, this.pos, this.pos + numBytes);\n      } else {\n        buf = this.buf.subarray(this.pos, this.pos + numBytes);\n      }\n      this.pos += numBytes;\n      return buf;\n    }\n\n    // the requested bytes are split across multiple packets; if a chunked read\n    // is in progress, a chunk is acquired that will accommodate the requested\n    // bytes; otherwise, a separate buffer will be allocated to accommodate the\n    // requested bytes\n    let buf;\n    if (inChunkedRead) {\n      buf = this.chunkedBytesBuf.getBuf(numBytes);\n    } else {\n      buf = Buffer.allocUnsafe(numBytes);\n    }\n\n    // copy the bytes to the buffer from the remainder of this packet\n    let offset = 0;\n    this.buf.copy(buf, offset, this.pos, this.pos + numBytesLeft);\n    offset += numBytesLeft;\n    numBytes -= numBytesLeft;\n\n    // acquire packets until the requested number of bytes is satisfied\n    while (numBytes > 0) {\n      this.receivePacket();\n      const numSplitBytes = Math.min(numBytes, this.size - this.pos);\n      this.buf.copy(buf, offset, this.pos, this.pos + numSplitBytes);\n      this.pos += numSplitBytes;\n      offset += numSplitBytes;\n      numBytes -= numSplitBytes;\n    }\n    return buf;\n  }\n\n  /**\n   * Receives a packet from the adapter.\n   */\n  receivePacket() {\n    if (this.savedPacketPos === this.savedPackets.length) {\n      const packet = this.nsi.syncRecvPacket();\n      if (!packet || this.nsi.isBreak) throw new utils.OutOfPacketsError();\n      this.savedPackets.push(packet);\n    }\n    this.startPacket(this.savedPackets[this.savedPacketPos++]);\n  }\n  restorePoint() {\n    this.savedPacketPos = 0;\n    this.startPacket(this.savedPackets[this.savedPacketPos++]);\n    this.pos = this.savedPos;\n  }\n  savePoint() {\n    if (this.savedPackets) {\n      this.savedPackets = this.savedPackets.splice(this.savedPacketPos - 1);\n    } else {\n      this.savedPackets = [this.packet];\n    }\n    this.savedPacketPos = 1;\n    this.savedPos = this.pos;\n  }\n  startPacket(packet) {\n    this.packet = packet;\n    this.buf = packet.buf;\n    this.pos = 10; // skip packet heaader and data flags\n    this.size = packet.buf.length;\n    this.packetNum = packet.num;\n  }\n\n  /**\n   * Read packets from network.\n   * If checkRequestBoundary is passed as true, it\n   * would read all packets until end of request\n   * boundary is seen in nwk header.\n   */\n  async waitForPackets(checkRequestBoundary = false) {\n    let packet = await this.nsi.recvPacket();\n    if (!this.savedPackets) {\n      this.savedPackets = [packet];\n      this.savedPacketPos = 0;\n    } else {\n      this.savedPackets.push(packet);\n    }\n    if (checkRequestBoundary && this.nsi.endOfRequestSupport) {\n      while (packet.type === constants.TNS_PACKET_TYPE_DATA) {\n        // End Marker\n        if (packet.buf.readUInt16BE(8) & constants.TNS_DATA_FLAGS_END_OF_REQUEST) {\n          break;\n        }\n\n        // Single Byte 1D packet\n        if (packet.buf.length === MSG_TYPE_OFFSET && packet.buf[MSG_TYPE_OFFSET - 1] === constants.TNS_MSG_TYPE_END_OF_REQUEST) {\n          break;\n        }\n        packet = await this.nsi.recvPacket();\n        this.savedPackets.push(packet);\n      }\n    }\n    this.startPacket(this.savedPackets[this.savedPacketPos++]);\n  }\n\n  /**\n   * Reads OSON (QLocator followed by data) and decodes it into a JavaScript\n   * object.\n   */\n  readOson() {\n    const numBytes = this.readUB4();\n    if (numBytes === 0) {\n      return null;\n    }\n    this.skipUB8(); // size (unused)\n    this.skipUB4(); // chunk size (unused)\n    const decoder = new oson.OsonDecoder(this.readBytesWithLength());\n    this.skipBytesChunked(); // locator (unused)\n    return decoder.decode();\n  }\n  readURowID() {\n    let outputOffset = 0,\n      inputOffset = 1;\n    let buf = this.readBytesWithLength();\n    if (buf === null) return null;\n    buf = this.readBytesWithLength();\n    let inputLen = buf.length;\n\n    // Handle physical rowid\n    if (buf && buf[0] === 1) {\n      const rba = buf.readUInt32BE(1);\n      const partitionID = buf.readUInt16BE(5);\n      const blockNum = buf.readUInt32BE(7);\n      const slotNum = buf.readUInt16BE(11);\n      return utils.encodeRowID({\n        rba,\n        partitionID,\n        blockNum,\n        slotNum\n      });\n    }\n\n    // handle logical rowid\n    let outputLen = Math.floor(inputLen / 3) * 4;\n    const remainder = inputLen % 3;\n    if (remainder === 1) {\n      outputLen += 1;\n    } else if (remainder === 2) {\n      outputLen += 3;\n    }\n    const outputValue = Buffer.allocUnsafe(outputLen);\n    inputLen -= 1;\n    outputValue[0] = 42;\n    outputOffset += 1;\n    while (inputLen > 0) {\n      // produce first byte of quadruple\n      let pos = buf[inputOffset] >> 2;\n      outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n      outputOffset += 1;\n\n      // produce second byte of quadruple, but if only one byte is left,\n      // produce that one byte and exit\n      pos = (buf[inputOffset] & 0x3) << 4;\n      if (inputLen == 1) {\n        outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n        break;\n      }\n      inputOffset += 1;\n      pos |= (buf[inputOffset] & 0xf0) >> 4;\n      outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n      outputOffset += 1;\n\n      // produce third byte of quadruple, but if only two bytes are left,\n      // produce that one byte and exit\n      pos = (buf[inputOffset] & 0xf) << 2;\n      if (inputLen == 2) {\n        outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n        break;\n      }\n      inputOffset += 1;\n      pos |= (buf[inputOffset] & 0xc0) >> 6;\n      outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n      outputOffset += 1;\n\n      // produce final byte of quadruple\n      pos = buf[inputOffset] & 0x3f;\n      outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n      outputOffset += 1;\n      inputOffset += 1;\n      inputLen -= 3;\n    }\n    return outputValue.toString('utf-8');\n  }\n  readRowID() {\n    const rba = this.readUB4();\n    const partitionID = this.readUB2();\n    this.skipUB1();\n    const blockNum = this.readUB4();\n    const slotNum = this.readUB2();\n    return {\n      rba,\n      partitionID,\n      blockNum,\n      slotNum\n    };\n  }\n\n  /**\n   * Reads VECTOR data (QLocator followed by data) and decodes it into a\n   * JavaScript object.\n   */\n  readVector() {\n    const numBytes = this.readUB4();\n    if (numBytes === 0) {\n      return null;\n    }\n    this.skipUB8(); // size (unused)\n    this.skipUB4(); // chunk size (unused)\n    const decoder = new vector.VectorDecoder(this.readBytesWithLength());\n    this.skipBytesChunked(); // locator (unused)\n    return decoder.decode();\n  }\n  skipBytesChunked() {\n    const numBytes = this.readUInt8();\n    if (numBytes === 0 || numBytes === constants.TNS_NULL_LENGTH_INDICATOR) {\n      return;\n    }\n    if (numBytes !== constants.TNS_LONG_LENGTH_INDICATOR) {\n      this.skipBytes(numBytes);\n    } else {\n      while (true) {\n        // eslint-disable-line\n        const tempNumBytes = this.readUB4();\n        if (tempNumBytes === 0) break;\n        this.skipBytes(tempNumBytes);\n      }\n    }\n  }\n  readNullTerminatedBytes(maxSize = 50) {\n    let offset = 0;\n    const tmp = Buffer.allocUnsafe(maxSize);\n    while (offset < maxSize) {\n      tmp[offset] = this.readUInt8();\n      if (tmp[offset] === 0) {\n        break;\n      }\n      offset = offset + 1;\n    }\n    if (offset === maxSize) {\n      const reason = `Byte Arrray Exceeded MaxSize ${maxSize}`;\n      errors.throwErr(errors.ERR_INTERNAL, reason);\n    }\n    return tmp.subarray(0, offset + 1);\n  }\n}\n\n/**\n * Encapsulates the Network Write Buffer\n *\n * @class WritePacket\n */\nclass WritePacket extends BaseBuffer {\n  constructor(nsi, caps, protocol) {\n    super(nsi.sAtts.sdu);\n    this.size = this.maxSize;\n    this.isLargeSDU = nsi.sAtts.version >= constants.TNS_VERSION_MIN_LARGE_SDU;\n    this.protocol = protocol;\n    this.packetType = constants.TNS_PACKET_TYPE_DATA;\n    this.caps = caps;\n    this.nsi = nsi;\n  }\n\n  /**\n   * Grows the buffer by sending the existing buffer on the transport. A copy\n   * is made so that the existing buffer can be used for the next batch of data\n   * that needs to be sent\n   */\n  _grow() {\n    this._sendPacket();\n  }\n\n  /**\n   * Sends the data in the buffer on the transport. First, the packet header is\n   * set up by writing the size and packet type.\n   */\n  _sendPacket(finalPacket = false) {\n    const size = this.pos;\n    this.pos = 0;\n    if (this.isLargeSDU) {\n      this.writeUInt32BE(size);\n    } else {\n      this.writeUInt16BE(size);\n      this.writeUInt16BE(0);\n    }\n    this.writeUInt8(this.packetType);\n    this.writeUInt8(0);\n    this.writeUInt16BE(0);\n    let buf = this.buf.subarray(0, size);\n    if (!finalPacket) {\n      buf = Buffer.from(buf);\n      this.startPacket();\n    } else {\n      // Write End of RPC bit in last packet used only for fastAuth Message.\n      this.buf.writeUInt16BE(FAST_AUTH_END_OF_RPC_VALUE, FAST_AUTH_END_OF_RPC_OFFSET);\n    }\n    if (!this.nsi.ntAdapter) {\n      errors.throwErr(errors.ERR_INVALID_CONNECTION);\n    }\n    this.nsi.ntAdapter.send(buf);\n  }\n\n  /**\n   * Starts a packet.\n   */\n  startPacket(dataFlags = 0) {\n    this.pos = constants.PACKET_HEADER_SIZE;\n    if (this.packetType === constants.TNS_PACKET_TYPE_DATA) {\n      this.writeUInt16BE(dataFlags);\n    }\n  }\n\n  /**\n   * Starts a database request.\n   */\n  startRequest(packetType, dataFlags = 0) {\n    this.packetType = packetType;\n    this.startPacket(dataFlags);\n  }\n\n  /**\n   * Ends a database request.\n   */\n  endRequest() {\n    if (this.pos > constants.PACKET_HEADER_SIZE) {\n      this._sendPacket(true);\n    }\n  }\n  writeKeyValue(key, value, flags = 0) {\n    const keyBytesLen = Buffer.byteLength(key);\n    const valBytesLen = Buffer.byteLength(value);\n    this.writeUB4(keyBytesLen);\n    this.writeBytesWithLength(Buffer.from(key));\n    this.writeUB4(valBytesLen);\n    if (valBytesLen > 0) {\n      this.writeBytesWithLength(Buffer.from(value));\n    }\n    this.writeUB4(flags);\n  }\n\n  /**\n   * Encodes a JavaScript object into OSON and then writes it (QLocator\n   * followed by data) to the buffer.\n   */\n  writeOson(value, osonMaxFieldSize) {\n    const encoder = new oson.OsonEncoder();\n    const buf = encoder.encode(value, osonMaxFieldSize);\n    this.writeQLocator(buf.length);\n    this.writeBytesWithLength(buf);\n  }\n  writeSeqNum() {\n    this.writeUInt8(this.protocol.sequenceId);\n    this.protocol.sequenceId = (this.protocol.sequenceId + 1) % 256;\n  }\n\n  /**\n   * Encodes a JavaScript object into VECTOR data and then writes it (QLocator\n   * followed by data) to the buffer.\n   */\n  writeVector(value) {\n    const encoder = new vector.VectorEncoder();\n    const buf = encoder.encode(value);\n    this.writeQLocator(buf.length);\n    this.writeBytesWithLength(buf);\n  }\n\n  //---------------------------------------------------------------------------\n  // writeQLocator()\n  //\n  // Writes a QLocator. QLocators are always 40 bytes in length.\n  //---------------------------------------------------------------------------\n  writeQLocator(numBytes) {\n    this.writeUB4(40); // QLocator length\n    this.writeUInt8(40); // repeated length\n    this.writeUInt16BE(38); // internal length\n    this.writeUInt16BE(constants.TNS_LOB_QLOCATOR_VERSION);\n    this.writeUInt8(constants.TNS_LOB_LOC_FLAGS_VALUE_BASED | constants.TNS_LOB_LOC_FLAGS_BLOB | constants.TNS_LOB_LOC_FLAGS_ABSTRACT);\n    this.writeUInt8(constants.TNS_LOB_LOC_FLAGS_INIT);\n    this.writeUInt16BE(0); // additional flags\n    this.writeUInt16BE(1); // byt1\n    this.writeUInt64BE(numBytes);\n    this.writeUInt16BE(0); // unused\n    this.writeUInt16BE(0); // csid\n    this.writeUInt16BE(0); // unused\n    this.writeUInt64BE(0); // unused\n    this.writeUInt64BE(0); // unused\n  }\n}\nmodule.exports = {\n  ReadPacket,\n  WritePacket\n};","map":{"version":3,"names":["BaseBuffer","require","Buffer","constants","oson","utils","vector","errors","TNS_BASE64_ALPHABET_ARRAY","from","FAST_AUTH_END_OF_RPC_VALUE","FAST_AUTH_END_OF_RPC_OFFSET","MSG_TYPE_OFFSET","BytesChunk","constructor","numBytes","allocLen","remainder","CHUNKED_BYTES_CHUNK_SIZE","buf","allocUnsafe","actualLen","ChunkedBytesBuffer","chunks","endChunkedRead","length","totalNumBytes","chunk","pos","consolidatedChunk","copy","subarray","getBuf","undefined","push","startChunkedRead","splice","ReadPacket","nsi","caps","chunkedBytesBuf","_readBytesWithLength","TNS_LONG_LENGTH_INDICATOR","readBytes","numBytesInChunk","readUB4","skipBytes","size","receivePacket","numBytesLeft","numSplitBytes","Math","min","inChunkedRead","offset","savedPacketPos","savedPackets","packet","syncRecvPacket","isBreak","OutOfPacketsError","startPacket","restorePoint","savedPos","savePoint","packetNum","num","waitForPackets","checkRequestBoundary","recvPacket","endOfRequestSupport","type","TNS_PACKET_TYPE_DATA","readUInt16BE","TNS_DATA_FLAGS_END_OF_REQUEST","TNS_MSG_TYPE_END_OF_REQUEST","readOson","skipUB8","skipUB4","decoder","OsonDecoder","readBytesWithLength","skipBytesChunked","decode","readURowID","outputOffset","inputOffset","inputLen","rba","readUInt32BE","partitionID","blockNum","slotNum","encodeRowID","outputLen","floor","outputValue","toString","readRowID","readUB2","skipUB1","readVector","VectorDecoder","readUInt8","TNS_NULL_LENGTH_INDICATOR","tempNumBytes","readNullTerminatedBytes","maxSize","tmp","reason","throwErr","ERR_INTERNAL","WritePacket","protocol","sAtts","sdu","isLargeSDU","version","TNS_VERSION_MIN_LARGE_SDU","packetType","_grow","_sendPacket","finalPacket","writeUInt32BE","writeUInt16BE","writeUInt8","ntAdapter","ERR_INVALID_CONNECTION","send","dataFlags","PACKET_HEADER_SIZE","startRequest","endRequest","writeKeyValue","key","value","flags","keyBytesLen","byteLength","valBytesLen","writeUB4","writeBytesWithLength","writeOson","osonMaxFieldSize","encoder","OsonEncoder","encode","writeQLocator","writeSeqNum","sequenceId","writeVector","VectorEncoder","TNS_LOB_QLOCATOR_VERSION","TNS_LOB_LOC_FLAGS_VALUE_BASED","TNS_LOB_LOC_FLAGS_BLOB","TNS_LOB_LOC_FLAGS_ABSTRACT","TNS_LOB_LOC_FLAGS_INIT","writeUInt64BE","module","exports"],"sources":["C:/Users/Koliv/Desktop/Software/my-react-app/node_modules/oracledb/lib/thin/protocol/packet.js"],"sourcesContent":["// Copyright (c) 2022, 2024, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst { BaseBuffer } = require('../../impl/datahandlers/buffer.js');\nconst { Buffer } = require('buffer');\nconst constants = require('./constants.js');\nconst oson = require('../../impl/datahandlers/oson.js');\nconst utils = require('./utils.js');\nconst vector = require('../../impl/datahandlers/vector.js');\nconst errors = require(\"../../errors.js\");\n\nconst TNS_BASE64_ALPHABET_ARRAY = Buffer.from(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", 'utf8');\nconst FAST_AUTH_END_OF_RPC_VALUE = 0x800;\nconst FAST_AUTH_END_OF_RPC_OFFSET = 0x8;\nconst MSG_TYPE_OFFSET = 11;\n\n/**\n * Class used for byte chunks used in the ChunkedBytesBuffer.\n */\nclass BytesChunk {\n\n  /**\n   * Constructor.\n   * @param {Number} number of bytes to add to the chunk (rounded to the\n   * nearest chunk size to avoid unnecessary allocations and copies)\n   */\n  constructor(numBytes) {\n    this.allocLen = numBytes;\n    const remainder = numBytes % constants.CHUNKED_BYTES_CHUNK_SIZE;\n    if (remainder > 0) {\n      this.allocLen += (constants.CHUNKED_BYTES_CHUNK_SIZE - remainder);\n    }\n    this.buf = Buffer.allocUnsafe(this.allocLen);\n    this.actualLen = 0;\n  }\n\n}\n\n\n/**\n * Class used for handling chunked reads.\n */\nclass ChunkedBytesBuffer {\n\n  /**\n   * Constructor.\n   */\n  constructor() {\n    this.chunks = [];\n  }\n\n  /**\n   * End the chunked read and return a consolidated buffer.\n   */\n  endChunkedRead() {\n    if (this.chunks.length > 1) {\n      let totalNumBytes = 0;\n      for (const chunk of this.chunks) {\n        totalNumBytes += chunk.actualLen;\n      }\n      let pos = 0;\n      const consolidatedChunk = new BytesChunk(totalNumBytes);\n      for (const chunk of this.chunks) {\n        chunk.buf.copy(consolidatedChunk.buf, pos, 0, chunk.actualLen);\n        pos += chunk.actualLen;\n      }\n      consolidatedChunk.actualLen = totalNumBytes;\n      this.chunks = [consolidatedChunk];\n    }\n    const chunk = this.chunks[0];\n    return chunk.buf.subarray(0, chunk.actualLen);\n  }\n\n  /**\n   * Constructor.\n   */\n  getBuf(numBytes) {\n    let chunk;\n    if (this.chunks.length > 0) {\n      chunk = this.chunks[this.chunks.length - 1];\n      if (chunk.allocLen - chunk.actualLen < numBytes) {\n        chunk = undefined;\n      }\n    }\n    if (!chunk) {\n      chunk = new BytesChunk(numBytes);\n      this.chunks.push(chunk);\n    }\n    const buf = chunk.buf.subarray(chunk.actualLen,\n      chunk.actualLen + numBytes);\n    chunk.actualLen += numBytes;\n    return buf;\n  }\n\n  /**\n   * Start a chunked read. This ensures that only one chunk is available and\n   * its actual length is set to zero.\n   */\n  startChunkedRead() {\n    if (this.chunks.length > 0) {\n      this.chunks = this.chunks.splice(0, 1);\n      this.chunks[0].actualLen = 0;\n    }\n  }\n\n}\n\n\n/**\n * Encapsulates the Network Read Buffer\n *\n * @class ReadPacket\n */\n\nclass ReadPacket extends BaseBuffer {\n\n  /**\n   * Constructor.\n   * @param {Object} adapter used for sending/receiving data\n   * @param {Object} capabilities\n   */\n\n  constructor(nsi, caps) {\n    super();\n    this.nsi = nsi;\n    this.caps = caps;\n    this.chunkedBytesBuf = new ChunkedBytesBuffer();\n  }\n\n  /**\n   * Helper function that processes the length. If the length is defined as\n   * TNS_LONG_LENGTH_INDICATOR, a chunked read is performed.\n   */\n  _readBytesWithLength(numBytes) {\n    if (numBytes !== constants.TNS_LONG_LENGTH_INDICATOR) {\n      return this.readBytes(numBytes);\n    }\n    this.chunkedBytesBuf.startChunkedRead();\n    while (true) { // eslint-disable-line\n      const numBytesInChunk = this.readUB4();\n      if (numBytesInChunk === 0) {\n        break;\n      }\n      this.readBytes(numBytesInChunk, true);\n    }\n    return this.chunkedBytesBuf.endChunkedRead();\n  }\n\n  skipBytes(numBytes) {\n\n    // if no bytes are left in the buffer, a new packet needs to be fetched\n    // before anything else can take place\n    if (this.pos === this.size) {\n      this.receivePacket();\n    }\n\n    // if there is enough room in the buffer to satisfy the number of bytes\n    // requested, return the buffer directly\n    const numBytesLeft = this.numBytesLeft();\n    if (numBytes <= numBytesLeft) {\n      this.pos += numBytes;\n      return;\n    }\n    numBytes -= numBytesLeft;\n\n    // acquire packets until the requested number of bytes is satisfied\n    while (numBytes > 0) {\n      this.receivePacket();\n      const numSplitBytes = Math.min(numBytes, this.size - this.pos);\n      this.pos += numSplitBytes;\n      numBytes -= numSplitBytes;\n    }\n  }\n\n  /**\n   * Returns a buffer containing the specified number of bytes. If an\n   * insufficient number of bytes are available, a new packet is read.\n   * @param {Number} specifies the number of bytes to read from the buffer\n   */\n  readBytes(numBytes, inChunkedRead = false) {\n\n    // if no bytes are left in the buffer, a new packet needs to be fetched\n    // before anything else can take place\n    if (this.pos === this.size) {\n      this.receivePacket();\n    }\n\n    // if there is enough room in the buffer to satisfy the number of bytes\n    // requested, return the buffer directly\n    const numBytesLeft = this.numBytesLeft();\n    if (numBytes <= numBytesLeft) {\n      let buf;\n      if (inChunkedRead) {\n        buf = this.chunkedBytesBuf.getBuf(numBytes);\n        this.buf.copy(buf, 0, this.pos, this.pos + numBytes);\n      } else {\n        buf = this.buf.subarray(this.pos, this.pos + numBytes);\n      }\n      this.pos += numBytes;\n      return buf;\n    }\n\n    // the requested bytes are split across multiple packets; if a chunked read\n    // is in progress, a chunk is acquired that will accommodate the requested\n    // bytes; otherwise, a separate buffer will be allocated to accommodate the\n    // requested bytes\n    let buf;\n    if (inChunkedRead) {\n      buf = this.chunkedBytesBuf.getBuf(numBytes);\n    } else {\n      buf = Buffer.allocUnsafe(numBytes);\n    }\n\n    // copy the bytes to the buffer from the remainder of this packet\n    let offset = 0;\n    this.buf.copy(buf, offset, this.pos, this.pos + numBytesLeft);\n    offset += numBytesLeft;\n    numBytes -= numBytesLeft;\n\n    // acquire packets until the requested number of bytes is satisfied\n    while (numBytes > 0) {\n      this.receivePacket();\n      const numSplitBytes = Math.min(numBytes, this.size - this.pos);\n      this.buf.copy(buf, offset, this.pos, this.pos + numSplitBytes);\n      this.pos += numSplitBytes;\n      offset += numSplitBytes;\n      numBytes -= numSplitBytes;\n    }\n\n    return buf;\n\n  }\n\n  /**\n   * Receives a packet from the adapter.\n   */\n  receivePacket() {\n    if (this.savedPacketPos === this.savedPackets.length) {\n      const packet = this.nsi.syncRecvPacket();\n      if (!packet || this.nsi.isBreak)\n        throw new utils.OutOfPacketsError();\n      this.savedPackets.push(packet);\n    }\n    this.startPacket(this.savedPackets[this.savedPacketPos++]);\n  }\n\n  restorePoint() {\n    this.savedPacketPos = 0;\n    this.startPacket(this.savedPackets[this.savedPacketPos++]);\n    this.pos = this.savedPos;\n  }\n\n  savePoint() {\n    if (this.savedPackets) {\n      this.savedPackets = this.savedPackets.splice(this.savedPacketPos - 1);\n    } else {\n      this.savedPackets = [this.packet];\n    }\n    this.savedPacketPos = 1;\n    this.savedPos = this.pos;\n  }\n\n  startPacket(packet) {\n    this.packet = packet;\n    this.buf = packet.buf;\n    this.pos = 10;                      // skip packet heaader and data flags\n    this.size = packet.buf.length;\n    this.packetNum = packet.num;\n  }\n\n  /**\n   * Read packets from network.\n   * If checkRequestBoundary is passed as true, it\n   * would read all packets until end of request\n   * boundary is seen in nwk header.\n   */\n  async waitForPackets(checkRequestBoundary = false) {\n    let packet = await this.nsi.recvPacket();\n    if (!this.savedPackets) {\n      this.savedPackets = [packet];\n      this.savedPacketPos = 0;\n    } else {\n      this.savedPackets.push(packet);\n    }\n    if (checkRequestBoundary && this.nsi.endOfRequestSupport) {\n      while (packet.type === constants.TNS_PACKET_TYPE_DATA) {\n        // End Marker\n        if ((packet.buf.readUInt16BE(8) &\n            constants.TNS_DATA_FLAGS_END_OF_REQUEST)) {\n          break;\n        }\n\n        // Single Byte 1D packet\n        if (packet.buf.length === MSG_TYPE_OFFSET &&\n            packet.buf[MSG_TYPE_OFFSET - 1] ===\n            constants.TNS_MSG_TYPE_END_OF_REQUEST) {\n          break;\n        }\n        packet = await this.nsi.recvPacket();\n        this.savedPackets.push(packet);\n      }\n    }\n    this.startPacket(this.savedPackets[this.savedPacketPos++]);\n  }\n\n  /**\n   * Reads OSON (QLocator followed by data) and decodes it into a JavaScript\n   * object.\n   */\n  readOson() {\n    const numBytes = this.readUB4();\n    if (numBytes === 0) {\n      return null;\n    }\n    this.skipUB8();                     // size (unused)\n    this.skipUB4();                     // chunk size (unused)\n    const decoder = new oson.OsonDecoder(this.readBytesWithLength());\n    this.skipBytesChunked();            // locator (unused)\n    return decoder.decode();\n  }\n\n  readURowID() {\n    let outputOffset = 0, inputOffset = 1;\n    let buf = this.readBytesWithLength();\n    if (buf === null)\n      return null;\n    buf = this.readBytesWithLength();\n    let inputLen = buf.length;\n\n    // Handle physical rowid\n    if (buf && buf[0] === 1) {\n      const rba = buf.readUInt32BE(1);\n      const partitionID = buf.readUInt16BE(5);\n      const blockNum = buf.readUInt32BE(7);\n      const slotNum = buf.readUInt16BE(11);\n      return utils.encodeRowID({rba, partitionID, blockNum, slotNum});\n    }\n\n    // handle logical rowid\n    let outputLen = Math.floor(inputLen / 3) * 4;\n    const remainder = inputLen % 3;\n    if (remainder === 1) {\n      outputLen += 1;\n    } else if (remainder === 2) {\n      outputLen += 3;\n    }\n\n    const outputValue =  Buffer.allocUnsafe(outputLen);\n    inputLen -= 1;\n    outputValue[0] = 42;\n    outputOffset += 1;\n    while (inputLen > 0) {\n      // produce first byte of quadruple\n      let pos = buf[inputOffset] >> 2;\n      outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n      outputOffset += 1;\n\n      // produce second byte of quadruple, but if only one byte is left,\n      // produce that one byte and exit\n      pos = (buf[inputOffset] & 0x3) << 4;\n      if (inputLen == 1) {\n        outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n        break;\n      }\n      inputOffset += 1;\n      pos |= ((buf[inputOffset] & 0xf0) >> 4);\n      outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n      outputOffset += 1;\n\n      // produce third byte of quadruple, but if only two bytes are left,\n      // produce that one byte and exit\n      pos = (buf[inputOffset] & 0xf) << 2;\n      if (inputLen == 2) {\n        outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n        break;\n      }\n      inputOffset += 1;\n      pos |= ((buf[inputOffset] & 0xc0) >> 6);\n      outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n      outputOffset += 1;\n\n      // produce final byte of quadruple\n      pos = buf[inputOffset] & 0x3f;\n      outputValue[outputOffset] = TNS_BASE64_ALPHABET_ARRAY[pos];\n      outputOffset += 1;\n      inputOffset += 1;\n      inputLen -= 3;\n    }\n    return outputValue.toString('utf-8');\n  }\n\n  readRowID() {\n    const rba = this.readUB4();\n    const partitionID = this.readUB2();\n    this.skipUB1();\n    const blockNum = this.readUB4();\n    const slotNum = this.readUB2();\n    return {rba, partitionID, blockNum, slotNum};\n  }\n\n  /**\n   * Reads VECTOR data (QLocator followed by data) and decodes it into a\n   * JavaScript object.\n   */\n  readVector() {\n    const numBytes = this.readUB4();\n    if (numBytes === 0) {\n      return null;\n    }\n    this.skipUB8();                     // size (unused)\n    this.skipUB4();                     // chunk size (unused)\n    const decoder = new vector.VectorDecoder(this.readBytesWithLength());\n    this.skipBytesChunked();            // locator (unused)\n    return decoder.decode();\n  }\n\n  skipBytesChunked() {\n    const numBytes = this.readUInt8();\n    if (numBytes === 0 || numBytes === constants.TNS_NULL_LENGTH_INDICATOR) {\n      return;\n    }\n    if (numBytes !== constants.TNS_LONG_LENGTH_INDICATOR) {\n      this.skipBytes(numBytes);\n    } else {\n      while (true) { // eslint-disable-line\n        const tempNumBytes = this.readUB4();\n        if (tempNumBytes === 0)\n          break;\n        this.skipBytes(tempNumBytes);\n      }\n    }\n  }\n\n  readNullTerminatedBytes(maxSize = 50) {\n    let offset = 0;\n    const tmp = Buffer.allocUnsafe(maxSize);\n    while (offset < maxSize) {\n      tmp[offset] = this.readUInt8();\n      if (tmp[offset] === 0) {\n        break;\n      }\n      offset = offset + 1;\n    }\n    if (offset === maxSize) {\n      const reason = `Byte Arrray Exceeded MaxSize ${maxSize}`;\n      errors.throwErr(errors.ERR_INTERNAL, reason);\n    }\n    return tmp.subarray(0, offset + 1);\n  }\n\n}\n\n\n/**\n * Encapsulates the Network Write Buffer\n *\n * @class WritePacket\n */\nclass WritePacket extends BaseBuffer {\n\n  constructor(nsi, caps, protocol) {\n    super(nsi.sAtts.sdu);\n    this.size = this.maxSize;\n    this.isLargeSDU = nsi.sAtts.version >= constants.TNS_VERSION_MIN_LARGE_SDU;\n    this.protocol = protocol;\n    this.packetType = constants.TNS_PACKET_TYPE_DATA;\n    this.caps = caps;\n    this.nsi = nsi;\n  }\n\n  /**\n   * Grows the buffer by sending the existing buffer on the transport. A copy\n   * is made so that the existing buffer can be used for the next batch of data\n   * that needs to be sent\n   */\n  _grow() {\n    this._sendPacket();\n  }\n\n  /**\n   * Sends the data in the buffer on the transport. First, the packet header is\n   * set up by writing the size and packet type.\n   */\n  _sendPacket(finalPacket = false) {\n    const size = this.pos;\n    this.pos = 0;\n    if (this.isLargeSDU) {\n      this.writeUInt32BE(size);\n    } else {\n      this.writeUInt16BE(size);\n      this.writeUInt16BE(0);\n    }\n    this.writeUInt8(this.packetType);\n    this.writeUInt8(0);\n    this.writeUInt16BE(0);\n    let buf = this.buf.subarray(0, size);\n    if (!finalPacket) {\n      buf = Buffer.from(buf);\n      this.startPacket();\n    } else {\n      // Write End of RPC bit in last packet used only for fastAuth Message.\n      this.buf.writeUInt16BE(FAST_AUTH_END_OF_RPC_VALUE,\n        FAST_AUTH_END_OF_RPC_OFFSET);\n    }\n    if (!this.nsi.ntAdapter) {\n      errors.throwErr(errors.ERR_INVALID_CONNECTION);\n    }\n    this.nsi.ntAdapter.send(buf);\n  }\n\n  /**\n   * Starts a packet.\n   */\n  startPacket(dataFlags = 0) {\n    this.pos = constants.PACKET_HEADER_SIZE;\n    if (this.packetType === constants.TNS_PACKET_TYPE_DATA) {\n      this.writeUInt16BE(dataFlags);\n    }\n  }\n\n  /**\n   * Starts a database request.\n   */\n  startRequest(packetType, dataFlags = 0) {\n    this.packetType = packetType;\n    this.startPacket(dataFlags);\n  }\n\n  /**\n   * Ends a database request.\n   */\n  endRequest() {\n    if (this.pos > constants.PACKET_HEADER_SIZE) {\n      this._sendPacket(true);\n    }\n  }\n\n  writeKeyValue(key, value, flags = 0) {\n    const keyBytesLen = Buffer.byteLength(key);\n    const valBytesLen = Buffer.byteLength(value);\n    this.writeUB4(keyBytesLen);\n    this.writeBytesWithLength(Buffer.from(key));\n    this.writeUB4(valBytesLen);\n    if (valBytesLen > 0) {\n      this.writeBytesWithLength(Buffer.from(value));\n    }\n    this.writeUB4(flags);\n  }\n\n  /**\n   * Encodes a JavaScript object into OSON and then writes it (QLocator\n   * followed by data) to the buffer.\n   */\n  writeOson(value, osonMaxFieldSize) {\n    const encoder = new oson.OsonEncoder();\n    const buf = encoder.encode(value, osonMaxFieldSize);\n    this.writeQLocator(buf.length);\n    this.writeBytesWithLength(buf);\n  }\n\n  writeSeqNum() {\n    this.writeUInt8(this.protocol.sequenceId);\n    this.protocol.sequenceId = (this.protocol.sequenceId + 1) % 256;\n  }\n\n  /**\n   * Encodes a JavaScript object into VECTOR data and then writes it (QLocator\n   * followed by data) to the buffer.\n   */\n  writeVector(value) {\n    const encoder = new vector.VectorEncoder();\n    const buf = encoder.encode(value);\n    this.writeQLocator(buf.length);\n    this.writeBytesWithLength(buf);\n  }\n\n  //---------------------------------------------------------------------------\n  // writeQLocator()\n  //\n  // Writes a QLocator. QLocators are always 40 bytes in length.\n  //---------------------------------------------------------------------------\n  writeQLocator(numBytes) {\n    this.writeUB4(40);                  // QLocator length\n    this.writeUInt8(40);                // repeated length\n    this.writeUInt16BE(38);             // internal length\n    this.writeUInt16BE(constants.TNS_LOB_QLOCATOR_VERSION);\n    this.writeUInt8(constants.TNS_LOB_LOC_FLAGS_VALUE_BASED |\n      constants.TNS_LOB_LOC_FLAGS_BLOB | constants.TNS_LOB_LOC_FLAGS_ABSTRACT);\n    this.writeUInt8(constants.TNS_LOB_LOC_FLAGS_INIT);\n    this.writeUInt16BE(0);              // additional flags\n    this.writeUInt16BE(1);              // byt1\n    this.writeUInt64BE(numBytes);\n    this.writeUInt16BE(0);              // unused\n    this.writeUInt16BE(0);              // csid\n    this.writeUInt16BE(0);              // unused\n    this.writeUInt64BE(0);              // unused\n    this.writeUInt64BE(0);              // unused\n  }\n\n}\n\nmodule.exports = {\n  ReadPacket,\n  WritePacket\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}