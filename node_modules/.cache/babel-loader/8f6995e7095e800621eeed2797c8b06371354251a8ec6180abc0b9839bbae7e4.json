{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst {\n  createNVPair,\n  findValue\n} = require(\"./nvStrToNvPair.js\");\nconst fs = require('fs');\nconst process = require('process');\nconst readline = require('readline');\nconst errors = require(\"../../errors.js\");\nconst MAX_IFILE_DEPTH = 4;\n/**\n * Returns File path of the tnsnames.ora if it exists.\n */\nfunction tnsnamesFilePath(configDir) {\n  let filePathVal = null;\n  const tnsAdminVal = process.env.TNS_ADMIN;\n  if (configDir) {\n    filePathVal = configDir + '/tnsnames.ora';\n    if (fs.existsSync(filePathVal)) {\n      return filePathVal;\n    } else {\n      errors.throwErr(errors.ERR_TNS_NAMES_FILE_MISSING, configDir);\n    }\n  } else {\n    if (!tnsAdminVal) {\n      errors.throwErr(errors.ERR_NO_CONFIG_DIR);\n    } else {\n      filePathVal = tnsAdminVal;\n      filePathVal += '/tnsnames.ora';\n      if (!fs.existsSync(filePathVal)) {\n        errors.throwErr(errors.ERR_TNS_NAMES_FILE_MISSING, tnsAdminVal);\n      }\n    }\n    return filePathVal;\n  }\n}\nclass NLParamParser {\n  constructor() {\n    this.waiters = [];\n    this.readInProgress = false;\n  }\n  /**\n  * Reads the given file line by line and stores the\n  * network service names mapped to connect descriptors in the hashtable.\n  * @param {string} file_path\n  * @returns {Promise}\n  */\n  async initializeNlpa(file_path) {\n    if (this.readInProgress) {\n      await new Promise(resolve => {\n        this.waiters.push(resolve);\n      });\n    }\n    if (!this.checkModfTime()) {\n      /* No File has been modified */\n      return this.ht;\n    }\n    this.ht = new Map();\n    this.modTime = new Map(); //stores modified time of each IFile\n    this.readInProgress = true;\n    await this.start(file_path, 0); //start with 0 depth (tnsnames.ora)\n    return this.ht;\n  }\n  async start(file_path, depth) {\n    if (depth > MAX_IFILE_DEPTH) return; //ignore after max depth\n    const stat = fs.statSync(file_path);\n    // store file path and its modified time.\n    this.modTime.set(file_path, stat.mtime);\n    // Creating a readable stream from file\n    // readline module reads line by line\n    // but from a readable stream only.\n    const file = readline.createInterface({\n      input: fs.createReadStream(file_path),\n      output: process.stdout,\n      terminal: false\n    });\n    let nvElem = \"\";\n    for await (let line of file) {\n      if (line.length == 0) {\n        // ignore empty lines\n        continue;\n      } else if (line[0] == '#') {\n        // comment line\n        continue;\n      } else if (line[0] == ' ' ||\n      // continued input on new line\n      line[0] == '\\t' || line[0] == ')' || line[0] == '(') {\n        line = line.replace(/\\s+/g, '');\n        line = this.checkNLPforComments(line);\n        if (line.length == 0) continue;else {\n          nvElem = nvElem + line;\n        }\n      } else {\n        // new NV Element starting here\n        if (nvElem.length == 0) {\n          line = this.checkNLPforComments(line);\n          nvElem = nvElem + line;\n        } else if (nvElem.length != 0) {\n          await this.addNLPListElement(nvElem, depth); // Add Parameter to Hashtable\n          nvElem = \"\"; // Clear first, before storing current line\n\n          line = this.checkNLPforComments(line);\n          nvElem = nvElem + line;\n        }\n      }\n    }\n    if (nvElem.length != 0) {\n      // at eof, still one more parameter to read\n      await this.addNLPListElement(nvElem, depth);\n      nvElem = \"\"; // clear nvElem buffer after added\n    }\n    this.readInProgress = false;\n    let waiter;\n    while (waiter = this.waiters.pop()) {\n      waiter();\n    }\n  }\n  /**\n   * Given a string, this method looks if the '#' character is present.\n   * If true, the line is truncated from that point onwards until the end\n   * of the line; else, the original line is returned unchanged.\n   *\n   * @param  str     The String that is going to be tested for inline comments\n   * @return String  The modified String returned\n   */\n  checkNLPforComments(str) {\n    const str1 = new Array(str.length);\n    for (let i = 0; i < str.length; i++) {\n      const current_char = str[i];\n      if (current_char == '#') {\n        if (i != 0) {\n          break; // No need to continue. Return the line\n        } else {\n          // Entire line is a comment\n          return \"\";\n        }\n      } else str1.push(current_char);\n    }\n    return str1.join('');\n  }\n  // check if any of the IFiles has been changed\n  checkModfTime() {\n    if (this.modTime) {\n      for (const [key, value] of this.modTime) {\n        if (fs.existsSync(key)) {\n          const stat = fs.statSync(key);\n          if (stat.mtime - value > 0) {\n            return true;\n          }\n        } else return true;\n      }\n    } else {\n      return true;\n    }\n    return false;\n  }\n  /**\n    * adds name value pairs from the input buffer into the hash table.\n    * @param {string} ibuf\n    */\n  async addNLPListElement(ibuf, depth) {\n    const res = ibuf.split(/\\r?\\n/).filter(element => element);\n    for (let i = 0; i < res.length; i++) {\n      if (res[i].charAt(0) != '(') {\n        res[i] = '(' + res[i] + ')';\n      }\n      const nvp = createNVPair(res[i]);\n      const name = nvp.name;\n      const uname = name.toUpperCase();\n      nvp.name = uname;\n      // support for ifile\n      if (uname == 'IFILE') {\n        await this.start(nvp.atom, depth + 1);\n      } else {\n        const unames = uname.split(\",\"); //multiple aliases (alias1, alias2, alias3)\n        for (let i = 0; i < unames.length; i++) {\n          this.ht.set(unames[i], nvp);\n        }\n      }\n    }\n  }\n  toString() {\n    let out = \"\";\n    this.ht.forEach(value => {\n      out = out + value.toString() + \"\\n\";\n    });\n    return out;\n  }\n  /**\n    * if key is address/port then it returns the port value from the\n    * address NVPAIR.\n    * @param {string} key\n    * @returns {string}\n   */\n  findValueOf(key) {\n    const myarr = key.split('/');\n    return findValue(this.ht.get(myarr[0].toUpperCase()), myarr);\n  }\n}\nmodule.exports = {\n  NLParamParser,\n  tnsnamesFilePath\n};","map":{"version":3,"names":["createNVPair","findValue","require","fs","process","readline","errors","MAX_IFILE_DEPTH","tnsnamesFilePath","configDir","filePathVal","tnsAdminVal","env","TNS_ADMIN","existsSync","throwErr","ERR_TNS_NAMES_FILE_MISSING","ERR_NO_CONFIG_DIR","NLParamParser","constructor","waiters","readInProgress","initializeNlpa","file_path","Promise","resolve","push","checkModfTime","ht","Map","modTime","start","depth","stat","statSync","set","mtime","file","createInterface","input","createReadStream","output","stdout","terminal","nvElem","line","length","replace","checkNLPforComments","addNLPListElement","waiter","pop","str","str1","Array","i","current_char","join","key","value","ibuf","res","split","filter","element","charAt","nvp","name","uname","toUpperCase","atom","unames","toString","out","forEach","findValueOf","myarr","get","module","exports"],"sources":["C:/Users/Koliv/Desktop/Software/my-react-app/node_modules/oracledb/lib/thin/sqlnet/paramParser.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst {createNVPair, findValue} = require(\"./nvStrToNvPair.js\");\nconst fs = require('fs');\nconst process = require('process');\nconst readline = require('readline');\nconst errors = require(\"../../errors.js\");\n\nconst MAX_IFILE_DEPTH = 4;\n/**\n * Returns File path of the tnsnames.ora if it exists.\n */\nfunction tnsnamesFilePath(configDir) {\n  let filePathVal = null;\n  const tnsAdminVal = process.env.TNS_ADMIN;\n  if (configDir) {\n    filePathVal = configDir + '/tnsnames.ora';\n    if (fs.existsSync(filePathVal)) {\n      return filePathVal;\n    } else {\n      errors.throwErr(errors.ERR_TNS_NAMES_FILE_MISSING, configDir);\n    }\n  } else {\n    if (!tnsAdminVal) {\n      errors.throwErr(errors.ERR_NO_CONFIG_DIR);\n    } else {\n      filePathVal = tnsAdminVal;\n      filePathVal += '/tnsnames.ora';\n      if (!fs.existsSync(filePathVal)) {\n        errors.throwErr(errors.ERR_TNS_NAMES_FILE_MISSING, tnsAdminVal);\n      }\n    }\n    return filePathVal;\n  }\n}\n\nclass NLParamParser {\n\n  constructor() {\n    this.waiters = [];\n    this.readInProgress = false;\n  }\n  /**\n * Reads the given file line by line and stores the\n * network service names mapped to connect descriptors in the hashtable.\n * @param {string} file_path\n * @returns {Promise}\n */\n  async initializeNlpa(file_path) {\n    if (this.readInProgress) {\n      await new Promise((resolve) => {\n        this.waiters.push(resolve);\n      });\n    }\n    if (!this.checkModfTime()) {\n      /* No File has been modified */\n      return this.ht;\n    }\n    this.ht = new Map();\n    this.modTime = new Map(); //stores modified time of each IFile\n    this.readInProgress = true;\n    await this.start(file_path, 0); //start with 0 depth (tnsnames.ora)\n    return this.ht;\n  }\n\n  async start(file_path, depth) {\n\n    if (depth > MAX_IFILE_DEPTH)\n      return; //ignore after max depth\n    const stat = fs.statSync(file_path);\n    // store file path and its modified time.\n    this.modTime.set(file_path, stat.mtime);\n    // Creating a readable stream from file\n    // readline module reads line by line\n    // but from a readable stream only.\n    const file = readline.createInterface({\n      input: fs.createReadStream(file_path),\n      output: process.stdout,\n      terminal: false\n    });\n    let nvElem = \"\";\n    for await (let line of file) {\n      if (line.length == 0) {   // ignore empty lines\n        continue;\n      } else if (line[0] == '#') {  // comment line\n        continue;\n      } else if ((line[0] == ' ') ||    // continued input on new line\n                  (line[0] == '\\t') ||\n                  (line[0] == ')') ||\n                  (line[0] == '(')) {\n        line = line.replace(/\\s+/g, '');\n        line = this.checkNLPforComments(line);\n        if (line.length == 0)\n          continue;\n        else {\n          nvElem = nvElem + line;\n        }\n\n      } else {  // new NV Element starting here\n        if (nvElem.length == 0) {\n\n          line = this.checkNLPforComments(line);\n          nvElem = nvElem + line;\n\n        } else if (nvElem.length != 0) {\n          await this.addNLPListElement(nvElem, depth); // Add Parameter to Hashtable\n          nvElem = \"\"; // Clear first, before storing current line\n\n          line = this.checkNLPforComments(line);\n          nvElem = nvElem + line;\n        }\n      }\n    }\n    if (nvElem.length != 0) { // at eof, still one more parameter to read\n      await this.addNLPListElement(nvElem, depth);\n      nvElem = \"\";      // clear nvElem buffer after added\n    }\n    this.readInProgress = false;\n    let waiter;\n    while ((waiter = this.waiters.pop())) {\n      waiter();\n    }\n  }\n  /**\n   * Given a string, this method looks if the '#' character is present.\n   * If true, the line is truncated from that point onwards until the end\n   * of the line; else, the original line is returned unchanged.\n   *\n   * @param  str     The String that is going to be tested for inline comments\n   * @return String  The modified String returned\n   */\n  checkNLPforComments(str) {\n    const str1 = new Array(str.length);\n\n    for (let i = 0; i < str.length; i++) {\n      const current_char = str[i];\n      if (current_char == '#') {\n        if (i != 0) {\n          break; // No need to continue. Return the line\n        } else {\n          // Entire line is a comment\n          return \"\";\n        }\n      } else\n        str1.push(current_char);\n    }\n    return str1.join('');\n  }\n  // check if any of the IFiles has been changed\n  checkModfTime() {\n    if (this.modTime) {\n      for (const [key, value] of this.modTime) {\n        if (fs.existsSync(key)) {\n          const stat = fs.statSync(key);\n          if ((stat.mtime - value > 0)) {\n            return true;\n          }\n        } else\n          return true;\n      }\n    } else {\n      return true;\n    }\n    return false;\n  }\n  /**\n    * adds name value pairs from the input buffer into the hash table.\n    * @param {string} ibuf\n    */\n  async addNLPListElement(ibuf, depth) {\n    const res = ibuf.split(/\\r?\\n/).filter(element => element);\n    for (let i = 0; i < res.length; i++) {\n      if (res[i].charAt(0) != '(') {\n        res[i] = '(' + res[i] + ')';\n      }\n      const nvp = createNVPair(res[i]);\n      const name = nvp.name;\n      const uname = name.toUpperCase();\n      nvp.name = uname;\n      // support for ifile\n      if (uname == 'IFILE') {\n        await this.start(nvp.atom, depth + 1);\n      } else {\n        const unames = uname.split(\",\"); //multiple aliases (alias1, alias2, alias3)\n        for (let i = 0; i < unames.length; i++) {\n          this.ht.set(unames[i], nvp);\n        }\n      }\n    }\n  }\n  toString() {\n    let out = \"\";\n    this.ht.forEach((value) => {\n      out = out + value.toString() + \"\\n\";\n    });\n    return out;\n  }\n  /**\n    * if key is address/port then it returns the port value from the\n    * address NVPAIR.\n    * @param {string} key\n    * @returns {string}\n   */\n  findValueOf(key) {\n    const myarr = key.split('/');\n    return (findValue(this.ht.get(myarr[0].toUpperCase()), myarr));\n  }\n\n}\n\nmodule.exports = {\n  NLParamParser,\n  tnsnamesFilePath\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}