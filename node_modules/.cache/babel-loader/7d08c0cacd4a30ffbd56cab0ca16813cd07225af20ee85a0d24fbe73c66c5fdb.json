{"ast":null,"code":"// Copyright (c) 2022, 2024, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\nconst constants = require('../constants');\nconst errors = require('../errors');\nconst protoConstants = require('./protocol/constants');\n\n/**\n * It is used to cache the metadata about bind information\n * associated with the statement. This will determine if statement needs\n * to use Execute or Re-Execute.\n */\nclass BindInfo {\n  constructor(name, isReturnBind = false) {\n    this.bindName = name;\n    this.isReturnBind = isReturnBind;\n    this.maxSize = 0;\n    this.numElements = 0;\n    this.maxArraySize = 0;\n    this.type = null;\n    this.isArray = false;\n    this.dir = constants.BIND_IN;\n    this.bindVar = null;\n  }\n}\n\n/**\n * Encapsulates the SQL statement run on the connection.\n * It has information like type of stmt, bind infrmation, cursor number, ...\n */\nmodule.exports.BindInfo = BindInfo;\nclass Parser {\n  constructor() {\n    this.returningKeywordFound = false;\n    this.pos = 0;\n    this.maxPos = 0;\n    this.sqlData = \"\";\n  }\n\n  /**\n   * Bind variables are identified as follows:\n   *  - Quoted and non-quoted bind names are allowed.\n   *  - Quoted bind names can contain any characters.\n   *  - Non-quoted bind names must begin with an alphabetic character.\n   *  - Non-quoted bind names can only contain alphanumeric characters, the\n   *    underscore, the dollar sign and the pound sign.\n   *  - Non-quoted bind names cannot be Oracle Database Reserved Names (this\n   *    is left to the server to detect and return an appropriate error).\n   */\n  _parseBindName(stmt) {\n    let quotedName = false;\n    let inBind = false;\n    let digitsOnly = false;\n    let startPos = 0;\n    let pos = this.pos + 1;\n    let bindName;\n    let ch;\n    while (pos <= this.maxPos) {\n      ch = this.sqlData[pos];\n      if (!inBind) {\n        if (/\\p{space}/u.test(ch)) {\n          pos += 1;\n          continue;\n        } else if (ch === '\"') {\n          quotedName = true;\n        } else if (/\\p{N}/u.test(ch)) {\n          digitsOnly = true;\n        } else if (!/\\p{Alpha}/u.test(ch)) {\n          break;\n        }\n        inBind = true;\n        startPos = pos;\n      } else if (digitsOnly && !/\\p{N}/u.test(ch)) {\n        this.pos = pos - 1;\n        break;\n      } else if (quotedName && ch === '\"') {\n        this.pos = pos;\n        break;\n      } else if (!digitsOnly && !quotedName && !/[\\p{L}\\p{N}]/u.test(ch) && !['$', '_', '#'].includes(ch)) {\n        this.pos = pos - 1;\n        break;\n      }\n      pos += 1;\n    }\n    if (inBind) {\n      if (quotedName) {\n        bindName = stmt.sql.substring(startPos + 1, pos);\n      } else if (digitsOnly) {\n        bindName = stmt.sql.substring(startPos, pos);\n      } else {\n        bindName = stmt.sql.substring(startPos, pos).toUpperCase();\n      }\n      stmt._addBind(bindName);\n    }\n  }\n\n  /**\n   * Multiple line comments consist of the characters /* followed by all\n   * characters up until * followed by /. This method is called when the first\n   * slash is detected and checks for the subsequent asterisk. If found,\n   * the comment is traversed and the current position is updated; otherwise,\n   * the current position is left untouched.\n   */\n  _parseMultiLineComment() {\n    let inComment = false;\n    let exitingComment = false;\n    let pos = this.pos + 1;\n    let ch;\n    while (pos <= this.maxPos) {\n      ch = this.sqlData[pos];\n      if (!inComment) {\n        if (ch !== '*') {\n          break;\n        }\n        inComment = true;\n      } else if (ch === '*') {\n        exitingComment = true;\n      } else if (exitingComment) {\n        if (ch === '/') {\n          this.pos = pos;\n          break;\n        }\n        exitingComment = false;\n      }\n      pos += 1;\n    }\n  }\n\n  /** Parses a q-string which consists of the characters \"q\" and a single\n   * quote followed by a start separator, any text that does not contain the\n   * end seprator and the end separator and ending quote. The following are\n   * examples that demonstrate this:\n   *   - q'[...]'\n   *   - q'{...}'\n   *   - q'<...>'\n   *   - q'(...)'\n   *   - q'?...?' (where ? is any character)\n   */\n  _parseQstring() {\n    let exitingQstring = false;\n    let inQstring = false;\n    let sep;\n    let ch;\n    this.pos += 1;\n    while (this.pos <= this.maxPos) {\n      ch = this.sqlData[this.pos];\n      if (!inQstring) {\n        if (ch === '[') {\n          sep = ']';\n        } else if (ch === '{') {\n          sep = '}';\n        } else if (ch === '(') {\n          sep = ')';\n        } else if (ch === '<') {\n          sep = '>';\n        } else {\n          sep = ch;\n        }\n        inQstring = true;\n      } else if (!exitingQstring && ch === sep) {\n        exitingQstring = true;\n      } else if (exitingQstring) {\n        if (ch === \"'\") {\n          break;\n        } else if (ch !== sep) {\n          exitingQstring = false;\n        }\n      }\n      this.pos += 1;\n    }\n  }\n\n  /**\n   * Parses a quoted string with the given separator. All characters until\n   * the separate is detected are discarded.\n   */\n  _parseQuotedString(sep) {\n    let ch;\n    this.pos += 1;\n    while (this.pos <= this.maxPos) {\n      ch = this.sqlData[this.pos];\n      if (ch === sep) {\n        break;\n      }\n      this.pos += 1;\n    }\n  }\n\n  /**\n   * Single line comments consist of two dashes and all characters up to the\n   * next line break (or the end of the data). This method is called when\n   * the first dash is detected and checks for the subsequent dash. If found,\n   * the single line comment is traversed and the current position is updated;\n   * otherwise, the current position is left untouched.\n   */\n  _parseSingleLineComment() {\n    let inComment = false;\n    let pos = this.pos + 1;\n    let ch;\n    while (pos <= this.maxPos) {\n      ch = this.sqlData[pos];\n      if (!inComment) {\n        if (ch !== '-') {\n          return;\n        }\n        inComment = true;\n      } else if (ch === '\\n') {\n        break;\n      }\n      pos += 1;\n    }\n    this.pos = pos;\n  }\n\n  /**\n   * Parses the SQL stored in the statement in order to determine the\n   * keyword that identifies the type of SQL being executed as well as a\n   * list of bind variable names. A check is also made for DML returning\n   * statements since the bind variables following the \"INTO\" keyword are\n   * treated differently from other bind variables.\n   */\n  parse(stmt) {\n    let initialKeywordFound = false;\n    let lastWasString = false;\n    let ch,\n      lastCh = '',\n      alphaStartCh = '';\n    let alphaStartPos = 0,\n      alphaLen;\n    let isAlpha,\n      lastWasAlpha = false;\n    let keyword;\n\n    // initialization\n    this.pos = 0;\n    this.maxPos = stmt.sql.length - 1;\n    this.sqlData = stmt.sql;\n\n    // scan all the characters in the string\n    while (this.pos <= this.maxPos) {\n      ch = this.sqlData[this.pos];\n      // look for certain keywords (initial keyword and the ones for\n      // detecting DML returning statements\n      isAlpha = /\\p{L}/u.test(ch);\n      if (isAlpha && !lastWasAlpha) {\n        alphaStartPos = this.pos;\n        alphaStartCh = ch;\n      } else if (!isAlpha && lastWasAlpha) {\n        alphaLen = this.pos - alphaStartPos;\n        if (!initialKeywordFound) {\n          keyword = stmt.sql.substring(alphaStartPos, this.pos).toUpperCase();\n          stmt._determineStatementType(keyword);\n          initialKeywordFound = true;\n          if (stmt.isDdl) {\n            break;\n          }\n        } else if (stmt.isDml && !this.returningKeywordFound && (alphaLen === 9 || alphaLen === 6) && ['r', 'R'].includes(alphaStartCh)) {\n          keyword = stmt.sql.substring(alphaStartPos, this.pos).toUpperCase();\n          if (['RETURNING', 'RETURN'].includes(keyword)) {\n            this.returningKeywordFound = true;\n          }\n        } else if (this.returningKeywordFound && alphaLen === 4 && ['i', 'I'].includes(alphaStartCh)) {\n          keyword = stmt.sql.substring(alphaStartPos, this.pos).toUpperCase();\n          if (keyword === 'INTO') {\n            stmt.isReturning = true;\n          }\n        }\n      }\n\n      // need to keep track of whether the last token parsed was a string\n      // (excluding whitespace) as if the last token parsed was a string\n      // a following colon is not a bind variable but a part of the JSON\n      // constant syntax\n      if (ch === \"'\") {\n        lastWasString = true;\n        if (['q', 'Q'].includes(lastCh)) {\n          this._parseQstring();\n        } else {\n          this._parseQuotedString(ch);\n        }\n      } else if (!/\\p{space}/u.test(ch)) {\n        if (ch === '-') {\n          this._parseSingleLineComment();\n        } else if (ch === '/') {\n          this._parseMultiLineComment();\n        } else if (ch === '\"') {\n          this._parseQuotedString(ch);\n        } else if (ch === ':' && !lastWasString) {\n          this._parseBindName(stmt);\n        }\n        lastWasString = false;\n      }\n      this.pos += 1;\n      lastWasAlpha = isAlpha;\n      lastCh = ch;\n    }\n\n    // if only a single word is found in sql, e.g. in case of commit/rollback\n    if (!initialKeywordFound) {\n      stmt._determineStatementType(stmt.sql.toUpperCase());\n    }\n  }\n}\nclass Statement {\n  constructor() {\n    this.sql = \"\";\n    this.sqlBytes = [];\n    this.sqlLength = 0;\n    this.cursorId = 0;\n    this.requiresDefine = false;\n    this.isQuery = false;\n    this.isPlSql = false;\n    this.isDml = false;\n    this.isDdl = false;\n    this.isReturning = false;\n    this.bindInfoList = [];\n    this.queryVars = [];\n    this.bindInfoDict = new Map();\n    this.requiresFullExecute = false;\n    this.noPrefetch = false;\n    this.returnToCache = false;\n    this.numColumns = 0;\n    this.lastRowIndex;\n    this.lastRowid;\n    this.moreRowsToFetch = true;\n    this.inUse = false;\n    this.bufferRowIndex = 0;\n    this.bufferRowCount = 0;\n    this.pendingClear = false;\n    this.statementType = constants.STMT_TYPE_UNKNOWN;\n  }\n\n  //---------------------------------------------------------------------------\n  // _copy()\n  //\n  // Copying existing statement into new statement object required by drcp\n  //---------------------------------------------------------------------------\n  _copy() {\n    const copiedStatement = new Statement();\n    copiedStatement.sql = this.sql;\n    copiedStatement.sqlBytes = this.sqlBytes;\n    copiedStatement.sqlLength = this.sqlLength;\n    copiedStatement.isQuery = this.isQuery;\n    copiedStatement.isPlSql = this.isPlSql;\n    copiedStatement.isDml = this.isDml;\n    copiedStatement.isDdl = this.isDdl;\n    copiedStatement.isReturning = this.isReturning;\n    copiedStatement.bindInfoList = [];\n    for (const bindInfo of this.bindInfoList) {\n      const newBindInfo = new BindInfo(bindInfo.bindName, bindInfo.isReturnBind);\n      copiedStatement.bindInfoList.push(newBindInfo);\n    }\n    const bindInfoDict = copiedStatement.bindInfoDict = new Map();\n    for (const bindInfo of copiedStatement.bindInfoList) {\n      if (bindInfoDict.has(bindInfo.bindName)) {\n        bindInfoDict.get(bindInfo.bindName).push(bindInfo);\n      } else {\n        bindInfoDict.set(bindInfo.bindName, [bindInfo]);\n      }\n    }\n    copiedStatement.returnToCache = false;\n    return copiedStatement;\n  }\n\n  //---------------------------------------------------------------------------\n  // _determineStatementType(sql)\n  //\n  // Determine the type of the SQL statement by examining the first keyword\n  // found in the statement\n  //---------------------------------------------------------------------------\n  _determineStatementType(sqlKeyword) {\n    switch (sqlKeyword) {\n      case 'DECLARE':\n        this.isPlSql = true;\n        this.statementType = constants.STMT_TYPE_DECLARE;\n        break;\n      case 'CALL':\n        this.isPlSql = true;\n        this.statementType = constants.STMT_TYPE_CALL;\n        break;\n      case 'BEGIN':\n        this.isPlSql = true;\n        this.statementType = constants.STMT_TYPE_BEGIN;\n        break;\n      case 'SELECT':\n        this.isQuery = true;\n        this.statementType = constants.STMT_TYPE_SELECT;\n        break;\n      case 'WITH':\n        this.isQuery = true;\n        break;\n      case 'INSERT':\n        this.isDml = true;\n        this.statementType = constants.STMT_TYPE_INSERT;\n        break;\n      case 'UPDATE':\n        this.isDml = true;\n        this.statementType = constants.STMT_TYPE_UPDATE;\n        break;\n      case 'DELETE':\n        this.isDml = true;\n        this.statementType = constants.STMT_TYPE_DELETE;\n        break;\n      case 'MERGE':\n        this.isDml = true;\n        this.statementType = constants.STMT_TYPE_MERGE;\n        break;\n      case 'ALTER':\n        this.isDdl = true;\n        this.statementType = constants.STMT_TYPE_ALTER;\n        break;\n      case 'CREATE':\n        this.isDdl = true;\n        this.statementType = constants.STMT_TYPE_CREATE;\n        break;\n      case 'DROP':\n        this.isDdl = true;\n        this.statementType = constants.STMT_TYPE_DROP;\n        break;\n      case 'ANALYZE':\n      case 'AUDIT':\n      case 'COMMENT':\n      case 'GRANT':\n      case 'REVOKE':\n      case 'TRUNCATE':\n        this.isDdl = true;\n        break;\n      case 'COMMIT':\n        this.statementType = constants.STMT_TYPE_COMMIT;\n        break;\n      case 'ROLLBACK':\n        this.statementType = constants.STMT_TYPE_ROLLBACK;\n        break;\n      default:\n        this.statementType = constants.STMT_TYPE_UNKNOWN;\n        break;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // prepare(sql)\n  //\n  // Prepare the SQL for execution by determining the list of bind names\n  // that are found within it. The length of the SQL text is also calculated\n  // at this time.\n  //---------------------------------------------------------------------------\n  _prepare(sql) {\n    this.sql = sql;\n    this.sqlBytes = Buffer.from(this.sql, 'utf8');\n    this.sqlLength = this.sqlBytes.length;\n    const parser = new Parser();\n    parser.parse(this);\n  }\n\n  //---------------------------------------------------------------------------\n  // _addBinds(sql)\n  //\n  // Add bind information to the statement by examining the passed SQL for\n  // bind variable names.\n  //---------------------------------------------------------------------------\n  _addBind(name) {\n    if (!this.isPlSql || !this.bindInfoDict.has(name)) {\n      const info = new BindInfo(name, this.isReturning);\n      this.bindInfoList.push(info);\n      if (this.bindInfoDict.has(info.bindName)) {\n        if (this.isReturning) {\n          const origInfo = this.bindInfoDict.get(info.bindName)[0];\n          if (!origInfo.isReturnBind) {\n            errors.throwErr(errors.ERR_DML_RETURNING_DUP_BINDS, name);\n          }\n        }\n        this.bindInfoDict.get(info.bindName).push(info);\n      } else {\n        this.bindInfoDict.set(info.bindName, [info]);\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _setVariable(sql)\n  //\n  // Set the variable on the bind information and copy across metadata that\n  // will be used for binding. If the bind metadata has changed, mark the\n  // statement as requiring a full execute. In addition, binding a REF\n  // cursor also requires a full execute.\n  //---------------------------------------------------------------------------\n  _setVariable(bindInfo, variable) {\n    if (variable.type._oraTypeNum === protoConstants.TNS_DATA_TYPE_CURSOR) {\n      this.requiresFullExecute = true;\n    }\n    if (variable.maxSize !== bindInfo.maxSize || variable.dir !== bindInfo.dir || variable.isArray !== bindInfo.isArray || variable.values.length > bindInfo.numElements || variable.type != bindInfo.type || variable.maxArraySize != bindInfo.maxArraySize) {\n      bindInfo.isArray = variable.isArray;\n      bindInfo.numElements = variable.values.length;\n      bindInfo.maxSize = variable.maxSize;\n      bindInfo.type = variable.type;\n      bindInfo.dir = variable.dir;\n      bindInfo.maxArraySize = variable.maxArraySize;\n      this.requiresFullExecute = true;\n    }\n    bindInfo.bindVar = variable;\n  }\n\n  //---------------------------------------------------------------------------\n  // _clearAllState\n  //\n  // clear all state associated with the cursor\n  //---------------------------------------------------------------------------\n  _clearAllState() {\n    this.cursorId = 0;\n    this.requiresDefine = false;\n    this.noPrefetch = false;\n    this.requiresFullExecute = false;\n    this.queryVars = [];\n    this.numQueryVars = 0;\n    this.bufferRowCount = 0;\n    this.bufferRowIndex = 0;\n  }\n\n  //---------------------------------------------------------------------------\n  // _clearState\n  //\n  // clear some state associated with the cursor\n  //---------------------------------------------------------------------------\n  _clearState() {\n    this.cursorId = 0;\n    this.requiresDefine = false;\n    this.noPrefetch = false;\n    this.requiresFullExecute = false;\n  }\n}\nmodule.exports.Statement = Statement;","map":{"version":3,"names":["Buffer","require","constants","errors","protoConstants","BindInfo","constructor","name","isReturnBind","bindName","maxSize","numElements","maxArraySize","type","isArray","dir","BIND_IN","bindVar","module","exports","Parser","returningKeywordFound","pos","maxPos","sqlData","_parseBindName","stmt","quotedName","inBind","digitsOnly","startPos","ch","test","includes","sql","substring","toUpperCase","_addBind","_parseMultiLineComment","inComment","exitingComment","_parseQstring","exitingQstring","inQstring","sep","_parseQuotedString","_parseSingleLineComment","parse","initialKeywordFound","lastWasString","lastCh","alphaStartCh","alphaStartPos","alphaLen","isAlpha","lastWasAlpha","keyword","length","_determineStatementType","isDdl","isDml","isReturning","Statement","sqlBytes","sqlLength","cursorId","requiresDefine","isQuery","isPlSql","bindInfoList","queryVars","bindInfoDict","Map","requiresFullExecute","noPrefetch","returnToCache","numColumns","lastRowIndex","lastRowid","moreRowsToFetch","inUse","bufferRowIndex","bufferRowCount","pendingClear","statementType","STMT_TYPE_UNKNOWN","_copy","copiedStatement","bindInfo","newBindInfo","push","has","get","set","sqlKeyword","STMT_TYPE_DECLARE","STMT_TYPE_CALL","STMT_TYPE_BEGIN","STMT_TYPE_SELECT","STMT_TYPE_INSERT","STMT_TYPE_UPDATE","STMT_TYPE_DELETE","STMT_TYPE_MERGE","STMT_TYPE_ALTER","STMT_TYPE_CREATE","STMT_TYPE_DROP","STMT_TYPE_COMMIT","STMT_TYPE_ROLLBACK","_prepare","from","parser","info","origInfo","throwErr","ERR_DML_RETURNING_DUP_BINDS","_setVariable","variable","_oraTypeNum","TNS_DATA_TYPE_CURSOR","values","_clearAllState","numQueryVars","_clearState"],"sources":["C:/Users/Koliv/Desktop/Software/my-react-app/node_modules/oracledb/lib/thin/statement.js"],"sourcesContent":["// Copyright (c) 2022, 2024, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst { Buffer } = require('buffer');\nconst constants = require('../constants');\nconst errors = require('../errors');\nconst protoConstants = require('./protocol/constants');\n\n/**\n * It is used to cache the metadata about bind information\n * associated with the statement. This will determine if statement needs\n * to use Execute or Re-Execute.\n */\nclass BindInfo {\n  constructor(name, isReturnBind = false) {\n    this.bindName = name;\n    this.isReturnBind = isReturnBind;\n    this.maxSize = 0;\n    this.numElements = 0;\n    this.maxArraySize = 0;\n    this.type = null;\n    this.isArray = false;\n    this.dir = constants.BIND_IN;\n    this.bindVar = null;\n  }\n}\n\n/**\n * Encapsulates the SQL statement run on the connection.\n * It has information like type of stmt, bind infrmation, cursor number, ...\n */\nmodule.exports.BindInfo = BindInfo;\n\nclass Parser {\n  constructor() {\n    this.returningKeywordFound = false;\n    this.pos = 0;\n    this.maxPos = 0;\n    this.sqlData = \"\";\n  }\n\n  /**\n   * Bind variables are identified as follows:\n   *  - Quoted and non-quoted bind names are allowed.\n   *  - Quoted bind names can contain any characters.\n   *  - Non-quoted bind names must begin with an alphabetic character.\n   *  - Non-quoted bind names can only contain alphanumeric characters, the\n   *    underscore, the dollar sign and the pound sign.\n   *  - Non-quoted bind names cannot be Oracle Database Reserved Names (this\n   *    is left to the server to detect and return an appropriate error).\n   */\n  _parseBindName(stmt) {\n    let quotedName = false;\n    let inBind = false;\n    let digitsOnly = false;\n    let startPos = 0;\n    let pos = this.pos + 1;\n    let bindName;\n    let ch;\n\n    while (pos <= this.maxPos) {\n      ch = this.sqlData[pos];\n      if (!inBind) {\n        if (/\\p{space}/u.test(ch)) {\n          pos += 1;\n          continue;\n        } else if (ch === '\"') {\n          quotedName = true;\n        } else if (/\\p{N}/u.test(ch)) {\n          digitsOnly = true;\n        } else if (!/\\p{Alpha}/u.test(ch)) {\n          break;\n        }\n        inBind = true;\n        startPos = pos;\n      } else if (digitsOnly && !(/\\p{N}/u.test(ch))) {\n        this.pos = pos - 1;\n        break;\n      } else if (quotedName && ch === '\"') {\n        this.pos = pos;\n        break;\n      } else if (!digitsOnly && !quotedName\n          && !(/[\\p{L}\\p{N}]/u.test(ch))\n          && !['$', '_', '#'].includes(ch)) {\n        this.pos = pos - 1;\n        break;\n      }\n      pos += 1;\n    }\n\n    if (inBind) {\n      if (quotedName) {\n        bindName = stmt.sql.substring(startPos + 1, pos);\n      } else if (digitsOnly) {\n        bindName = stmt.sql.substring(startPos, pos);\n      } else {\n        bindName = stmt.sql.substring(startPos, pos).toUpperCase();\n      }\n      stmt._addBind(bindName);\n    }\n  }\n\n  /**\n   * Multiple line comments consist of the characters /* followed by all\n   * characters up until * followed by /. This method is called when the first\n   * slash is detected and checks for the subsequent asterisk. If found,\n   * the comment is traversed and the current position is updated; otherwise,\n   * the current position is left untouched.\n   */\n  _parseMultiLineComment() {\n    let inComment = false;\n    let exitingComment = false;\n    let pos = this.pos + 1;\n    let ch;\n    while (pos <= this.maxPos) {\n      ch = this.sqlData[pos];\n      if (!inComment) {\n        if (ch !== '*') {\n          break;\n        }\n        inComment = true;\n      } else if (ch === '*') {\n        exitingComment = true;\n      } else if (exitingComment) {\n        if (ch === '/') {\n          this.pos = pos;\n          break;\n        }\n        exitingComment = false;\n      }\n      pos += 1;\n    }\n  }\n\n  /** Parses a q-string which consists of the characters \"q\" and a single\n   * quote followed by a start separator, any text that does not contain the\n   * end seprator and the end separator and ending quote. The following are\n   * examples that demonstrate this:\n   *   - q'[...]'\n   *   - q'{...}'\n   *   - q'<...>'\n   *   - q'(...)'\n   *   - q'?...?' (where ? is any character)\n   */\n  _parseQstring() {\n    let exitingQstring = false;\n    let inQstring = false;\n    let sep;\n    let ch;\n\n    this.pos += 1;\n\n    while (this.pos <= this.maxPos) {\n      ch = this.sqlData[this.pos];\n      if (!inQstring) {\n        if (ch === '[') {\n          sep = ']';\n        } else if (ch === '{') {\n          sep = '}';\n        } else if (ch === '(') {\n          sep = ')';\n        } else if (ch === '<') {\n          sep = '>';\n        } else {\n          sep = ch;\n        }\n        inQstring = true;\n      } else if (!exitingQstring && ch === sep) {\n        exitingQstring = true;\n      } else if (exitingQstring) {\n        if (ch === \"'\") {\n          break;\n        } else if (ch !== sep) {\n          exitingQstring = false;\n        }\n      }\n      this.pos += 1;\n    }\n  }\n\n  /**\n   * Parses a quoted string with the given separator. All characters until\n   * the separate is detected are discarded.\n   */\n  _parseQuotedString(sep) {\n    let ch;\n    this.pos += 1;\n    while (this.pos <= this.maxPos) {\n      ch = this.sqlData[this.pos];\n      if (ch === sep) {\n        break;\n      }\n      this.pos += 1;\n    }\n  }\n\n  /**\n   * Single line comments consist of two dashes and all characters up to the\n   * next line break (or the end of the data). This method is called when\n   * the first dash is detected and checks for the subsequent dash. If found,\n   * the single line comment is traversed and the current position is updated;\n   * otherwise, the current position is left untouched.\n   */\n  _parseSingleLineComment() {\n    let inComment = false;\n    let pos = this.pos + 1;\n    let ch;\n\n    while (pos <= this.maxPos) {\n      ch = this.sqlData[pos];\n      if (!inComment) {\n        if (ch !== '-') {\n          return;\n        }\n        inComment = true;\n      } else if (ch === '\\n') {\n        break;\n      }\n      pos += 1;\n    }\n    this.pos = pos;\n  }\n\n  /**\n   * Parses the SQL stored in the statement in order to determine the\n   * keyword that identifies the type of SQL being executed as well as a\n   * list of bind variable names. A check is also made for DML returning\n   * statements since the bind variables following the \"INTO\" keyword are\n   * treated differently from other bind variables.\n   */\n  parse(stmt) {\n    let initialKeywordFound = false;\n    let lastWasString = false;\n    let ch, lastCh = '', alphaStartCh = '';\n    let alphaStartPos = 0, alphaLen;\n    let isAlpha, lastWasAlpha = false;\n    let keyword;\n\n    // initialization\n    this.pos = 0;\n    this.maxPos = stmt.sql.length - 1;\n    this.sqlData = stmt.sql;\n\n    // scan all the characters in the string\n    while (this.pos <= this.maxPos) {\n      ch = this.sqlData[this.pos];\n      // look for certain keywords (initial keyword and the ones for\n      // detecting DML returning statements\n      isAlpha = /\\p{L}/u.test(ch);\n      if (isAlpha && !lastWasAlpha) {\n        alphaStartPos = this.pos;\n        alphaStartCh = ch;\n      } else if (!isAlpha && lastWasAlpha) {\n        alphaLen = this.pos - alphaStartPos;\n        if (!initialKeywordFound) {\n          keyword = stmt.sql.substring(alphaStartPos, this.pos).toUpperCase();\n          stmt._determineStatementType(keyword);\n          initialKeywordFound = true;\n          if (stmt.isDdl) {\n            break;\n          }\n        } else if (stmt.isDml && !this.returningKeywordFound\n            && (alphaLen === 9 || alphaLen === 6)\n            && ['r', 'R'].includes(alphaStartCh)) {\n          keyword = stmt.sql.substring(alphaStartPos, this.pos).toUpperCase();\n          if (['RETURNING', 'RETURN'].includes(keyword)) {\n            this.returningKeywordFound = true;\n          }\n        } else if (this.returningKeywordFound && alphaLen === 4\n            && ['i', 'I'].includes(alphaStartCh)) {\n          keyword = stmt.sql.substring(alphaStartPos, this.pos).toUpperCase();\n          if (keyword === 'INTO') {\n            stmt.isReturning = true;\n          }\n        }\n      }\n\n      // need to keep track of whether the last token parsed was a string\n      // (excluding whitespace) as if the last token parsed was a string\n      // a following colon is not a bind variable but a part of the JSON\n      // constant syntax\n      if (ch === \"'\") {\n        lastWasString = true;\n        if (['q', 'Q'].includes(lastCh)) {\n          this._parseQstring();\n        } else {\n          this._parseQuotedString(ch);\n        }\n      } else if (!(/\\p{space}/u.test(ch))) {\n        if (ch === '-') {\n          this._parseSingleLineComment();\n        } else if (ch === '/') {\n          this._parseMultiLineComment();\n        } else if (ch === '\"') {\n          this._parseQuotedString(ch);\n        } else if (ch === ':' && !lastWasString) {\n          this._parseBindName(stmt);\n        }\n        lastWasString = false;\n      }\n\n      this.pos += 1;\n      lastWasAlpha = isAlpha;\n      lastCh = ch;\n    }\n\n    // if only a single word is found in sql, e.g. in case of commit/rollback\n    if (!initialKeywordFound) {\n      stmt._determineStatementType(stmt.sql.toUpperCase());\n    }\n  }\n}\n\nclass Statement {\n  constructor() {\n    this.sql = \"\";\n    this.sqlBytes = [];\n    this.sqlLength = 0;\n    this.cursorId = 0;\n    this.requiresDefine = false;\n    this.isQuery = false;\n    this.isPlSql = false;\n    this.isDml = false;\n    this.isDdl = false;\n    this.isReturning = false;\n    this.bindInfoList = [];\n    this.queryVars = [];\n    this.bindInfoDict = new Map();\n    this.requiresFullExecute = false;\n    this.noPrefetch = false;\n    this.returnToCache = false;\n    this.numColumns = 0;\n    this.lastRowIndex;\n    this.lastRowid;\n    this.moreRowsToFetch = true;\n    this.inUse = false;\n    this.bufferRowIndex = 0;\n    this.bufferRowCount = 0;\n    this.pendingClear = false;\n    this.statementType = constants.STMT_TYPE_UNKNOWN;\n  }\n\n  //---------------------------------------------------------------------------\n  // _copy()\n  //\n  // Copying existing statement into new statement object required by drcp\n  //---------------------------------------------------------------------------\n  _copy() {\n    const copiedStatement = new Statement();\n    copiedStatement.sql = this.sql;\n    copiedStatement.sqlBytes = this.sqlBytes;\n    copiedStatement.sqlLength = this.sqlLength;\n    copiedStatement.isQuery = this.isQuery;\n    copiedStatement.isPlSql = this.isPlSql;\n    copiedStatement.isDml = this.isDml;\n    copiedStatement.isDdl = this.isDdl;\n    copiedStatement.isReturning = this.isReturning;\n    copiedStatement.bindInfoList = [];\n    for (const bindInfo of this.bindInfoList) {\n      const newBindInfo = new BindInfo(bindInfo.bindName, bindInfo.isReturnBind);\n      copiedStatement.bindInfoList.push(newBindInfo);\n    }\n    const bindInfoDict = copiedStatement.bindInfoDict = new Map();\n    for (const bindInfo of copiedStatement.bindInfoList) {\n      if (bindInfoDict.has(bindInfo.bindName)) {\n        bindInfoDict.get(bindInfo.bindName).push(bindInfo);\n      } else {\n        bindInfoDict.set(bindInfo.bindName, [bindInfo]);\n      }\n    }\n    copiedStatement.returnToCache = false;\n    return copiedStatement;\n  }\n\n  //---------------------------------------------------------------------------\n  // _determineStatementType(sql)\n  //\n  // Determine the type of the SQL statement by examining the first keyword\n  // found in the statement\n  //---------------------------------------------------------------------------\n  _determineStatementType(sqlKeyword) {\n    switch (sqlKeyword) {\n      case 'DECLARE':\n        this.isPlSql = true;\n        this.statementType = constants.STMT_TYPE_DECLARE;\n        break;\n      case 'CALL':\n        this.isPlSql = true;\n        this.statementType = constants.STMT_TYPE_CALL;\n        break;\n      case 'BEGIN':\n        this.isPlSql = true;\n        this.statementType = constants.STMT_TYPE_BEGIN;\n        break;\n      case 'SELECT':\n        this.isQuery = true;\n        this.statementType = constants.STMT_TYPE_SELECT;\n        break;\n      case 'WITH':\n        this.isQuery = true;\n        break;\n      case 'INSERT':\n        this.isDml = true;\n        this.statementType = constants.STMT_TYPE_INSERT;\n        break;\n      case 'UPDATE':\n        this.isDml = true;\n        this.statementType = constants.STMT_TYPE_UPDATE;\n        break;\n      case 'DELETE':\n        this.isDml = true;\n        this.statementType = constants.STMT_TYPE_DELETE;\n        break;\n      case 'MERGE':\n        this.isDml = true;\n        this.statementType = constants.STMT_TYPE_MERGE;\n        break;\n      case 'ALTER':\n        this.isDdl = true;\n        this.statementType = constants.STMT_TYPE_ALTER;\n        break;\n      case 'CREATE':\n        this.isDdl = true;\n        this.statementType = constants.STMT_TYPE_CREATE;\n        break;\n      case 'DROP':\n        this.isDdl = true;\n        this.statementType = constants.STMT_TYPE_DROP;\n        break;\n      case 'ANALYZE':\n      case 'AUDIT':\n      case 'COMMENT':\n      case 'GRANT':\n      case 'REVOKE':\n      case 'TRUNCATE':\n        this.isDdl = true;\n        break;\n      case 'COMMIT':\n        this.statementType = constants.STMT_TYPE_COMMIT;\n        break;\n      case 'ROLLBACK':\n        this.statementType = constants.STMT_TYPE_ROLLBACK;\n        break;\n      default:\n        this.statementType = constants.STMT_TYPE_UNKNOWN;\n        break;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // prepare(sql)\n  //\n  // Prepare the SQL for execution by determining the list of bind names\n  // that are found within it. The length of the SQL text is also calculated\n  // at this time.\n  //---------------------------------------------------------------------------\n  _prepare(sql) {\n    this.sql = sql;\n    this.sqlBytes = Buffer.from(this.sql, 'utf8');\n    this.sqlLength = this.sqlBytes.length;\n    const parser = new Parser();\n    parser.parse(this);\n  }\n\n  //---------------------------------------------------------------------------\n  // _addBinds(sql)\n  //\n  // Add bind information to the statement by examining the passed SQL for\n  // bind variable names.\n  //---------------------------------------------------------------------------\n  _addBind(name) {\n    if (!this.isPlSql || !this.bindInfoDict.has(name)) {\n      const info = new BindInfo(name, this.isReturning);\n      this.bindInfoList.push(info);\n      if (this.bindInfoDict.has(info.bindName)) {\n        if (this.isReturning) {\n          const origInfo = this.bindInfoDict.get(info.bindName)[0];\n          if (!origInfo.isReturnBind) {\n            errors.throwErr(errors.ERR_DML_RETURNING_DUP_BINDS, name);\n          }\n        }\n        this.bindInfoDict.get(info.bindName).push(info);\n      } else {\n        this.bindInfoDict.set(info.bindName, [info]);\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _setVariable(sql)\n  //\n  // Set the variable on the bind information and copy across metadata that\n  // will be used for binding. If the bind metadata has changed, mark the\n  // statement as requiring a full execute. In addition, binding a REF\n  // cursor also requires a full execute.\n  //---------------------------------------------------------------------------\n  _setVariable(bindInfo, variable) {\n    if (variable.type._oraTypeNum === protoConstants.TNS_DATA_TYPE_CURSOR) {\n      this.requiresFullExecute = true;\n    }\n    if (variable.maxSize !== bindInfo.maxSize\n        || variable.dir !== bindInfo.dir\n        || variable.isArray !== bindInfo.isArray\n        || variable.values.length > bindInfo.numElements\n        || variable.type != bindInfo.type\n        || variable.maxArraySize != bindInfo.maxArraySize) {\n      bindInfo.isArray = variable.isArray;\n      bindInfo.numElements = variable.values.length;\n      bindInfo.maxSize = variable.maxSize;\n      bindInfo.type = variable.type;\n      bindInfo.dir = variable.dir;\n      bindInfo.maxArraySize = variable.maxArraySize;\n      this.requiresFullExecute = true;\n    }\n\n    bindInfo.bindVar = variable;\n  }\n\n  //---------------------------------------------------------------------------\n  // _clearAllState\n  //\n  // clear all state associated with the cursor\n  //---------------------------------------------------------------------------\n  _clearAllState() {\n    this.cursorId = 0;\n    this.requiresDefine = false;\n    this.noPrefetch = false;\n    this.requiresFullExecute = false;\n    this.queryVars = [];\n    this.numQueryVars = 0;\n    this.bufferRowCount = 0;\n    this.bufferRowIndex = 0;\n  }\n\n  //---------------------------------------------------------------------------\n  // _clearState\n  //\n  // clear some state associated with the cursor\n  //---------------------------------------------------------------------------\n  _clearState() {\n    this.cursorId = 0;\n    this.requiresDefine = false;\n    this.noPrefetch = false;\n    this.requiresFullExecute = false;\n  }\n}\n\nmodule.exports.Statement = Statement;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}