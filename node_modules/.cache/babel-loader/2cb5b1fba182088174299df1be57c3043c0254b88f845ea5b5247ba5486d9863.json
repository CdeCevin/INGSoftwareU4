{"ast":null,"code":"// Copyright (c) 2024, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// Node file defining the StatementCache class used to manage cached statements\n//-----------------------------------------------------------------------------\n\nconst errors = require(\"../errors.js\");\nconst {\n  Statement\n} = require(\"./statement\");\nclass StatementCache {\n  constructor(maxSize) {\n    this._cachedStatements = new Map();\n    this._maxSize = maxSize;\n    this._cursorsToClose = new Set();\n    this._openCursors = new Set();\n  }\n\n  //---------------------------------------------------------------------------\n  // _addCursorToClose()\n  //\n  // Add the statement's cursor to the list of cursors that need to be closed.\n  //---------------------------------------------------------------------------\n  _addCursorToClose(statement) {\n    if (this._cursorsToClose.has(statement.cursorId)) {\n      const reason = `attempt to close cursor ${statement.cursorId} twice`;\n      errors.throwErr(errors.ERR_INTERNAL, reason);\n    }\n    if (statement.cursorId != 0) {\n      this._cursorsToClose.add(statement.cursorId);\n    }\n    this._openCursors.delete(statement);\n  }\n\n  //---------------------------------------------------------------------------\n  // _adjustCache()\n  // Adjust the cache so that no more than the maximum number of statements\n  // are cached by removing least recently used statements\n  //---------------------------------------------------------------------------\n  _adjustCache() {\n    while (this._cachedStatements.size > this._maxSize) {\n      const sql = this._cachedStatements.keys().next().value;\n      const stmt = this._cachedStatements.get(sql);\n      this._cachedStatements.delete(sql);\n      if (stmt.inUse) {\n        stmt.returnToCache = false;\n      } else if (stmt.cursorId !== 0) {\n        this._addCursorToClose(stmt);\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  //clearCursors() {\n  // Clears the list of open cursors and removes the list of cursors that\n  // need to be closed. This is required when a DRCP session change has\n  // taken place as the cursor ID values are invalidated.\n  //---------------------------------------------------------------------------\n  clearCursors() {\n    const newOpenCursors = new Set();\n    for (const stmt of this._openCursors) {\n      if (stmt.inUse || stmt.returnToCache) {\n        stmt.pendingClear = true;\n        newOpenCursors.add(stmt);\n      }\n      stmt._clearState();\n    }\n    this._openCursors = newOpenCursors;\n    this._cursorsToClose.clear();\n  }\n\n  //---------------------------------------------------------------------------\n  //clearPendingState() {\n  // Clears state for statment with pending clear flag set and not in use.\n  // This will clear all state for open cursors.\n  // Called after rows processing is completed.\n  //---------------------------------------------------------------------------\n  clearPendingStatus() {\n    for (const stmt of this._openCursors) {\n      if (stmt.pendingClear && !stmt.inUse) {\n        stmt._clearAllState();\n        stmt.pendingClear = false;\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // get_statement()\n  // Get a statement from the statement cache, or prepare a new statement\n  // for use. If a statement is already in use or the statement is not\n  // supposed to be cached, a copy will be made (and not returned to the\n  // cache).\n  //---------------------------------------------------------------------------\n  getStatement(sql, cacheStatement = false, forceNew = false) {\n    let stmt = null;\n    if (sql) {\n      stmt = this._cachedStatements.get(sql);\n    }\n    if (!stmt) {\n      stmt = new Statement();\n      if (sql) {\n        stmt._prepare(sql);\n      }\n      if (cacheStatement && !stmt.isDdl && this._maxSize > 0) {\n        stmt.returnToCache = true;\n        this._cachedStatements.set(sql, stmt);\n        this._adjustCache();\n      }\n      this._openCursors.add(stmt);\n    } else if (forceNew || stmt.inUse) {\n      if (!cacheStatement) {\n        this._addCursorToClose(stmt);\n        this._cachedStatements.delete(sql);\n      }\n      stmt = stmt._copy();\n      this._openCursors.add(stmt);\n    } else if (!cacheStatement) {\n      this._cachedStatements.delete(sql);\n      stmt.returnToCache = false;\n    } else {\n      this._cachedStatements.delete(sql);\n      this._cachedStatements.set(sql, stmt);\n    }\n    this._openCursors.add(stmt);\n    stmt.inUse = true;\n    return stmt;\n  }\n  clearCursor(statement) {\n    this._addCursorToClose(statement);\n    statement.cursorId = 0;\n  }\n\n  //---------------------------------------------------------------------------\n  // returnStatement()\n  // Return the statement to the statement cache, if applicable. If the\n  // statement must not be returned to the statement cache, add the cursor\n  // id to the list of cursor ids to close on the next round trip to the\n  // database. Clear all bind variables and fetch variables in order to\n  // ensure that unnecessary references are not retained.\n  //---------------------------------------------------------------------------\n  returnStatement(statement) {\n    if (statement.bindInfoList) {\n      statement.bindInfoList.forEach(bindInfo => {\n        bindInfo.bindVar = null;\n      });\n    }\n    if (statement.queryVars) {\n      statement.queryVars.forEach(queryVar => {\n        queryVar.values.fill(null);\n      });\n    }\n    if (statement.returnToCache) {\n      statement.inUse = false;\n    } else {\n      this._addCursorToClose(statement);\n    }\n    // clear all state for statement which is having flag set and not in use\n    this.clearPendingStatus();\n  }\n\n  //---------------------------------------------------------------------------\n  // writeCursorsToClose()\n  // Write the list of cursors to close to the buffer.\n  //---------------------------------------------------------------------------\n  writeCursorsToClose(buf) {\n    buf.writeUB4(this._cursorsToClose.size);\n    for (const cursorNum of this._cursorsToClose.keys()) {\n      buf.writeUB4(cursorNum);\n    }\n    this._cursorsToClose.clear();\n  }\n}\nmodule.exports = StatementCache;","map":{"version":3,"names":["errors","require","Statement","StatementCache","constructor","maxSize","_cachedStatements","Map","_maxSize","_cursorsToClose","Set","_openCursors","_addCursorToClose","statement","has","cursorId","reason","throwErr","ERR_INTERNAL","add","delete","_adjustCache","size","sql","keys","next","value","stmt","get","inUse","returnToCache","clearCursors","newOpenCursors","pendingClear","_clearState","clear","clearPendingStatus","_clearAllState","getStatement","cacheStatement","forceNew","_prepare","isDdl","set","_copy","clearCursor","returnStatement","bindInfoList","forEach","bindInfo","bindVar","queryVars","queryVar","values","fill","writeCursorsToClose","buf","writeUB4","cursorNum","module","exports"],"sources":["C:/Users/Koliv/Desktop/Software/my-react-app/node_modules/oracledb/lib/thin/statementCache.js"],"sourcesContent":["// Copyright (c) 2024, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n// Node file defining the StatementCache class used to manage cached statements\n//-----------------------------------------------------------------------------\n\nconst errors = require(\"../errors.js\");\nconst { Statement } = require(\"./statement\");\n\nclass StatementCache {\n  constructor(maxSize) {\n    this._cachedStatements = new Map();\n    this._maxSize = maxSize;\n    this._cursorsToClose = new Set();\n    this._openCursors = new Set();\n  }\n\n  //---------------------------------------------------------------------------\n  // _addCursorToClose()\n  //\n  // Add the statement's cursor to the list of cursors that need to be closed.\n  //---------------------------------------------------------------------------\n  _addCursorToClose(statement) {\n    if (this._cursorsToClose.has(statement.cursorId)) {\n      const reason = `attempt to close cursor ${statement.cursorId} twice`;\n      errors.throwErr(errors.ERR_INTERNAL, reason);\n    }\n    if (statement.cursorId != 0) {\n      this._cursorsToClose.add(statement.cursorId);\n    }\n    this._openCursors.delete(statement);\n  }\n\n  //---------------------------------------------------------------------------\n  // _adjustCache()\n  // Adjust the cache so that no more than the maximum number of statements\n  // are cached by removing least recently used statements\n  //---------------------------------------------------------------------------\n  _adjustCache() {\n    while (this._cachedStatements.size > this._maxSize) {\n      const sql = this._cachedStatements.keys().next().value;\n      const stmt = this._cachedStatements.get(sql);\n      this._cachedStatements.delete(sql);\n      if (stmt.inUse) {\n        stmt.returnToCache = false;\n      } else if (stmt.cursorId !== 0) {\n        this._addCursorToClose(stmt);\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  //clearCursors() {\n  // Clears the list of open cursors and removes the list of cursors that\n  // need to be closed. This is required when a DRCP session change has\n  // taken place as the cursor ID values are invalidated.\n  //---------------------------------------------------------------------------\n  clearCursors() {\n    const newOpenCursors = new Set();\n    for (const stmt of this._openCursors) {\n      if (stmt.inUse || stmt.returnToCache) {\n        stmt.pendingClear = true;\n        newOpenCursors.add(stmt);\n      }\n      stmt._clearState();\n    }\n    this._openCursors = newOpenCursors;\n    this._cursorsToClose.clear();\n  }\n\n  //---------------------------------------------------------------------------\n  //clearPendingState() {\n  // Clears state for statment with pending clear flag set and not in use.\n  // This will clear all state for open cursors.\n  // Called after rows processing is completed.\n  //---------------------------------------------------------------------------\n  clearPendingStatus() {\n    for (const stmt of this._openCursors) {\n      if (stmt.pendingClear && !stmt.inUse) {\n        stmt._clearAllState();\n        stmt.pendingClear = false;\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // get_statement()\n  // Get a statement from the statement cache, or prepare a new statement\n  // for use. If a statement is already in use or the statement is not\n  // supposed to be cached, a copy will be made (and not returned to the\n  // cache).\n  //---------------------------------------------------------------------------\n  getStatement(sql, cacheStatement = false, forceNew = false) {\n    let stmt = null;\n    if (sql) {\n      stmt = this._cachedStatements.get(sql);\n    }\n    if (!stmt) {\n      stmt = new Statement();\n      if (sql) {\n        stmt._prepare(sql);\n      }\n      if (cacheStatement && !stmt.isDdl && this._maxSize > 0) {\n        stmt.returnToCache = true;\n        this._cachedStatements.set(sql, stmt);\n        this._adjustCache();\n      }\n      this._openCursors.add(stmt);\n    } else if (forceNew || stmt.inUse) {\n      if (!cacheStatement) {\n        this._addCursorToClose(stmt);\n        this._cachedStatements.delete(sql);\n      }\n      stmt = stmt._copy();\n      this._openCursors.add(stmt);\n    } else if (!cacheStatement) {\n      this._cachedStatements.delete(sql);\n      stmt.returnToCache = false;\n    } else {\n      this._cachedStatements.delete(sql);\n      this._cachedStatements.set(sql, stmt);\n    }\n    this._openCursors.add(stmt);\n    stmt.inUse = true;\n    return stmt;\n  }\n\n  clearCursor(statement) {\n    this._addCursorToClose(statement);\n    statement.cursorId = 0;\n  }\n\n  //---------------------------------------------------------------------------\n  // returnStatement()\n  // Return the statement to the statement cache, if applicable. If the\n  // statement must not be returned to the statement cache, add the cursor\n  // id to the list of cursor ids to close on the next round trip to the\n  // database. Clear all bind variables and fetch variables in order to\n  // ensure that unnecessary references are not retained.\n  //---------------------------------------------------------------------------\n  returnStatement(statement) {\n    if (statement.bindInfoList) {\n      statement.bindInfoList.forEach(bindInfo => {\n        bindInfo.bindVar = null;\n      });\n    }\n    if (statement.queryVars) {\n      statement.queryVars.forEach(queryVar => {\n        queryVar.values.fill(null);\n      });\n    }\n    if (statement.returnToCache) {\n      statement.inUse = false;\n    } else {\n      this._addCursorToClose(statement);\n    }\n    // clear all state for statement which is having flag set and not in use\n    this.clearPendingStatus();\n  }\n\n  //---------------------------------------------------------------------------\n  // writeCursorsToClose()\n  // Write the list of cursors to close to the buffer.\n  //---------------------------------------------------------------------------\n  writeCursorsToClose(buf) {\n    buf.writeUB4(this._cursorsToClose.size);\n    for (const cursorNum of this._cursorsToClose.keys()) {\n      buf.writeUB4(cursorNum);\n    }\n    this._cursorsToClose.clear();\n  }\n}\n\nmodule.exports = StatementCache;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}