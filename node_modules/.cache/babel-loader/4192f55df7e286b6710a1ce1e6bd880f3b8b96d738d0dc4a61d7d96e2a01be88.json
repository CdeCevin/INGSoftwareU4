{"ast":null,"code":"// Copyright (c) 2022, 2024, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst {\n  Buffer\n} = require('buffer');\nconst ConnectionImpl = require('../impl/connection.js');\nconst ThinResultSetImpl = require('./resultSet.js');\nconst ThinLobImpl = require(\"./lob.js\");\nconst Protocol = require(\"./protocol/protocol.js\");\nconst {\n  BaseBuffer\n} = require('../impl/datahandlers/buffer.js');\nconst {\n  NetworkSession: nsi\n} = require(\"./sqlnet/networkSession.js\");\nconst {\n  Statement\n} = require(\"./statement\");\nconst thinUtil = require('./util');\nconst sqlNetConstants = require('./sqlnet/constants.js');\nconst constants = require('./protocol/constants.js');\nconst process = require('process');\nconst types = require('../types.js');\nconst errors = require(\"../errors.js\");\nconst messages = require('./protocol/messages');\nconst StatementCache = require('./statementCache.js');\nconst finalizationRegistry = new global.FinalizationRegistry(heldValue => {\n  heldValue.disconnect();\n});\nclass TDSBuffer extends BaseBuffer {}\nclass ThinConnectionImpl extends ConnectionImpl {\n  /**\n   * Terminates the connection\n   *\n   * @return {Promise}\n   */\n  async close() {\n    try {\n      if (this._protocol.txnInProgress) {\n        if (this.tpcContext) {\n          const message = this.createTpcRollbackMessage();\n          await this._protocol._processMessage(message);\n        } else {\n          await this.rollback();\n        }\n        this.tpcContext = null;\n      }\n      if (this._drcpEnabled) {\n        await this._sessRelease();\n        this._drcpEstablishSession = true;\n      }\n      if (this._pool && !this._dropSess) {\n        await this._pool.release(this);\n      } else {\n        if (!this._drcpEnabled) {\n          const message = new messages.LogOffMessage(this);\n          await this._protocol._processMessage(message);\n        }\n        this.nscon.disconnect();\n      }\n    } catch (err) {\n      // immediate close of open socket on failure\n      // exception won't be thrown to user\n      this.nscon.disconnect(sqlNetConstants.NSFIMM);\n    }\n  }\n  async _sessRelease() {\n    const message = new messages.SessionReleaseMessage(this);\n    if (!this.isPooled()) {\n      message.sessReleaseMode = constants.DRCP_DEAUTHENTICATE;\n    }\n    await this._protocol._processMessage(message);\n  }\n\n  //---------------------------------------------------------------------------\n  // _getElementTypeObj()\n  //\n  // Get the element type's object type. This is needed when processing\n  // collections with an object as the element type since this information is\n  // not available in the TDS.\n  //---------------------------------------------------------------------------\n  async _getElementTypeObj(info) {\n    const binds = [{\n      name: \"owner\",\n      type: types.DB_TYPE_VARCHAR,\n      dir: constants.BIND_IN,\n      maxSize: 128,\n      values: [info.schema]\n    }, {\n      name: \"name\",\n      type: types.DB_TYPE_VARCHAR,\n      dir: constants.BIND_IN,\n      maxSize: 128,\n      values: [info.name]\n    }, {\n      name: \"package_name\",\n      type: types.DB_TYPE_VARCHAR,\n      dir: constants.BIND_IN,\n      maxSize: 128,\n      values: [info.packageName]\n    }];\n    let sql;\n    if (info.packageName) {\n      sql = `\n        select\n            elem_type_owner,\n            elem_type_name,\n            elem_type_package\n        from all_plsql_coll_types\n        where owner = :owner\n          and type_name = :name\n          and package_name = :package_name`;\n    } else {\n      binds.pop();\n      sql = `\n        select\n            elem_type_owner,\n            elem_type_name\n        from all_coll_types\n        where owner = :owner\n          and type_name = :name`;\n    }\n    const options = {\n      connection: {\n        _impl: this\n      },\n      prefetchRows: 2\n    };\n    const result = await this.execute(sql, 1, binds, options, false);\n    const rows = await result.resultSet.getRows(1, options);\n    await result.resultSet.close();\n    const row = rows[0];\n    info.elementTypeClass = this._getDbObjectType(row[0], row[1], row[2]);\n    if (info.elementTypeClass.partial) {\n      this._partialDbObjectTypes.push(info.elementTypeClass);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _execute()\n  //\n  // Calls the RPC that executes a SQL statement and returns the results.\n  //---------------------------------------------------------------------------\n  async _execute(statement, numIters, binds, options, executeManyFlag) {\n    // perform binds\n    const numBinds = statement.bindInfoList.length;\n    const numVars = binds.length;\n    if (numBinds !== numVars && (numVars === 0 || !binds[0].name)) {\n      errors.throwErr(errors.ERR_WRONG_NUMBER_OF_POSITIONAL_BINDS, numBinds, numVars);\n    }\n    for (let i = 0; i < binds.length; i++) {\n      await this._bind(statement, binds[i], i + 1);\n    }\n    if (statement.isPlSql && (options.batchErrors || options.dmlRowCounts)) {\n      errors.throwErr(errors.ERR_EXEC_MODE_ONLY_FOR_DML);\n    }\n\n    // send database request\n    const message = new messages.ExecuteMessage(this, statement, options);\n    message.numExecs = numIters;\n    message.arrayDmlRowCounts = options.dmlRowCounts;\n    message.batchErrors = options.batchErrors;\n\n    // if a PL/SQL statement requires a full execute, perform only a single\n    // iteration in order to allow the determination of input/output binds\n    // to be completed; after that, an execution of the remaining iterations\n    // can be performed.\n    if (statement.isPlSql && (statement.cursorId === 0 || statement.requiresFullExecute)) {\n      message.numExecs = 1;\n      message.noImplicitRelease = true;\n      await this._protocol._processMessage(message);\n      statement.requiresFullExecute = false;\n      message.numExecs = numIters - 1;\n      message.offset = 1;\n      message.noImplicitRelease = false;\n    }\n    if (message.numExecs > 0) {\n      await this._protocol._processMessage(message);\n      statement.requiresFullExecute = false;\n    }\n\n    // if a define is required, send an additional request to the database\n    if (statement.requiresDefine && statement.sql) {\n      statement.requiresFullExecute = true;\n      await this._protocol._processMessage(message);\n      statement.requiresFullExecute = false;\n      statement.requiresDefine = false;\n    }\n\n    // process results\n    const result = {};\n    if (message.warning) {\n      result.warning = message.warning;\n    }\n    if (statement.numQueryVars > 0) {\n      result.resultSet = message.resultSet;\n    } else {\n      statement.bufferRowIndex = 0;\n      const outBinds = thinUtil.getOutBinds(statement, numIters, executeManyFlag);\n      if (outBinds) {\n        result.outBinds = outBinds;\n      }\n      if (executeManyFlag) {\n        if (!statement.isPlSql) {\n          result.rowsAffected = statement.rowCount;\n          delete statement.rowCount;\n        }\n        if (options.dmlRowCounts) {\n          result.dmlRowCounts = options.dmlRowCounts;\n        }\n        if (options.batchErrors) {\n          result.batchErrors = options.batchErrors;\n        }\n      } else {\n        if (statement.isPlSql && options.implicitResultSet) {\n          result.implicitResults = options.implicitResultSet;\n        }\n        if (statement.lastRowid) {\n          result.lastRowid = statement.lastRowid;\n          delete statement.lastRowid;\n        }\n        if (statement.isPlSql) {\n          if (statement.rowCount) {\n            result.rowsAffected = statement.rowCount;\n          }\n        } else {\n          result.rowsAffected = statement.rowCount || 0;\n        }\n        if (statement.rowCount) {\n          delete statement.rowCount;\n        }\n      }\n      this._returnStatement(statement);\n    }\n    return result;\n  }\n\n  //---------------------------------------------------------------------------\n  // _parseTDSAttr()\n  //\n  // Returns the DB type and fills metadata from the TDS buffer.\n  //---------------------------------------------------------------------------\n  _parseTDSAttr(buf, metaData) {\n    let oraTypeNum, csfrm, attrType;\n\n    // skip until a type code that is of interest\n    for (;;) {\n      attrType = buf.readUInt8();\n      if (attrType === constants.TNS_OBJ_TDS_TYPE_EMBED_ADT_INFO) {\n        buf.skipBytes(1); // flags\n      } else if (attrType !== constants.TNS_OBJ_TDS_TYPE_SUBTYPE_MARKER) {\n        break;\n      }\n    }\n\n    // process the type code.\n    switch (attrType) {\n      case constants.TNS_OBJ_TDS_TYPE_NUMBER:\n        metaData.precision = buf.readInt8();\n        metaData.scale = buf.readInt8();\n        return types.DB_TYPE_NUMBER;\n      case constants.TNS_OBJ_TDS_TYPE_FLOAT:\n        metaData.precision = buf.readInt8();\n        return types.DB_TYPE_NUMBER;\n      case constants.TNS_OBJ_TDS_TYPE_VARCHAR:\n      case constants.TNS_OBJ_TDS_TYPE_CHAR:\n        metaData.maxSize = buf.readUInt16BE(); // maximum length\n        oraTypeNum = attrType === constants.TNS_OBJ_TDS_TYPE_VARCHAR ? constants.TNS_DATA_TYPE_VARCHAR : constants.TNS_DATA_TYPE_CHAR;\n        csfrm = buf.readUInt8();\n        csfrm = csfrm & 0x7f;\n        buf.skipBytes(2); // character set\n        return types.getTypeByOraTypeNum(oraTypeNum, csfrm);\n      case constants.TNS_OBJ_TDS_TYPE_RAW:\n        metaData.maxSize = buf.readUInt16BE(); // maximum length\n        return types.DB_TYPE_RAW;\n      case constants.TNS_OBJ_TDS_TYPE_BINARY_FLOAT:\n        return types.DB_TYPE_BINARY_FLOAT;\n      case constants.TNS_OBJ_TDS_TYPE_BINARY_DOUBLE:\n        return types.DB_TYPE_BINARY_DOUBLE;\n      case constants.TNS_OBJ_TDS_TYPE_DATE:\n        return types.DB_TYPE_DATE;\n      case constants.TNS_OBJ_TDS_TYPE_TIMESTAMP:\n        buf.skipBytes(1); // precision\n        return types.DB_TYPE_TIMESTAMP;\n      case constants.TNS_OBJ_TDS_TYPE_TIMESTAMP_LTZ:\n        buf.skipBytes(1); // precision\n        return types.DB_TYPE_TIMESTAMP_LTZ;\n      case constants.TNS_OBJ_TDS_TYPE_TIMESTAMP_TZ:\n        buf.skipBytes(1); // precision\n        return types.DB_TYPE_TIMESTAMP_TZ;\n      case constants.TNS_OBJ_TDS_TYPE_BOOLEAN:\n        return types.DB_TYPE_BOOLEAN;\n      case constants.TNS_OBJ_TDS_TYPE_CLOB:\n        return types.DB_TYPE_CLOB;\n      case constants.TNS_OBJ_TDS_TYPE_BLOB:\n        return types.DB_TYPE_BLOB;\n      case constants.TNS_OBJ_TDS_TYPE_OBJ:\n        buf.skipBytes(5);\n        return types.DB_TYPE_OBJECT;\n      case constants.TNS_OBJ_TDS_TYPE_START_EMBED_ADT:\n        // loop until end type, TNS_OBJ_TDS_TYPE_END_EMBED_ADT\n        // is received.\n        while (this._parseTDSAttr(buf, {}) !== 0) {\n          continue;\n        }\n        return types.DB_TYPE_OBJECT;\n      case constants.TNS_OBJ_TDS_TYPE_END_EMBED_ADT:\n        return 0;\n      default:\n        errors.throwErr(errors.ERR_TDS_TYPE_NOT_SUPPORTED, attrType);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _parseTDS()\n  //\n  // Parses the TDS (type descriptor segment) for the type.\n  //---------------------------------------------------------------------------\n  async _parseTDS(tds, info) {\n    // parse initial TDS bytes\n    const buf = new TDSBuffer(tds);\n    buf.skipBytes(4); // end offset\n    buf.skipBytes(2); // version op code and version\n    buf.skipBytes(2); // unknown\n\n    // if the number of attributes exceeds 1, the type cannot refer to a\n    // collection, so nothing further needs to be done\n    const numAttrs = buf.readUInt16BE();\n\n    // continue parsing TDS bytes to discover if type refers to a collection\n    buf.skipBytes(1); // TDS attributes?\n    buf.skipBytes(1); // start ADT op code\n    buf.skipBytes(2); // ADT number (always zero)\n    buf.skipBytes(4); // offset to index table\n\n    // check to see if type refers to a collection (only one attribute is\n    // present in that case).\n    info.isCollection = false;\n    if (numAttrs === 1) {\n      const pos = buf.pos;\n      const attrType = buf.readUInt8();\n      if (attrType === constants.TNS_OBJ_TDS_TYPE_COLL) {\n        info.isCollection = true;\n      } else {\n        buf.pos = pos;\n      }\n    }\n\n    // Handle collections\n    if (info.isCollection) {\n      // continue parsing TDS to determine element type\n      const elementPos = buf.readUInt32BE();\n      info.maxNumElements = buf.readUInt32BE();\n      info.collectionType = buf.readUInt8();\n      if (info.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {\n        info.collectionFlags = constants.TNS_OBJ_HAS_INDEXES;\n      }\n      buf.pos = elementPos;\n      info.elementTypeInfo = {};\n      info.elementType = this._parseTDSAttr(buf, info.elementTypeInfo);\n      if (info.elementType === types.DB_TYPE_OBJECT) {\n        await this._getElementTypeObj(info);\n        if (info.elementTypeClass.isXmlType) {\n          info.elementType = types.DB_TYPE_XMLTYPE;\n        }\n      }\n    } else {\n      if (info.attributes) {\n        // skip for XML type as it has no attributes.\n        for (const attr of info.attributes) {\n          this._parseTDSAttr(buf, attr);\n        }\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _populateDbObjectTypeInfo()\n  //\n  // Poplates type information given the name of the type.\n  //---------------------------------------------------------------------------\n  async _populateDbObjectTypeInfo(name) {\n    // get type information from the database\n    const sql = `\n      declare\n          t_Instantiable              varchar2(3);\n          t_SuperTypeOwner            varchar2(128);\n          t_SuperTypeName             varchar2(128);\n          t_SubTypeRefCursor          sys_refcursor;\n          t_Pos                       pls_integer;\n      begin\n          :ret_val := dbms_pickler.get_type_shape(:full_name, :oid,\n              :version, :tds, t_Instantiable, t_SuperTypeOwner,\n              t_SuperTypeName, :attrs_rc, t_SubTypeRefCursor);\n          :package_name := null;\n          if substr(:full_name, length(:full_name) - 7) = '%ROWTYPE' then\n              t_Pos := instr(:full_name, '.');\n              :schema := substr(:full_name, 1, t_Pos - 1);\n              :name := substr(:full_name, t_Pos + 1);\n          else\n              begin\n                  select owner, type_name\n                  into :schema, :name\n                  from all_types\n                  where type_oid = :oid;\n              exception\n              when no_data_found then\n                  begin\n                      select owner, package_name, type_name\n                      into :schema, :package_name, :name\n                      from all_plsql_types\n                      where type_oid = :oid;\n                  exception\n                  when no_data_found then\n                      null;\n                  end;\n              end;\n          end if;\n      end;`;\n\n    // get column and datatype information in case of %ROWTYPE handling.\n    const getColumnsSQL = `\n      SELECT\n        column_name,\n        data_type,\n        data_type_owner,\n        case\n          when data_type in\n            ('CHAR', 'NCHAR', 'VARCHAR2', 'NVARCHAR2', 'RAW')\n          then data_length\n          else 0\n        end,\n        nvl(data_precision, 0),\n        nvl(data_scale, 0)\n      from all_tab_cols\n      where owner = :owner\n        and table_name = :name\n        and hidden_column != 'YES'\n      order by column_id`;\n    const binds = [{\n      name: \"full_name\",\n      type: types.DB_TYPE_VARCHAR,\n      dir: constants.BIND_INOUT,\n      maxSize: 500,\n      values: [name]\n    }, {\n      name: \"ret_val\",\n      type: types.DB_TYPE_BINARY_INTEGER,\n      dir: constants.BIND_OUT,\n      values: []\n    }, {\n      name: \"oid\",\n      type: types.DB_TYPE_RAW,\n      maxSize: 16,\n      dir: constants.BIND_OUT,\n      values: []\n    }, {\n      name: \"version\",\n      type: types.DB_TYPE_BINARY_INTEGER,\n      dir: constants.BIND_OUT,\n      values: []\n    }, {\n      name: \"tds\",\n      type: types.DB_TYPE_RAW,\n      maxSize: 2000,\n      dir: constants.BIND_OUT,\n      values: []\n    }, {\n      name: \"attrs_rc\",\n      type: types.DB_TYPE_CURSOR,\n      dir: constants.BIND_OUT,\n      values: []\n    }, {\n      name: \"package_name\",\n      type: types.DB_TYPE_VARCHAR,\n      maxSize: 128,\n      dir: constants.BIND_OUT,\n      values: []\n    }, {\n      name: \"schema\",\n      type: types.DB_TYPE_VARCHAR,\n      maxSize: 128,\n      dir: constants.BIND_OUT,\n      values: []\n    }, {\n      name: \"name\",\n      type: types.DB_TYPE_VARCHAR,\n      maxSize: 128,\n      dir: constants.BIND_OUT,\n      values: []\n    }];\n    const options = {\n      connection: {\n        _impl: this\n      },\n      nullifyInvalidCursor: true\n    };\n    const result = await this.execute(sql, 1, binds, options, false);\n    if (result.outBinds.ret_val !== 0) {\n      errors.throwErr(errors.ERR_INVALID_OBJECT_TYPE_NAME, name);\n    }\n\n    // check cache; if already present, nothing more to do!\n    const info = this._getDbObjectType(result.outBinds.schema, result.outBinds.name, result.outBinds.package_name, result.outBinds.oid);\n    if (!info.partial) return info;\n\n    // process TDS and attributes cursor\n    if (info.name.endsWith('%ROWTYPE')) {\n      const bindVal = [{\n        name: \"owner\",\n        type: types.DB_TYPE_VARCHAR,\n        maxSize: 128,\n        dir: constants.BIND_IN,\n        values: [result.outBinds.schema]\n      }, {\n        name: \"name\",\n        type: types.DB_TYPE_VARCHAR,\n        maxSize: 128,\n        dir: constants.BIND_IN,\n        values: [info.name.substring(0, info.name.length - 8)]\n      }];\n      const val = await this.execute(getColumnsSQL, 1, bindVal, options, false);\n      const attrRows = await val.resultSet._getAllRows();\n      info.attributes = [];\n      for (const row of attrRows) {\n        const metaData = {\n          name: row[0],\n          dataType: row[1],\n          dataTypeOwner: row[2],\n          maxSize: row[3],\n          dataPrecision: row[4],\n          dataScale: row[5]\n        };\n        if (!metaData.dataTypeOwner) {\n          const startPos = row[1].indexOf('(');\n          const endPos = row[1].indexOf(')');\n          if (endPos > startPos) {\n            metaData.dataType = metaData.dataType.substring(0, startPos) + metaData.dataType.substring(endPos + 1, metaData.dataType.length);\n          }\n        }\n        this._addAttr(info.attributes, metaData);\n      }\n    } else {\n      info.version = result.outBinds.version;\n      const attrRows = await result.outBinds.attrs_rc._getAllRows();\n      if (attrRows.length > 0) {\n        // Its an object not a collection.\n        info.attributes = [];\n        for (const row of attrRows) {\n          const metaData = {\n            name: row[1],\n            dataType: row[3],\n            dataTypeOwner: row[4],\n            packageName: row[5],\n            oid: row[6]\n          };\n          this._addAttr(info.attributes, metaData);\n        }\n      }\n      await this._parseTDS(result.outBinds.tds, info);\n    }\n    info.partial = false;\n    return info;\n  }\n\n  //---------------------------------------------------------------------------\n  // _addAttr()\n  //\n  // Populates \"attributes\" object present in \"attrList\".\n  //---------------------------------------------------------------------------\n  _addAttr(attributes, attrInfo) {\n    const attr = {\n      name: attrInfo.name\n    };\n    if (attrInfo.dataTypeOwner) {\n      attr.type = types.DB_TYPE_OBJECT;\n      attr.typeClass = this._getDbObjectType(attrInfo.dataTypeOwner, attrInfo.dataType, attrInfo.packageName, attrInfo.oid);\n      if (attr.typeClass.isXmlType) {\n        attr.type = types.DB_TYPE_XMLTYPE;\n      }\n      if (attr.typeClass.partial) {\n        this._partialDbObjectTypes.push(attr.typeClass);\n      }\n    } else {\n      attr.type = types.getTypeByColumnTypeName(attrInfo.dataType);\n      attr.maxSize = attrInfo.maxSize;\n      attr.precision = attrInfo.dataPrecision;\n      attr.scale = attrInfo.dataScale;\n    }\n    attributes.push(attr);\n  }\n\n  //---------------------------------------------------------------------------\n  // _populatePartialDbObjectTypes()\n  //\n  // Populates partial types that were discovered earlier. Since populating an\n  // object type might result in additional object types being discovered,\n  // object types are popped from the partial types list until the list is\n  // empty.\n  //---------------------------------------------------------------------------\n  async _populatePartialDbObjectTypes() {\n    while (this._partialDbObjectTypes.length > 0) {\n      const info = this._partialDbObjectTypes.pop();\n      let suffix = \"%ROWTYPE\";\n      let name = info.name;\n      if (name.endsWith(suffix)) {\n        name = name.substring(0, name.length - suffix.length);\n      } else {\n        suffix = \"\";\n      }\n      let fullName;\n      if (info.packageName) {\n        fullName = `\"${info.schema}\".\"${info.packageName}\".\"${name}\"${suffix}`;\n      } else {\n        fullName = `\"${info.schema}\".\"${name}\"${suffix}`;\n      }\n      await this._populateDbObjectTypeInfo(fullName);\n    }\n  }\n  async commit() {\n    const message = new messages.CommitMessage(this);\n    await this._protocol._processMessage(message);\n  }\n  async breakExecution() {\n    await this._protocol.breakMessage();\n  }\n  isHealthy() {\n    try {\n      if (this.nscon.recvInbandNotif() === 0) return true;\n      return false;\n    } catch {\n      return false;\n    }\n  }\n  isPooled() {\n    return this._pool ? true : false;\n  }\n\n  /**\n   *\n   * @param {object} params  Configuration of the connection\n   *\n   * @return {Promise}\n   */\n  async connect(params) {\n    if (!params.connectString) {\n      errors.throwErr(errors.ERR_EMPTY_CONNECT_STRING);\n    }\n    thinUtil.checkCredentials(params);\n    this.sessionID = 0;\n    this.serialNum = 0;\n    this.autoCommit = false;\n    this.serverVersion = \"\";\n    this.statementCache = null;\n    this.currentSchema = \"\";\n    this.invokeSessionCallback = true;\n    this.statementCacheSize = params.stmtCacheSize;\n    this._currentSchemaModified = false;\n    this._tempLobsToClose = [];\n    this._tempLobsTotalSize = 0;\n    this._drcpEstablishSession = false;\n    this._cclass = null;\n    this._clientIdentifier = \"\";\n    this._clientIdentifierModified = false;\n    this._action = \"\";\n    this._actionModified = false;\n    this._dbOp = \"\";\n    this._dbOpModified = false;\n    this._clientInfo = \"\";\n    this._clientInfoModified = false;\n    this._module = \"\";\n    this._moduleModified = false;\n    this._drcpEnabled = false;\n    this.serviceName = '';\n    this.remoteAddress = '';\n    this.comboKey = null; // used in changePassword API\n    this.tpcContext = null;\n    this.nscon = new nsi();\n    finalizationRegistry.register(this, this.nscon);\n    await this.nscon.connect(params);\n    let serverType;\n    if (this.isPooled()) {\n      serverType = params._connInfo[0];\n      this.serviceName = params._connInfo[2];\n      this.purity = params._connInfo[3] | constants.PURITY_DEFAULT;\n      this.sid = params._connInfo[4];\n    } else {\n      serverType = this.nscon.getOption(sqlNetConstants.SERVERTYPE);\n      this.serviceName = this.nscon.getOption(sqlNetConstants.SVCNAME);\n      this.sid = this.nscon.getOption(sqlNetConstants.SID);\n      this.purity = this.nscon.getOption(sqlNetConstants.PURITY) | constants.PURITY_DEFAULT;\n    }\n    if (serverType) {\n      this._drcpEnabled = serverType.toLowerCase() === 'pooled';\n    }\n    this.remoteAddress = this.nscon.getOption(sqlNetConstants.REMOTEADDR);\n    this.connectionClass = params.connectionClass;\n\n    /*\n     * if drcp is used, use purity = NEW as the default purity for\n     * standalone connections and purity = SELF for connections that belong\n     * to a pool\n     */\n    if (this.purity === constants.PURITY_DEFAULT && this._drcpEnabled) {\n      if (this.isPooled()) {\n        this.purity = constants.PURITY_SELF;\n      } else {\n        this.purity = constants.PURITY_NEW;\n      }\n    }\n    this._protocol = new Protocol(this);\n\n    // check if the protocol version supported by the database is high\n    // enough; if not, reject the connection immediately\n    if (this._protocol.caps.protocolVersion < constants.TNS_VERSION_MIN_ACCEPTED) {\n      errors.throwErr(errors.ERR_SERVER_VERSION_NOT_SUPPORTED);\n    }\n    try {\n      const protocolMessage = new messages.ProtocolMessage(this);\n      const dataTypeMessage = new messages.DataTypeMessage(this);\n      const authMessage = new messages.AuthMessage(this, params);\n      if (this.nscon.supportsFastAuth) {\n        const fastAuthMessage = new messages.FastAuthMessage(this);\n        fastAuthMessage.protocolMessage = protocolMessage;\n        fastAuthMessage.dataTypeMessage = dataTypeMessage;\n        fastAuthMessage.authMessage = authMessage;\n        await this._protocol._processMessage(fastAuthMessage);\n        if (fastAuthMessage.reNegotiate) {\n          // Fast Authentication failed.\n          await this._protocol._processMessage(dataTypeMessage);\n          await this._protocol._processMessage(authMessage);\n        }\n      } else {\n        await this._protocol._processMessage(protocolMessage);\n        await this._protocol._processMessage(dataTypeMessage);\n        await this._protocol._processMessage(authMessage);\n      }\n      if (!params.token) {\n        // non-token Authentication\n        await this._protocol._processMessage(authMessage); // OAUTH\n      }\n    } catch (err) {\n      this.nscon.disconnect();\n      throw err;\n    }\n    this.statementCache = new StatementCache(this.statementCacheSize);\n    // maintain a list of partially populated database object types\n    this._partialDbObjectTypes = [];\n    if (params.debugJDWP) {\n      this.jdwpData = Buffer.from(params.debugJDWP);\n    } else if (process.env.ORA_DEBUG_JDWP) {\n      this.jdwpData = Buffer.from(process.env.ORA_DEBUG_JDWP);\n    }\n    this._protocol.connInProgress = false;\n  }\n\n  //---------------------------------------------------------------------------\n  // Return the statement to the statement cache, if applicable\n  //---------------------------------------------------------------------------\n  _returnStatement(statement) {\n    this.statementCache.returnStatement(statement);\n  }\n\n  //---------------------------------------------------------------------------\n  // Parses the sql statement and puts it into cache if keepInStmtCache\n  // option is true\n  //---------------------------------------------------------------------------\n  _prepare(sql, options) {\n    const statement = this._getStatement(sql, options.keepInStmtCache);\n    statement.bufferRowIndex = 0;\n    statement.bufferRowCount = 0;\n    statement.lastRowIndex = 0;\n    statement.moreRowsToFetch = true;\n    return statement;\n  }\n\n  //---------------------------------------------------------------------------\n  // Binds the values by user to the statement object\n  //---------------------------------------------------------------------------\n  async _bind(stmt, variable, pos = 0) {\n    const bindInfoDict = stmt.bindInfoDict;\n    const bindInfoList = stmt.bindInfoList;\n\n    /*\n     * For PL/SQL blocks, if the size of a string or bytes object exceeds\n     * 32,767 bytes it is converted to a BLOB/CLOB; and conversion\n     * needs to be established as well to return the string in the way that\n     * the user expects to get it\n     */\n    if (stmt.isPlSql && variable.maxSize > 32767) {\n      if (variable.type === types.DB_TYPE_RAW || variable.type === types.DB_TYPE_LONG_RAW) {\n        variable.type = types.DB_TYPE_BLOB;\n      } else if (variable.type._csfrm === constants.CSFRM_NCHAR) {\n        variable.type = types.DB_TYPE_NCLOB;\n      } else {\n        variable.type = types.DB_TYPE_CLOB;\n      }\n      const maxSize = variable.maxSize;\n      delete variable.maxSize;\n      variable.outConverter = async function (val) {\n        if (val === null) {\n          return null;\n        }\n        const data = await val.getData();\n        const len = val._length;\n        if (data && len > maxSize) {\n          errors.throwErr(errors.ERR_INSUFFICIENT_BUFFER_FOR_BINDS);\n        }\n        return data;\n      };\n    }\n    if (variable.type === types.DB_TYPE_CLOB || variable.type === types.DB_TYPE_NCLOB || variable.type === types.DB_TYPE_BLOB) {\n      for (const [index, val] of variable.values.entries()) {\n        if (!(val instanceof ThinLobImpl)) {\n          if (val && val.length > 0) {\n            const lobImpl = new ThinLobImpl();\n            await lobImpl.create(this, variable.type);\n            await lobImpl.write(1, val);\n            variable.values[index] = lobImpl;\n          } else {\n            variable.values[index] = null;\n          }\n        }\n      }\n    }\n    if (variable.name) {\n      let normalizedName;\n      if (variable.name.startsWith('\"') && variable.name.endsWith('\"')) {\n        normalizedName = variable.name.substring(1, variable.name.length - 1);\n      } else {\n        normalizedName = variable.name.toUpperCase();\n      }\n      if (normalizedName.startsWith(':')) {\n        normalizedName = variable.name.substring(1);\n      }\n      if (!bindInfoDict.has(normalizedName)) {\n        errors.throwErr(errors.ERR_INVALID_BIND_NAME, normalizedName);\n      }\n      bindInfoDict.get(normalizedName).forEach(bindInfo => {\n        stmt._setVariable(bindInfo, variable);\n      });\n    } else {\n      const bindInfo = bindInfoList[pos - 1];\n      stmt._setVariable(bindInfo, variable);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _createResultSet()\n  //\n  // Creates a result set and performs any necessary initialization.\n  //---------------------------------------------------------------------------\n  _createResultSet(options, statement) {\n    const resultSet = new ThinResultSetImpl();\n    if (!statement) {\n      statement = new Statement();\n    }\n    resultSet._resultSetNew(this, statement, options);\n    if (statement.queryVars.length > 0) {\n      const metadata = thinUtil.getMetadataMany(statement.queryVars);\n      resultSet._setup(options, metadata);\n    }\n    return resultSet;\n  }\n\n  //---------------------------------------------------------------------------\n  // getDbObjectClass()\n  //\n  // Returns a database object class given its name.\n  //---------------------------------------------------------------------------\n  async getDbObjectClass(name) {\n    const info = await this._populateDbObjectTypeInfo(name);\n    await this._populatePartialDbObjectTypes();\n    return info;\n  }\n\n  //---------------------------------------------------------------------------\n  // getStatementInfo()\n  //\n  // Parses the SQL statement and returns information about the statement.\n  //---------------------------------------------------------------------------\n  async getStatementInfo(sql) {\n    const options = {};\n    const result = {};\n    const statement = this._prepare(sql, options);\n    options.connection = this;\n    try {\n      if (!statement.isDdl) {\n        const message = new messages.ExecuteMessage(this, statement, options);\n        message.parseOnly = true;\n        await this._protocol._processMessage(message);\n      }\n      if (statement.numQueryVars > 0) {\n        result.metaData = thinUtil.getMetadataMany(statement.queryVars);\n      }\n      result.bindNames = Array.from(statement.bindInfoDict.keys());\n      result.statementType = statement.statementType;\n      return result;\n    } finally {\n      this._returnStatement(statement);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // execute()\n  //\n  // Calls the RPC that executes a SQL statement and returns the results.\n  //---------------------------------------------------------------------------\n  async execute(sql, numIters, binds, options, executeManyFlag) {\n    const statement = this._prepare(sql, options);\n    try {\n      return await this._execute(statement, numIters, binds, options, executeManyFlag);\n    } catch (err) {\n      this._returnStatement(statement);\n      throw err;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // Get the statement object from the statement cache for the SQL if it exists\n  // else prepare a new statement object for the SQL. If a statement is already\n  // in use a copy will be made and returned (and will not be returned to the\n  // cache). If a statement is being executed for the first time after releasing\n  // a DRCP session, a copy will also be made (and will not be returned to the\n  // cache) since it is unknown at this point whether the original session or a\n  // new session is going to be used.\n  //---------------------------------------------------------------------------\n  _getStatement(sql, cacheStatement = false) {\n    return this.statementCache.getStatement(sql, cacheStatement, this._drcpEstablishSession);\n  }\n\n  //---------------------------------------------------------------------------\n  // Calls the ping RPC for Oracle Database\n  //---------------------------------------------------------------------------\n  async ping() {\n    const message = new messages.PingMessage(this);\n    await this._protocol._processMessage(message);\n  }\n\n  //---------------------------------------------------------------------------\n  // Calls the Rollback RPC for Oracle Database\n  //---------------------------------------------------------------------------\n  async rollback() {\n    const message = new messages.RollbackMessage(this);\n    await this._protocol._processMessage(message);\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Server version\n  //---------------------------------------------------------------------------\n  getOracleServerVersion() {\n    return this.serverVersion;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Server version string\n  //---------------------------------------------------------------------------\n  getOracleServerVersionString() {\n    return this.serverVersionString;\n  }\n  setCurrentSchema(schema) {\n    this._currentSchemaModified = true;\n    this.currentSchema = schema;\n  }\n  getCurrentSchema() {\n    return this.currentSchema;\n  }\n  setClientId(clientId) {\n    this._clientIdentifierModified = true;\n    this._clientIdentifier = clientId;\n  }\n  setDbOp(dbOp) {\n    this._dbOpModified = true;\n    this._dbOp = dbOp;\n  }\n  setExternalName(value) {\n    this.externalName = value;\n  }\n  setInternalName(value) {\n    this.internalName = value;\n  }\n  setClientInfo(clientInfo) {\n    this._clientInfoModified = true;\n    this._clientInfo = clientInfo;\n  }\n  setModule(module) {\n    this._moduleModified = true;\n    this._module = module;\n\n    /*\n     * setting the module by itself results in an error so always force\n     * action to be set as well (which eliminates this error)\n     */\n    this._actionModified = true;\n  }\n  setAction(action) {\n    this._actionModified = true;\n    this._action = action;\n  }\n  async changePassword(user, password, newPassword) {\n    const config = {\n      user: user,\n      newPassword: newPassword,\n      password: password,\n      changePassword: true\n    };\n    const message = new messages.AuthMessage(this, config);\n    await this._protocol._processMessage(message); // OAUTH\n  }\n  async createLob(dbType) {\n    const lobImpl = new ThinLobImpl();\n    await lobImpl.create(this, dbType);\n    return lobImpl;\n  }\n\n  // Check the state returned by the tpcCommit() call.\n  checkTpcCommitState(state, onePhase) {\n    if (onePhase && state !== constants.TNS_TPC_TXN_STATE_READ_ONLY && state !== constants.TNS_TPC_TXN_STATE_COMMITTED || !onePhase && state !== constants.TNS_TPC_TXN_STATE_FORGOTTEN) {\n      errors.throwErr(errors.ERR_UNKNOWN_TRANSACTION_STATE, state);\n    }\n  }\n\n  // Creates a two-phase commit message suitable for committing a transaction.\n  createTpcCommitMessage(xid, onePhase) {\n    const message = new messages.TransactionChangeStateMessage(this);\n    message.operation = constants.TNS_TPC_TXN_COMMIT;\n    message.state = onePhase == 0 ? constants.TNS_TPC_TXN_STATE_COMMITTED : constants.TNS_TPC_TXN_STATE_READ_ONLY;\n    message.xid = xid;\n    message.context = this.tpcContext;\n    return message;\n  }\n\n  // Creates a two-phase commit rollback message suitable for use in both\n  // the close() method and explicitly by the user.\n  createTpcRollbackMessage(xid = null) {\n    const message = new messages.TransactionChangeStateMessage(this);\n    message.operation = constants.TNS_TPC_TXN_ABORT;\n    message.state = constants.TNS_TPC_TXN_STATE_ABORTED;\n    message.xid = xid;\n    message.context = this.tpcContext;\n    return message;\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcBegin()\n  //---------------------------------------------------------------------------\n  async tpcBegin(xid, flags, timeout) {\n    const message = new messages.TransactionSwitchMessage(this);\n    message.operation = constants.TNS_TPC_TXN_START;\n    message.xid = xid;\n    message.flags = flags;\n    message.timeout = timeout;\n    await this._protocol._processMessage(message);\n    this.tpcContext = message.context;\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcCommit()\n  //---------------------------------------------------------------------------\n  async tpcCommit(xid, onePhase) {\n    const message = this.createTpcCommitMessage(xid, onePhase);\n    await this._protocol._processMessage(message);\n    this.checkTpcCommitState(message.state, onePhase);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcEnd()\n  //---------------------------------------------------------------------------\n  async tpcEnd(xid, flags) {\n    const message = new messages.TransactionSwitchMessage(this);\n    message.operation = constants.TNS_TPC_TXN_DETACH;\n    message.xid = xid;\n    message.context = this.tpcContext;\n    message.flags = flags;\n    await this._protocol._processMessage(message);\n    this.tpcContext = null;\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcPrepare()\n  //---------------------------------------------------------------------------\n  async tpcPrepare(xid) {\n    const message = new messages.TransactionChangeStateMessage(this);\n    message.operation = constants.TNS_TPC_TXN_PREPARE;\n    message.xid = xid;\n    message.context = this.tpcContext;\n    await this._protocol._processMessage(message);\n    if (message.state === constants.TNS_TPC_TXN_STATE_REQUIRES_COMMIT) {\n      return true;\n    } else if (message.state === constants.TNS_TPC_TXN_STATE_READ_ONLY) {\n      return false;\n    }\n    errors.throwErr(errors.ERR_UNKNOWN_TRANSACTION_STATE, message.state);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcRollback()\n  //---------------------------------------------------------------------------\n  async tpcRollback(xid) {\n    const message = this.createTpcRollbackMessage(xid);\n    await this._protocol._processMessage(message);\n    if (message.state !== constants.TNS_TPC_TXN_STATE_ABORTED) {\n      errors.throwErr(errors.ERR_UNKNOWN_TRANSACTION_STATE, message.state);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the statement cache size for the statement cache maintained by\n  // the connection object\n  //---------------------------------------------------------------------------\n  getStmtCacheSize() {\n    return this.statementCache._maxSize;\n  }\n  setCallTimeout(timeout) {\n    this._protocol.callTimeout = timeout;\n  }\n  getCallTimeout() {\n    return this._protocol.callTimeout;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns getTag. Actual tag returned by db must be a string.\n  //---------------------------------------------------------------------------\n  getTag() {\n    return '';\n  }\n  getExternalName() {\n    return this.externalName;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Database instance name associated with the connection.\n  //---------------------------------------------------------------------------\n  getInstanceName() {\n    return this.instanceName;\n  }\n  getInternalName() {\n    return this.internalName;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Database domain name associated with the connection.\n  //---------------------------------------------------------------------------\n  getDbDomain() {\n    return this.dbDomain;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Database name associated with the connection.\n  //---------------------------------------------------------------------------\n  getDbName() {\n    return this.dbName;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns maximum number of cursors that can be opened in one session.\n  //---------------------------------------------------------------------------\n  getMaxOpenCursors() {\n    return this.maxOpenCursors;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Database service name associated with the connection.\n  //---------------------------------------------------------------------------\n  getServiceName() {\n    return this.serviceName;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns boolean based on this._protocol.txnInProgress value.\n  //---------------------------------------------------------------------------\n  getTransactionInProgress() {\n    return this._protocol.txnInProgress;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the warning object.\n  //---------------------------------------------------------------------------\n  getWarning() {\n    return this.warning;\n  }\n}\nmodule.exports = ThinConnectionImpl;","map":{"version":3,"names":["Buffer","require","ConnectionImpl","ThinResultSetImpl","ThinLobImpl","Protocol","BaseBuffer","NetworkSession","nsi","Statement","thinUtil","sqlNetConstants","constants","process","types","errors","messages","StatementCache","finalizationRegistry","global","FinalizationRegistry","heldValue","disconnect","TDSBuffer","ThinConnectionImpl","close","_protocol","txnInProgress","tpcContext","message","createTpcRollbackMessage","_processMessage","rollback","_drcpEnabled","_sessRelease","_drcpEstablishSession","_pool","_dropSess","release","LogOffMessage","nscon","err","NSFIMM","SessionReleaseMessage","isPooled","sessReleaseMode","DRCP_DEAUTHENTICATE","_getElementTypeObj","info","binds","name","type","DB_TYPE_VARCHAR","dir","BIND_IN","maxSize","values","schema","packageName","sql","pop","options","connection","_impl","prefetchRows","result","execute","rows","resultSet","getRows","row","elementTypeClass","_getDbObjectType","partial","_partialDbObjectTypes","push","_execute","statement","numIters","executeManyFlag","numBinds","bindInfoList","length","numVars","throwErr","ERR_WRONG_NUMBER_OF_POSITIONAL_BINDS","i","_bind","isPlSql","batchErrors","dmlRowCounts","ERR_EXEC_MODE_ONLY_FOR_DML","ExecuteMessage","numExecs","arrayDmlRowCounts","cursorId","requiresFullExecute","noImplicitRelease","offset","requiresDefine","warning","numQueryVars","bufferRowIndex","outBinds","getOutBinds","rowsAffected","rowCount","implicitResultSet","implicitResults","lastRowid","_returnStatement","_parseTDSAttr","buf","metaData","oraTypeNum","csfrm","attrType","readUInt8","TNS_OBJ_TDS_TYPE_EMBED_ADT_INFO","skipBytes","TNS_OBJ_TDS_TYPE_SUBTYPE_MARKER","TNS_OBJ_TDS_TYPE_NUMBER","precision","readInt8","scale","DB_TYPE_NUMBER","TNS_OBJ_TDS_TYPE_FLOAT","TNS_OBJ_TDS_TYPE_VARCHAR","TNS_OBJ_TDS_TYPE_CHAR","readUInt16BE","TNS_DATA_TYPE_VARCHAR","TNS_DATA_TYPE_CHAR","getTypeByOraTypeNum","TNS_OBJ_TDS_TYPE_RAW","DB_TYPE_RAW","TNS_OBJ_TDS_TYPE_BINARY_FLOAT","DB_TYPE_BINARY_FLOAT","TNS_OBJ_TDS_TYPE_BINARY_DOUBLE","DB_TYPE_BINARY_DOUBLE","TNS_OBJ_TDS_TYPE_DATE","DB_TYPE_DATE","TNS_OBJ_TDS_TYPE_TIMESTAMP","DB_TYPE_TIMESTAMP","TNS_OBJ_TDS_TYPE_TIMESTAMP_LTZ","DB_TYPE_TIMESTAMP_LTZ","TNS_OBJ_TDS_TYPE_TIMESTAMP_TZ","DB_TYPE_TIMESTAMP_TZ","TNS_OBJ_TDS_TYPE_BOOLEAN","DB_TYPE_BOOLEAN","TNS_OBJ_TDS_TYPE_CLOB","DB_TYPE_CLOB","TNS_OBJ_TDS_TYPE_BLOB","DB_TYPE_BLOB","TNS_OBJ_TDS_TYPE_OBJ","DB_TYPE_OBJECT","TNS_OBJ_TDS_TYPE_START_EMBED_ADT","TNS_OBJ_TDS_TYPE_END_EMBED_ADT","ERR_TDS_TYPE_NOT_SUPPORTED","_parseTDS","tds","numAttrs","isCollection","pos","TNS_OBJ_TDS_TYPE_COLL","elementPos","readUInt32BE","maxNumElements","collectionType","TNS_OBJ_PLSQL_INDEX_TABLE","collectionFlags","TNS_OBJ_HAS_INDEXES","elementTypeInfo","elementType","isXmlType","DB_TYPE_XMLTYPE","attributes","attr","_populateDbObjectTypeInfo","getColumnsSQL","BIND_INOUT","DB_TYPE_BINARY_INTEGER","BIND_OUT","DB_TYPE_CURSOR","nullifyInvalidCursor","ret_val","ERR_INVALID_OBJECT_TYPE_NAME","package_name","oid","endsWith","bindVal","substring","val","attrRows","_getAllRows","dataType","dataTypeOwner","dataPrecision","dataScale","startPos","indexOf","endPos","_addAttr","version","attrs_rc","attrInfo","typeClass","getTypeByColumnTypeName","_populatePartialDbObjectTypes","suffix","fullName","commit","CommitMessage","breakExecution","breakMessage","isHealthy","recvInbandNotif","connect","params","connectString","ERR_EMPTY_CONNECT_STRING","checkCredentials","sessionID","serialNum","autoCommit","serverVersion","statementCache","currentSchema","invokeSessionCallback","statementCacheSize","stmtCacheSize","_currentSchemaModified","_tempLobsToClose","_tempLobsTotalSize","_cclass","_clientIdentifier","_clientIdentifierModified","_action","_actionModified","_dbOp","_dbOpModified","_clientInfo","_clientInfoModified","_module","_moduleModified","serviceName","remoteAddress","comboKey","register","serverType","_connInfo","purity","PURITY_DEFAULT","sid","getOption","SERVERTYPE","SVCNAME","SID","PURITY","toLowerCase","REMOTEADDR","connectionClass","PURITY_SELF","PURITY_NEW","caps","protocolVersion","TNS_VERSION_MIN_ACCEPTED","ERR_SERVER_VERSION_NOT_SUPPORTED","protocolMessage","ProtocolMessage","dataTypeMessage","DataTypeMessage","authMessage","AuthMessage","supportsFastAuth","fastAuthMessage","FastAuthMessage","reNegotiate","token","debugJDWP","jdwpData","from","env","ORA_DEBUG_JDWP","connInProgress","returnStatement","_prepare","_getStatement","keepInStmtCache","bufferRowCount","lastRowIndex","moreRowsToFetch","stmt","variable","bindInfoDict","DB_TYPE_LONG_RAW","_csfrm","CSFRM_NCHAR","DB_TYPE_NCLOB","outConverter","data","getData","len","_length","ERR_INSUFFICIENT_BUFFER_FOR_BINDS","index","entries","lobImpl","create","write","normalizedName","startsWith","toUpperCase","has","ERR_INVALID_BIND_NAME","get","forEach","bindInfo","_setVariable","_createResultSet","_resultSetNew","queryVars","metadata","getMetadataMany","_setup","getDbObjectClass","getStatementInfo","isDdl","parseOnly","bindNames","Array","keys","statementType","cacheStatement","getStatement","ping","PingMessage","RollbackMessage","getOracleServerVersion","getOracleServerVersionString","serverVersionString","setCurrentSchema","getCurrentSchema","setClientId","clientId","setDbOp","dbOp","setExternalName","value","externalName","setInternalName","internalName","setClientInfo","clientInfo","setModule","module","setAction","action","changePassword","user","password","newPassword","config","createLob","dbType","checkTpcCommitState","state","onePhase","TNS_TPC_TXN_STATE_READ_ONLY","TNS_TPC_TXN_STATE_COMMITTED","TNS_TPC_TXN_STATE_FORGOTTEN","ERR_UNKNOWN_TRANSACTION_STATE","createTpcCommitMessage","xid","TransactionChangeStateMessage","operation","TNS_TPC_TXN_COMMIT","context","TNS_TPC_TXN_ABORT","TNS_TPC_TXN_STATE_ABORTED","tpcBegin","flags","timeout","TransactionSwitchMessage","TNS_TPC_TXN_START","tpcCommit","tpcEnd","TNS_TPC_TXN_DETACH","tpcPrepare","TNS_TPC_TXN_PREPARE","TNS_TPC_TXN_STATE_REQUIRES_COMMIT","tpcRollback","getStmtCacheSize","_maxSize","setCallTimeout","callTimeout","getCallTimeout","getTag","getExternalName","getInstanceName","instanceName","getInternalName","getDbDomain","dbDomain","getDbName","dbName","getMaxOpenCursors","maxOpenCursors","getServiceName","getTransactionInProgress","getWarning","exports"],"sources":["C:/Users/Koliv/Desktop/Software/my-react-app/node_modules/oracledb/lib/thin/connection.js"],"sourcesContent":["// Copyright (c) 2022, 2024, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst { Buffer } = require('buffer');\nconst ConnectionImpl = require('../impl/connection.js');\nconst ThinResultSetImpl = require('./resultSet.js');\nconst ThinLobImpl  = require(\"./lob.js\");\nconst Protocol = require(\"./protocol/protocol.js\");\nconst { BaseBuffer } = require('../impl/datahandlers/buffer.js');\nconst {NetworkSession: nsi} = require(\"./sqlnet/networkSession.js\");\nconst { Statement } = require(\"./statement\");\nconst thinUtil = require('./util');\nconst sqlNetConstants = require('./sqlnet/constants.js');\nconst constants = require('./protocol/constants.js');\nconst process = require('process');\nconst types = require('../types.js');\nconst errors = require(\"../errors.js\");\nconst messages = require('./protocol/messages');\nconst StatementCache = require('./statementCache.js');\n\nconst finalizationRegistry = new global.FinalizationRegistry((heldValue) => {\n  heldValue.disconnect();\n});\n\nclass TDSBuffer extends BaseBuffer {\n}\n\nclass ThinConnectionImpl extends ConnectionImpl {\n\n  /**\n   * Terminates the connection\n   *\n   * @return {Promise}\n   */\n  async close() {\n    try {\n      if (this._protocol.txnInProgress) {\n        if (this.tpcContext) {\n          const message = this.createTpcRollbackMessage();\n          await this._protocol._processMessage(message);\n        } else {\n          await this.rollback();\n        }\n        this.tpcContext = null;\n      }\n      if (this._drcpEnabled) {\n        await this._sessRelease();\n        this._drcpEstablishSession = true;\n      }\n      if (this._pool && !this._dropSess) {\n        await this._pool.release(this);\n      } else {\n        if (!this._drcpEnabled) {\n          const message = new messages.LogOffMessage(this);\n          await this._protocol._processMessage(message);\n        }\n        this.nscon.disconnect();\n      }\n    } catch (err) {\n      // immediate close of open socket on failure\n      // exception won't be thrown to user\n      this.nscon.disconnect(sqlNetConstants.NSFIMM);\n    }\n  }\n\n  async _sessRelease() {\n    const message = new messages.SessionReleaseMessage(this);\n    if (!this.isPooled()) {\n      message.sessReleaseMode = constants.DRCP_DEAUTHENTICATE;\n    }\n    await this._protocol._processMessage(message);\n  }\n\n  //---------------------------------------------------------------------------\n  // _getElementTypeObj()\n  //\n  // Get the element type's object type. This is needed when processing\n  // collections with an object as the element type since this information is\n  // not available in the TDS.\n  //---------------------------------------------------------------------------\n  async _getElementTypeObj(info) {\n    const binds = [\n      {\n        name: \"owner\",\n        type: types.DB_TYPE_VARCHAR,\n        dir: constants.BIND_IN,\n        maxSize: 128,\n        values: [info.schema]\n      },\n      {\n        name: \"name\",\n        type: types.DB_TYPE_VARCHAR,\n        dir: constants.BIND_IN,\n        maxSize: 128,\n        values: [info.name]\n      },\n      {\n        name: \"package_name\",\n        type: types.DB_TYPE_VARCHAR,\n        dir: constants.BIND_IN,\n        maxSize: 128,\n        values: [info.packageName]\n      }\n    ];\n    let sql;\n    if (info.packageName) {\n      sql = `\n        select\n            elem_type_owner,\n            elem_type_name,\n            elem_type_package\n        from all_plsql_coll_types\n        where owner = :owner\n          and type_name = :name\n          and package_name = :package_name`;\n    } else {\n      binds.pop();\n      sql = `\n        select\n            elem_type_owner,\n            elem_type_name\n        from all_coll_types\n        where owner = :owner\n          and type_name = :name`;\n    }\n    const options = {\n      connection: { _impl: this },\n      prefetchRows: 2\n    };\n    const result = await this.execute(sql, 1, binds, options, false);\n    const rows = await result.resultSet.getRows(1, options);\n    await result.resultSet.close();\n    const row = rows[0];\n    info.elementTypeClass = this._getDbObjectType(row[0], row[1], row[2]);\n    if (info.elementTypeClass.partial) {\n      this._partialDbObjectTypes.push(info.elementTypeClass);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _execute()\n  //\n  // Calls the RPC that executes a SQL statement and returns the results.\n  //---------------------------------------------------------------------------\n  async _execute(statement, numIters, binds, options, executeManyFlag) {\n\n    // perform binds\n    const numBinds = statement.bindInfoList.length;\n    const numVars = binds.length;\n    if (numBinds !== numVars && (numVars === 0 || !binds[0].name)) {\n      errors.throwErr(errors.ERR_WRONG_NUMBER_OF_POSITIONAL_BINDS, numBinds, numVars);\n    }\n    for (let i = 0; i < binds.length; i++) {\n      await this._bind(statement, binds[i], i + 1);\n    }\n    if (statement.isPlSql && (options.batchErrors || options.dmlRowCounts)) {\n      errors.throwErr(errors.ERR_EXEC_MODE_ONLY_FOR_DML);\n    }\n\n    // send database request\n    const message = new messages.ExecuteMessage(this, statement, options);\n    message.numExecs = numIters;\n    message.arrayDmlRowCounts = options.dmlRowCounts;\n    message.batchErrors = options.batchErrors;\n\n    // if a PL/SQL statement requires a full execute, perform only a single\n    // iteration in order to allow the determination of input/output binds\n    // to be completed; after that, an execution of the remaining iterations\n    // can be performed.\n    if (statement.isPlSql && (statement.cursorId === 0 ||\n      statement.requiresFullExecute)) {\n      message.numExecs = 1;\n      message.noImplicitRelease = true;\n      await this._protocol._processMessage(message);\n      statement.requiresFullExecute = false;\n      message.numExecs = numIters - 1;\n      message.offset = 1;\n      message.noImplicitRelease = false;\n    }\n    if (message.numExecs > 0) {\n      await this._protocol._processMessage(message);\n      statement.requiresFullExecute = false;\n    }\n\n    // if a define is required, send an additional request to the database\n    if (statement.requiresDefine && statement.sql) {\n      statement.requiresFullExecute = true;\n      await this._protocol._processMessage(message);\n      statement.requiresFullExecute = false;\n      statement.requiresDefine = false;\n    }\n\n    // process results\n    const result = {};\n    if (message.warning) {\n      result.warning = message.warning;\n    }\n    if (statement.numQueryVars > 0) {\n      result.resultSet = message.resultSet;\n    } else {\n      statement.bufferRowIndex = 0;\n      const outBinds = thinUtil.getOutBinds(statement, numIters,\n        executeManyFlag);\n      if (outBinds) {\n        result.outBinds = outBinds;\n      }\n      if (executeManyFlag) {\n        if (!statement.isPlSql) {\n          result.rowsAffected = statement.rowCount;\n          delete statement.rowCount;\n        }\n        if (options.dmlRowCounts) {\n          result.dmlRowCounts = options.dmlRowCounts;\n        }\n        if (options.batchErrors) {\n          result.batchErrors = options.batchErrors;\n        }\n      } else {\n        if (statement.isPlSql && options.implicitResultSet) {\n          result.implicitResults = options.implicitResultSet;\n        }\n        if (statement.lastRowid) {\n          result.lastRowid = statement.lastRowid;\n          delete statement.lastRowid;\n        }\n        if (statement.isPlSql) {\n          if (statement.rowCount) {\n            result.rowsAffected = statement.rowCount;\n          }\n        } else {\n          result.rowsAffected = statement.rowCount || 0;\n        }\n        if (statement.rowCount) {\n          delete statement.rowCount;\n        }\n      }\n      this._returnStatement(statement);\n    }\n\n    return result;\n  }\n\n  //---------------------------------------------------------------------------\n  // _parseTDSAttr()\n  //\n  // Returns the DB type and fills metadata from the TDS buffer.\n  //---------------------------------------------------------------------------\n  _parseTDSAttr(buf, metaData) {\n    let oraTypeNum, csfrm, attrType;\n\n    // skip until a type code that is of interest\n    for (;;) {\n      attrType = buf.readUInt8();\n      if (attrType === constants.TNS_OBJ_TDS_TYPE_EMBED_ADT_INFO) {\n        buf.skipBytes(1); // flags\n      } else if (attrType !== constants.TNS_OBJ_TDS_TYPE_SUBTYPE_MARKER) {\n        break;\n      }\n    }\n\n    // process the type code.\n    switch (attrType) {\n      case constants.TNS_OBJ_TDS_TYPE_NUMBER:\n        metaData.precision = buf.readInt8();\n        metaData.scale = buf.readInt8();\n        return types.DB_TYPE_NUMBER;\n      case constants.TNS_OBJ_TDS_TYPE_FLOAT:\n        metaData.precision = buf.readInt8();\n        return types.DB_TYPE_NUMBER;\n      case constants.TNS_OBJ_TDS_TYPE_VARCHAR:\n      case constants.TNS_OBJ_TDS_TYPE_CHAR:\n        metaData.maxSize = buf.readUInt16BE(); // maximum length\n        oraTypeNum = (attrType === constants.TNS_OBJ_TDS_TYPE_VARCHAR) ?\n          constants.TNS_DATA_TYPE_VARCHAR : constants.TNS_DATA_TYPE_CHAR;\n        csfrm = buf.readUInt8();\n        csfrm = csfrm & 0x7f;\n        buf.skipBytes(2); // character set\n        return types.getTypeByOraTypeNum(oraTypeNum, csfrm);\n      case constants.TNS_OBJ_TDS_TYPE_RAW:\n        metaData.maxSize = buf.readUInt16BE(); // maximum length\n        return types.DB_TYPE_RAW;\n      case constants.TNS_OBJ_TDS_TYPE_BINARY_FLOAT:\n        return types.DB_TYPE_BINARY_FLOAT;\n      case constants.TNS_OBJ_TDS_TYPE_BINARY_DOUBLE:\n        return types.DB_TYPE_BINARY_DOUBLE;\n      case constants.TNS_OBJ_TDS_TYPE_DATE:\n        return types.DB_TYPE_DATE;\n      case constants.TNS_OBJ_TDS_TYPE_TIMESTAMP:\n        buf.skipBytes(1); // precision\n        return types.DB_TYPE_TIMESTAMP;\n      case constants.TNS_OBJ_TDS_TYPE_TIMESTAMP_LTZ:\n        buf.skipBytes(1); // precision\n        return types.DB_TYPE_TIMESTAMP_LTZ;\n      case constants.TNS_OBJ_TDS_TYPE_TIMESTAMP_TZ:\n        buf.skipBytes(1); // precision\n        return types.DB_TYPE_TIMESTAMP_TZ;\n      case constants.TNS_OBJ_TDS_TYPE_BOOLEAN:\n        return types.DB_TYPE_BOOLEAN;\n      case constants.TNS_OBJ_TDS_TYPE_CLOB:\n        return types.DB_TYPE_CLOB;\n      case constants.TNS_OBJ_TDS_TYPE_BLOB:\n        return types.DB_TYPE_BLOB;\n      case constants.TNS_OBJ_TDS_TYPE_OBJ:\n        buf.skipBytes(5);\n        return types.DB_TYPE_OBJECT;\n      case constants.TNS_OBJ_TDS_TYPE_START_EMBED_ADT:\n        // loop until end type, TNS_OBJ_TDS_TYPE_END_EMBED_ADT\n        // is received.\n        while (this._parseTDSAttr(buf, {}) !== 0) {\n          continue;\n        }\n        return types.DB_TYPE_OBJECT;\n      case constants.TNS_OBJ_TDS_TYPE_END_EMBED_ADT:\n        return 0;\n      default:\n        errors.throwErr(errors.ERR_TDS_TYPE_NOT_SUPPORTED, attrType);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _parseTDS()\n  //\n  // Parses the TDS (type descriptor segment) for the type.\n  //---------------------------------------------------------------------------\n  async _parseTDS(tds, info) {\n    // parse initial TDS bytes\n    const buf = new TDSBuffer(tds);\n    buf.skipBytes(4);                   // end offset\n    buf.skipBytes(2);                   // version op code and version\n    buf.skipBytes(2);                   // unknown\n\n    // if the number of attributes exceeds 1, the type cannot refer to a\n    // collection, so nothing further needs to be done\n    const numAttrs = buf.readUInt16BE();\n\n    // continue parsing TDS bytes to discover if type refers to a collection\n    buf.skipBytes(1);                   // TDS attributes?\n    buf.skipBytes(1);                   // start ADT op code\n    buf.skipBytes(2);                   // ADT number (always zero)\n    buf.skipBytes(4);                   // offset to index table\n\n    // check to see if type refers to a collection (only one attribute is\n    // present in that case).\n    info.isCollection = false;\n    if (numAttrs === 1) {\n      const pos = buf.pos;\n      const attrType = buf.readUInt8();\n      if (attrType === constants.TNS_OBJ_TDS_TYPE_COLL) {\n        info.isCollection = true;\n      } else {\n        buf.pos = pos;\n      }\n    }\n\n    // Handle collections\n    if (info.isCollection) {\n      // continue parsing TDS to determine element type\n      const elementPos = buf.readUInt32BE();\n      info.maxNumElements = buf.readUInt32BE();\n      info.collectionType = buf.readUInt8();\n      if (info.collectionType === constants.TNS_OBJ_PLSQL_INDEX_TABLE) {\n        info.collectionFlags = constants.TNS_OBJ_HAS_INDEXES;\n      }\n      buf.pos = elementPos;\n      info.elementTypeInfo = {};\n      info.elementType = this._parseTDSAttr(buf, info.elementTypeInfo);\n      if (info.elementType === types.DB_TYPE_OBJECT) {\n        await this._getElementTypeObj(info);\n        if (info.elementTypeClass.isXmlType) {\n          info.elementType = types.DB_TYPE_XMLTYPE;\n        }\n      }\n    } else {\n      if (info.attributes) { // skip for XML type as it has no attributes.\n        for (const attr of info.attributes) {\n          this._parseTDSAttr(buf, attr);\n        }\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _populateDbObjectTypeInfo()\n  //\n  // Poplates type information given the name of the type.\n  //---------------------------------------------------------------------------\n  async _populateDbObjectTypeInfo(name) {\n\n    // get type information from the database\n    const sql = `\n      declare\n          t_Instantiable              varchar2(3);\n          t_SuperTypeOwner            varchar2(128);\n          t_SuperTypeName             varchar2(128);\n          t_SubTypeRefCursor          sys_refcursor;\n          t_Pos                       pls_integer;\n      begin\n          :ret_val := dbms_pickler.get_type_shape(:full_name, :oid,\n              :version, :tds, t_Instantiable, t_SuperTypeOwner,\n              t_SuperTypeName, :attrs_rc, t_SubTypeRefCursor);\n          :package_name := null;\n          if substr(:full_name, length(:full_name) - 7) = '%ROWTYPE' then\n              t_Pos := instr(:full_name, '.');\n              :schema := substr(:full_name, 1, t_Pos - 1);\n              :name := substr(:full_name, t_Pos + 1);\n          else\n              begin\n                  select owner, type_name\n                  into :schema, :name\n                  from all_types\n                  where type_oid = :oid;\n              exception\n              when no_data_found then\n                  begin\n                      select owner, package_name, type_name\n                      into :schema, :package_name, :name\n                      from all_plsql_types\n                      where type_oid = :oid;\n                  exception\n                  when no_data_found then\n                      null;\n                  end;\n              end;\n          end if;\n      end;`;\n\n    // get column and datatype information in case of %ROWTYPE handling.\n    const getColumnsSQL = `\n      SELECT\n        column_name,\n        data_type,\n        data_type_owner,\n        case\n          when data_type in\n            ('CHAR', 'NCHAR', 'VARCHAR2', 'NVARCHAR2', 'RAW')\n          then data_length\n          else 0\n        end,\n        nvl(data_precision, 0),\n        nvl(data_scale, 0)\n      from all_tab_cols\n      where owner = :owner\n        and table_name = :name\n        and hidden_column != 'YES'\n      order by column_id`;\n\n    const binds = [\n      {\n        name: \"full_name\",\n        type: types.DB_TYPE_VARCHAR,\n        dir: constants.BIND_INOUT,\n        maxSize: 500,\n        values: [name]\n      },\n      {\n        name: \"ret_val\",\n        type: types.DB_TYPE_BINARY_INTEGER,\n        dir: constants.BIND_OUT,\n        values: []\n      },\n      {\n        name: \"oid\",\n        type: types.DB_TYPE_RAW,\n        maxSize: 16,\n        dir: constants.BIND_OUT,\n        values: []\n      },\n      {\n        name: \"version\",\n        type: types.DB_TYPE_BINARY_INTEGER,\n        dir: constants.BIND_OUT,\n        values: []\n      },\n      {\n        name: \"tds\",\n        type: types.DB_TYPE_RAW,\n        maxSize: 2000,\n        dir: constants.BIND_OUT,\n        values: []\n      },\n      {\n        name: \"attrs_rc\",\n        type: types.DB_TYPE_CURSOR,\n        dir: constants.BIND_OUT,\n        values: []\n      },\n      {\n        name: \"package_name\",\n        type: types.DB_TYPE_VARCHAR,\n        maxSize: 128,\n        dir: constants.BIND_OUT,\n        values: []\n      },\n      {\n        name: \"schema\",\n        type: types.DB_TYPE_VARCHAR,\n        maxSize: 128,\n        dir: constants.BIND_OUT,\n        values: []\n      },\n      {\n        name: \"name\",\n        type: types.DB_TYPE_VARCHAR,\n        maxSize: 128,\n        dir: constants.BIND_OUT,\n        values: []\n      }\n    ];\n    const options = {\n      connection: { _impl: this },\n      nullifyInvalidCursor: true\n    };\n    const result = await this.execute(sql, 1, binds, options, false);\n    if (result.outBinds.ret_val !== 0) {\n      errors.throwErr(errors.ERR_INVALID_OBJECT_TYPE_NAME, name);\n    }\n\n    // check cache; if already present, nothing more to do!\n    const info = this._getDbObjectType(result.outBinds.schema,\n      result.outBinds.name, result.outBinds.package_name, result.outBinds.oid);\n    if (!info.partial)\n      return info;\n\n    // process TDS and attributes cursor\n    if (info.name.endsWith('%ROWTYPE')) {\n      const bindVal = [\n        {\n          name: \"owner\",\n          type: types.DB_TYPE_VARCHAR,\n          maxSize: 128,\n          dir: constants.BIND_IN,\n          values: [result.outBinds.schema],\n        },\n        {\n          name: \"name\",\n          type: types.DB_TYPE_VARCHAR,\n          maxSize: 128,\n          dir: constants.BIND_IN,\n          values: [info.name.substring(0, info.name.length - 8)]\n        }\n      ];\n      const val = await this.execute(\n        getColumnsSQL, 1, bindVal, options, false\n      );\n      const attrRows = await val.resultSet._getAllRows();\n      info.attributes = [];\n      for (const row of attrRows) {\n        const metaData = {\n          name: row[0],\n          dataType: row[1],\n          dataTypeOwner: row[2],\n          maxSize: row[3],\n          dataPrecision: row[4],\n          dataScale: row[5],\n        };\n        if (!metaData.dataTypeOwner) {\n          const startPos = row[1].indexOf('(');\n          const endPos = row[1].indexOf(')');\n          if (endPos > startPos) {\n            metaData.dataType = metaData.dataType.substring(0, startPos) +\n              metaData.dataType.substring(\n                endPos + 1, metaData.dataType.length\n              );\n          }\n        }\n        this._addAttr(info.attributes, metaData);\n      }\n    } else {\n      info.version = result.outBinds.version;\n      const attrRows = await result.outBinds.attrs_rc._getAllRows();\n      if (attrRows.length > 0) {\n        // Its an object not a collection.\n        info.attributes = [];\n        for (const row of attrRows) {\n          const metaData = {\n            name: row[1],\n            dataType: row[3],\n            dataTypeOwner: row[4],\n            packageName: row[5],\n            oid: row[6]\n          };\n          this._addAttr(info.attributes, metaData);\n        }\n\n      }\n      await this._parseTDS(result.outBinds.tds, info);\n    }\n    info.partial = false;\n    return info;\n\n  }\n\n  //---------------------------------------------------------------------------\n  // _addAttr()\n  //\n  // Populates \"attributes\" object present in \"attrList\".\n  //---------------------------------------------------------------------------\n  _addAttr(attributes, attrInfo) {\n    const attr = { name: attrInfo.name };\n    if (attrInfo.dataTypeOwner) {\n      attr.type = types.DB_TYPE_OBJECT;\n      attr.typeClass = this._getDbObjectType(\n        attrInfo.dataTypeOwner,\n        attrInfo.dataType,\n        attrInfo.packageName,\n        attrInfo.oid\n      );\n\n      if (attr.typeClass.isXmlType) {\n        attr.type = types.DB_TYPE_XMLTYPE;\n      }\n      if (attr.typeClass.partial) {\n        this._partialDbObjectTypes.push(attr.typeClass);\n      }\n    } else {\n      attr.type = types.getTypeByColumnTypeName(attrInfo.dataType);\n      attr.maxSize = attrInfo.maxSize;\n      attr.precision = attrInfo.dataPrecision;\n      attr.scale = attrInfo.dataScale;\n    }\n    attributes.push(attr);\n  }\n\n  //---------------------------------------------------------------------------\n  // _populatePartialDbObjectTypes()\n  //\n  // Populates partial types that were discovered earlier. Since populating an\n  // object type might result in additional object types being discovered,\n  // object types are popped from the partial types list until the list is\n  // empty.\n  //---------------------------------------------------------------------------\n  async _populatePartialDbObjectTypes() {\n    while (this._partialDbObjectTypes.length > 0) {\n      const info = this._partialDbObjectTypes.pop();\n      let suffix = \"%ROWTYPE\";\n      let name = info.name;\n      if (name.endsWith(suffix)) {\n        name = name.substring(0, name.length - suffix.length);\n      } else {\n        suffix = \"\";\n      }\n      let fullName;\n      if (info.packageName) {\n        fullName = `\"${info.schema}\".\"${info.packageName}\".\"${name}\"${suffix}`;\n      } else {\n        fullName = `\"${info.schema}\".\"${name}\"${suffix}`;\n      }\n      await this._populateDbObjectTypeInfo(fullName);\n    }\n  }\n\n  async commit() {\n    const message = new messages.CommitMessage(this);\n    await this._protocol._processMessage(message);\n  }\n\n  async breakExecution() {\n    await this._protocol.breakMessage();\n  }\n\n  isHealthy() {\n    try {\n      if (this.nscon.recvInbandNotif() === 0)\n        return true;\n      return false;\n    } catch {\n      return false;\n    }\n  }\n\n  isPooled() {\n    return (this._pool) ? true : false;\n  }\n\n  /**\n   *\n   * @param {object} params  Configuration of the connection\n   *\n   * @return {Promise}\n   */\n  async connect(params) {\n    if (!params.connectString) {\n      errors.throwErr(errors.ERR_EMPTY_CONNECT_STRING);\n    }\n    thinUtil.checkCredentials(params);\n\n    this.sessionID = 0;\n    this.serialNum = 0;\n    this.autoCommit = false;\n    this.serverVersion = \"\";\n    this.statementCache = null;\n    this.currentSchema = \"\";\n    this.invokeSessionCallback = true;\n    this.statementCacheSize = params.stmtCacheSize;\n    this._currentSchemaModified = false;\n    this._tempLobsToClose = [];\n    this._tempLobsTotalSize = 0;\n    this._drcpEstablishSession = false;\n    this._cclass = null;\n    this._clientIdentifier = \"\";\n    this._clientIdentifierModified = false;\n    this._action = \"\";\n    this._actionModified = false;\n    this._dbOp = \"\";\n    this._dbOpModified = false;\n    this._clientInfo = \"\";\n    this._clientInfoModified = false;\n    this._module = \"\";\n    this._moduleModified = false;\n    this._drcpEnabled = false;\n    this.serviceName = '';\n    this.remoteAddress = '';\n    this.comboKey = null; // used in changePassword API\n    this.tpcContext = null;\n\n    this.nscon = new nsi();\n    finalizationRegistry.register(this, this.nscon);\n    await this.nscon.connect(params);\n\n    let serverType;\n    if (this.isPooled()) {\n      serverType = params._connInfo[0];\n      this.serviceName = params._connInfo[2];\n      this.purity = params._connInfo[3] | constants.PURITY_DEFAULT;\n      this.sid = params._connInfo[4];\n    } else {\n      serverType = this.nscon.getOption(sqlNetConstants.SERVERTYPE);\n      this.serviceName = this.nscon.getOption(sqlNetConstants.SVCNAME);\n      this.sid = this.nscon.getOption(sqlNetConstants.SID);\n      this.purity = this.nscon.getOption(sqlNetConstants.PURITY) | constants.PURITY_DEFAULT;\n    }\n    if (serverType) {\n      this._drcpEnabled = serverType.toLowerCase() === 'pooled';\n    }\n    this.remoteAddress = this.nscon.getOption(sqlNetConstants.REMOTEADDR);\n    this.connectionClass = params.connectionClass;\n\n    /*\n     * if drcp is used, use purity = NEW as the default purity for\n     * standalone connections and purity = SELF for connections that belong\n     * to a pool\n     */\n    if (this.purity === constants.PURITY_DEFAULT && this._drcpEnabled) {\n      if (this.isPooled()) {\n        this.purity = constants.PURITY_SELF;\n      } else {\n        this.purity = constants.PURITY_NEW;\n      }\n    }\n\n    this._protocol = new Protocol(this);\n\n    // check if the protocol version supported by the database is high\n    // enough; if not, reject the connection immediately\n    if (this._protocol.caps.protocolVersion < constants.TNS_VERSION_MIN_ACCEPTED) {\n      errors.throwErr(errors.ERR_SERVER_VERSION_NOT_SUPPORTED);\n    }\n\n    try {\n      const protocolMessage = new messages.ProtocolMessage(this);\n      const dataTypeMessage = new messages.DataTypeMessage(this);\n      const authMessage = new messages.AuthMessage(this, params);\n      if (this.nscon.supportsFastAuth) {\n        const fastAuthMessage = new messages.FastAuthMessage(this);\n        fastAuthMessage.protocolMessage = protocolMessage;\n        fastAuthMessage.dataTypeMessage = dataTypeMessage;\n        fastAuthMessage.authMessage = authMessage;\n        await this._protocol._processMessage(fastAuthMessage);\n        if (fastAuthMessage.reNegotiate) {\n          // Fast Authentication failed.\n          await this._protocol._processMessage(dataTypeMessage);\n          await this._protocol._processMessage(authMessage);\n        }\n      } else {\n        await this._protocol._processMessage(protocolMessage);\n        await this._protocol._processMessage(dataTypeMessage);\n        await this._protocol._processMessage(authMessage);\n      }\n      if (!params.token) { // non-token Authentication\n        await this._protocol._processMessage(authMessage); // OAUTH\n      }\n    } catch (err) {\n      this.nscon.disconnect();\n      throw err;\n    }\n\n    this.statementCache = new StatementCache(this.statementCacheSize);\n    // maintain a list of partially populated database object types\n    this._partialDbObjectTypes = [];\n\n    if (params.debugJDWP) {\n      this.jdwpData = Buffer.from(params.debugJDWP);\n    } else if (process.env.ORA_DEBUG_JDWP) {\n      this.jdwpData = Buffer.from(process.env.ORA_DEBUG_JDWP);\n    }\n    this._protocol.connInProgress = false;\n  }\n\n  //---------------------------------------------------------------------------\n  // Return the statement to the statement cache, if applicable\n  //---------------------------------------------------------------------------\n  _returnStatement(statement) {\n    this.statementCache.returnStatement(statement);\n  }\n\n  //---------------------------------------------------------------------------\n  // Parses the sql statement and puts it into cache if keepInStmtCache\n  // option is true\n  //---------------------------------------------------------------------------\n  _prepare(sql, options) {\n    const statement = this._getStatement(sql, options.keepInStmtCache);\n    statement.bufferRowIndex = 0;\n    statement.bufferRowCount = 0;\n    statement.lastRowIndex = 0;\n    statement.moreRowsToFetch = true;\n    return statement;\n  }\n\n  //---------------------------------------------------------------------------\n  // Binds the values by user to the statement object\n  //---------------------------------------------------------------------------\n  async _bind(stmt, variable, pos = 0) {\n    const bindInfoDict = stmt.bindInfoDict;\n    const bindInfoList = stmt.bindInfoList;\n\n    /*\n     * For PL/SQL blocks, if the size of a string or bytes object exceeds\n     * 32,767 bytes it is converted to a BLOB/CLOB; and conversion\n     * needs to be established as well to return the string in the way that\n     * the user expects to get it\n     */\n    if (stmt.isPlSql && variable.maxSize > 32767) {\n      if (variable.type === types.DB_TYPE_RAW ||\n          variable.type === types.DB_TYPE_LONG_RAW) {\n        variable.type = types.DB_TYPE_BLOB;\n      } else if (variable.type._csfrm === constants.CSFRM_NCHAR)  {\n        variable.type = types.DB_TYPE_NCLOB;\n      } else {\n        variable.type = types.DB_TYPE_CLOB;\n      }\n      const maxSize = variable.maxSize;\n      delete variable.maxSize;\n      variable.outConverter = async function(val) {\n        if (val === null) {\n          return null;\n        }\n        const data = await val.getData();\n        const len = val._length;\n        if (data && len > maxSize) {\n          errors.throwErr(errors.ERR_INSUFFICIENT_BUFFER_FOR_BINDS);\n        }\n        return data;\n      };\n    }\n\n    if (variable.type === types.DB_TYPE_CLOB ||\n        variable.type === types.DB_TYPE_NCLOB ||\n        variable.type === types.DB_TYPE_BLOB) {\n      for (const [index, val] of variable.values.entries()) {\n        if (!(val instanceof ThinLobImpl)) {\n          if (val && val.length > 0) {\n            const lobImpl = new ThinLobImpl();\n            await lobImpl.create(this, variable.type);\n            await lobImpl.write(1, val);\n            variable.values[index] = lobImpl;\n          } else {\n            variable.values[index] = null;\n          }\n        }\n      }\n    }\n\n    if (variable.name) {\n      let normalizedName;\n      if (variable.name.startsWith('\"') && variable.name.endsWith('\"')) {\n        normalizedName = variable.name.substring(1, variable.name.length - 1);\n      } else {\n        normalizedName = variable.name.toUpperCase();\n      }\n      if (normalizedName.startsWith(':')) {\n        normalizedName = variable.name.substring(1);\n      }\n      if (!bindInfoDict.has(normalizedName)) {\n        errors.throwErr(errors.ERR_INVALID_BIND_NAME, normalizedName);\n      }\n      bindInfoDict.get(normalizedName).forEach((bindInfo) => {\n        stmt._setVariable(bindInfo, variable);\n      });\n    } else {\n      const bindInfo = bindInfoList[pos - 1];\n      stmt._setVariable(bindInfo, variable);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _createResultSet()\n  //\n  // Creates a result set and performs any necessary initialization.\n  //---------------------------------------------------------------------------\n  _createResultSet(options, statement) {\n    const resultSet = new ThinResultSetImpl();\n    if (!statement) {\n      statement = new Statement();\n    }\n    resultSet._resultSetNew(this, statement, options);\n    if (statement.queryVars.length > 0) {\n      const metadata = thinUtil.getMetadataMany(statement.queryVars);\n      resultSet._setup(options, metadata);\n    }\n    return resultSet;\n  }\n\n  //---------------------------------------------------------------------------\n  // getDbObjectClass()\n  //\n  // Returns a database object class given its name.\n  //---------------------------------------------------------------------------\n  async getDbObjectClass(name) {\n    const info = await this._populateDbObjectTypeInfo(name);\n    await this._populatePartialDbObjectTypes();\n    return info;\n  }\n\n  //---------------------------------------------------------------------------\n  // getStatementInfo()\n  //\n  // Parses the SQL statement and returns information about the statement.\n  //---------------------------------------------------------------------------\n  async getStatementInfo(sql) {\n    const options = {};\n    const result = {};\n    const statement = this._prepare(sql, options);\n    options.connection = this;\n    try {\n      if (!statement.isDdl) {\n        const message = new messages.ExecuteMessage(this, statement, options);\n        message.parseOnly = true;\n        await this._protocol._processMessage(message);\n      }\n      if (statement.numQueryVars > 0) {\n        result.metaData = thinUtil.getMetadataMany(statement.queryVars);\n      }\n      result.bindNames = Array.from(statement.bindInfoDict.keys());\n      result.statementType = statement.statementType;\n      return result;\n    } finally {\n      this._returnStatement(statement);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // execute()\n  //\n  // Calls the RPC that executes a SQL statement and returns the results.\n  //---------------------------------------------------------------------------\n  async execute(sql, numIters, binds, options, executeManyFlag) {\n    const statement = this._prepare(sql, options);\n    try {\n      return await this._execute(statement, numIters, binds, options,\n        executeManyFlag);\n    } catch (err) {\n      this._returnStatement(statement);\n      throw err;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // Get the statement object from the statement cache for the SQL if it exists\n  // else prepare a new statement object for the SQL. If a statement is already\n  // in use a copy will be made and returned (and will not be returned to the\n  // cache). If a statement is being executed for the first time after releasing\n  // a DRCP session, a copy will also be made (and will not be returned to the\n  // cache) since it is unknown at this point whether the original session or a\n  // new session is going to be used.\n  //---------------------------------------------------------------------------\n  _getStatement(sql, cacheStatement = false) {\n    return this.statementCache.getStatement(sql, cacheStatement,\n      this._drcpEstablishSession);\n  }\n\n  //---------------------------------------------------------------------------\n  // Calls the ping RPC for Oracle Database\n  //---------------------------------------------------------------------------\n  async ping() {\n    const message = new messages.PingMessage(this);\n    await this._protocol._processMessage(message);\n  }\n\n  //---------------------------------------------------------------------------\n  // Calls the Rollback RPC for Oracle Database\n  //---------------------------------------------------------------------------\n  async rollback() {\n    const message = new messages.RollbackMessage(this);\n    await this._protocol._processMessage(message);\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Server version\n  //---------------------------------------------------------------------------\n  getOracleServerVersion() {\n    return this.serverVersion;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Server version string\n  //---------------------------------------------------------------------------\n  getOracleServerVersionString() {\n    return this.serverVersionString;\n  }\n\n  setCurrentSchema(schema) {\n    this._currentSchemaModified = true;\n    this.currentSchema = schema;\n  }\n\n  getCurrentSchema() {\n    return this.currentSchema;\n  }\n\n  setClientId(clientId) {\n    this._clientIdentifierModified = true;\n    this._clientIdentifier = clientId;\n  }\n\n  setDbOp(dbOp) {\n    this._dbOpModified = true;\n    this._dbOp = dbOp;\n  }\n\n  setExternalName(value) {\n    this.externalName = value;\n  }\n\n  setInternalName(value) {\n    this.internalName = value;\n  }\n\n  setClientInfo(clientInfo) {\n    this._clientInfoModified = true;\n    this._clientInfo = clientInfo;\n  }\n\n  setModule(module) {\n    this._moduleModified = true;\n    this._module = module;\n\n    /*\n     * setting the module by itself results in an error so always force\n     * action to be set as well (which eliminates this error)\n     */\n    this._actionModified = true;\n  }\n\n  setAction(action) {\n    this._actionModified = true;\n    this._action = action;\n  }\n\n  async changePassword(user, password, newPassword) {\n    const config = {\n      user: user,\n      newPassword: newPassword,\n      password: password,\n      changePassword: true\n    };\n    const message = new messages.AuthMessage(this, config);\n    await this._protocol._processMessage(message);    // OAUTH\n  }\n\n  async createLob(dbType) {\n    const lobImpl = new ThinLobImpl();\n    await lobImpl.create(this, dbType);\n    return lobImpl;\n  }\n\n  // Check the state returned by the tpcCommit() call.\n  checkTpcCommitState(state, onePhase) {\n    if ((onePhase && state !== constants.TNS_TPC_TXN_STATE_READ_ONLY\n      && state !== constants.TNS_TPC_TXN_STATE_COMMITTED) ||\n      (!onePhase && state !== constants.TNS_TPC_TXN_STATE_FORGOTTEN)) {\n      errors.throwErr(errors.ERR_UNKNOWN_TRANSACTION_STATE, state);\n    }\n  }\n\n  // Creates a two-phase commit message suitable for committing a transaction.\n  createTpcCommitMessage(xid, onePhase) {\n    const message = new messages.TransactionChangeStateMessage(this);\n    message.operation = constants.TNS_TPC_TXN_COMMIT;\n    message.state = (onePhase == 0) ? constants.TNS_TPC_TXN_STATE_COMMITTED :\n      constants.TNS_TPC_TXN_STATE_READ_ONLY;\n    message.xid = xid;\n    message.context = this.tpcContext;\n    return message;\n  }\n\n  // Creates a two-phase commit rollback message suitable for use in both\n  // the close() method and explicitly by the user.\n  createTpcRollbackMessage(xid = null) {\n    const message = new messages.TransactionChangeStateMessage(this);\n    message.operation = constants.TNS_TPC_TXN_ABORT;\n    message.state = constants.TNS_TPC_TXN_STATE_ABORTED;\n    message.xid = xid;\n    message.context = this.tpcContext;\n    return message;\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcBegin()\n  //---------------------------------------------------------------------------\n  async tpcBegin(xid, flags, timeout) {\n    const message = new messages.TransactionSwitchMessage(this);\n    message.operation = constants.TNS_TPC_TXN_START;\n    message.xid = xid;\n    message.flags = flags;\n    message.timeout = timeout;\n    await this._protocol._processMessage(message);\n    this.tpcContext = message.context;\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcCommit()\n  //---------------------------------------------------------------------------\n  async tpcCommit(xid, onePhase) {\n    const message = this.createTpcCommitMessage(xid, onePhase);\n    await this._protocol._processMessage(message);\n    this.checkTpcCommitState(message.state, onePhase);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcEnd()\n  //---------------------------------------------------------------------------\n  async tpcEnd(xid, flags) {\n    const message = new messages.TransactionSwitchMessage(this);\n    message.operation = constants.TNS_TPC_TXN_DETACH;\n    message.xid = xid;\n    message.context = this.tpcContext;\n    message.flags = flags;\n    await this._protocol._processMessage(message);\n    this.tpcContext = null;\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcPrepare()\n  //---------------------------------------------------------------------------\n  async tpcPrepare(xid) {\n    const message = new messages.TransactionChangeStateMessage(this);\n    message.operation = constants.TNS_TPC_TXN_PREPARE;\n    message.xid = xid;\n    message.context = this.tpcContext;\n    await this._protocol._processMessage(message);\n    if (message.state === constants.TNS_TPC_TXN_STATE_REQUIRES_COMMIT) {\n      return true;\n    } else if (message.state === constants.TNS_TPC_TXN_STATE_READ_ONLY) {\n      return false;\n    }\n\n    errors.throwErr(errors.ERR_UNKNOWN_TRANSACTION_STATE, message.state);\n  }\n\n  //---------------------------------------------------------------------------\n  // tpcRollback()\n  //---------------------------------------------------------------------------\n  async tpcRollback(xid) {\n    const message = this.createTpcRollbackMessage(xid);\n    await this._protocol._processMessage(message);\n    if (message.state !== constants.TNS_TPC_TXN_STATE_ABORTED) {\n      errors.throwErr(errors.ERR_UNKNOWN_TRANSACTION_STATE, message.state);\n    }\n  }\n\n\n  //---------------------------------------------------------------------------\n  // Returns the statement cache size for the statement cache maintained by\n  // the connection object\n  //---------------------------------------------------------------------------\n  getStmtCacheSize() {\n    return this.statementCache._maxSize;\n  }\n\n  setCallTimeout(timeout) {\n    this._protocol.callTimeout = timeout;\n  }\n\n  getCallTimeout() {\n    return this._protocol.callTimeout;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns getTag. Actual tag returned by db must be a string.\n  //---------------------------------------------------------------------------\n  getTag() {\n    return '';\n  }\n\n  getExternalName() {\n    return this.externalName;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Database instance name associated with the connection.\n  //---------------------------------------------------------------------------\n  getInstanceName() {\n    return this.instanceName;\n  }\n\n  getInternalName() {\n    return this.internalName;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Database domain name associated with the connection.\n  //---------------------------------------------------------------------------\n  getDbDomain() {\n    return this.dbDomain;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Database name associated with the connection.\n  //---------------------------------------------------------------------------\n  getDbName() {\n    return this.dbName;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns maximum number of cursors that can be opened in one session.\n  //---------------------------------------------------------------------------\n  getMaxOpenCursors() {\n    return this.maxOpenCursors;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the Oracle Database service name associated with the connection.\n  //---------------------------------------------------------------------------\n  getServiceName() {\n    return this.serviceName;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns boolean based on this._protocol.txnInProgress value.\n  //---------------------------------------------------------------------------\n  getTransactionInProgress() {\n    return this._protocol.txnInProgress;\n  }\n\n  //---------------------------------------------------------------------------\n  // Returns the warning object.\n  //---------------------------------------------------------------------------\n  getWarning() {\n    return this.warning;\n  }\n}\nmodule.exports = ThinConnectionImpl;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}