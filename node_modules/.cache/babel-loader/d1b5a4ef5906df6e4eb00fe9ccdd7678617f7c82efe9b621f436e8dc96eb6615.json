{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst constants = require('../constants.js');\nconst errors = require('../errors.js');\nconst nodbUtil = require('../util.js');\nconst settings = require('../settings.js');\nconst future = require('../future.js');\nconst types = require('../types.js');\nconst Lob = require('../lob.js');\nconst oson = require('./datahandlers/oson.js');\n\n// define implementation class\nclass ResultSetImpl {\n  //---------------------------------------------------------------------------\n  // _determineFetchType()\n  //\n  // Determine the fetch type to use for the specified metadata.\n  //---------------------------------------------------------------------------\n  _determineFetchType(metadata, options) {\n    // clear any previous fetch type and converter functions that may have been\n    // retained\n    delete metadata.fetchType;\n    delete metadata.converter;\n\n    // if a fetch type handler is specified, call it; if no value (undefined)\n    // is returned, the normal processing takes place\n    if (options.fetchTypeHandler) {\n      const result = options.fetchTypeHandler(metadata);\n      if (result !== undefined) {\n        errors.assert(typeof result === 'object', errors.ERR_FETCH_TYPE_HANDLER_RETURN_VALUE);\n        if (result.type !== undefined) {\n          errors.assert(result.type instanceof types.DbType, errors.ERR_FETCH_TYPE_HANDLER_TYPE);\n        }\n        if (result.converter !== undefined) {\n          errors.assert(typeof result.converter === 'function', errors.ERR_FETCH_TYPE_HANDLER_CONVERTER);\n        }\n        metadata.fetchType = result.type;\n        metadata.converter = result.converter;\n      }\n    }\n\n    // continue processing if no fetch type was specified or no fetch type\n    // handler was supplied\n    if (!metadata.fetchType) {\n      // if the fetchTypeMap exists (calculated from the fetchInfo argument),\n      // use it to determine the fetch type\n      if (options.fetchTypeMap && options.fetchTypeMap.has(metadata.name)) {\n        metadata.fetchType = options.fetchTypeMap.get(metadata.name);\n        if (metadata.fetchType === constants.DEFAULT) {\n          metadata.fetchType = types.DB_TYPE_FETCH_TYPE_MAP.get(metadata.dbType);\n        }\n\n        // otherwise, use the default fetch type map (calculated from the\n        // fetchAsString and fetchAsBuffer settings\n      } else {\n        metadata.fetchType = settings.fetchTypeMap.get(metadata.dbType);\n      }\n    }\n\n    // if the types do not match, verify that the conversion is supported and\n    // adjust the final fetch type to match what the database expects\n    if (metadata.fetchType !== metadata.dbType) {\n      const map = types.DB_TYPE_CONVERSION_MAP.get(metadata.dbType);\n      const actualFetchType = map && map.get(metadata.fetchType);\n      if (!actualFetchType) {\n        errors.throwErr(errors.ERR_UNSUPPORTED_CONVERSION, metadata.dbType.name, metadata.fetchType.name);\n      }\n      metadata.fetchType = actualFetchType;\n    }\n    let converter;\n    const userConverter = metadata.converter;\n\n    // If IsJson or IsOson is set, convert to JSON objects unless\n    // user defined output type handler overwrites it.\n    if (metadata.dbType !== types.DB_TYPE_JSON && future.oldJsonColumnAsObj && userConverter === undefined) {\n      let outConverter;\n      if (metadata.isOson) {\n        outConverter = async function (val) {\n          if (!val) {\n            return val;\n          }\n          let result = val;\n          if (val instanceof Lob) {\n            result = await val.getData();\n          }\n          const decoder = new oson.OsonDecoder(result);\n          return decoder.decode();\n        };\n        converter = outConverter;\n      } else if (metadata.isJson) {\n        outConverter = async function (val) {\n          if (!val) {\n            return val;\n          }\n          let result = val;\n          if (val instanceof Lob) {\n            result = await val.getData();\n          }\n          if (result instanceof Buffer) {\n            result = result.toString();\n          }\n          result = JSON.parse(result);\n          return result;\n        };\n        converter = outConverter;\n      }\n    }\n\n    // in thin mode, Oracle NUMBER values are internally fetched as string in\n    // order to preserve precision so must be converted to JavaScript Number\n    // when needed; other numeric and date types are fetched natively as\n    // JavaScript Number and Date values and are converted to string using\n    // toString() when desired\n    if (settings.thin) {\n      if (metadata.dbType === types.DB_TYPE_NUMBER && metadata.fetchType === types.DB_TYPE_NUMBER) {\n        converter = v => v === null ? null : parseFloat(v);\n      } else if (metadata.fetchType === types.DB_TYPE_VARCHAR) {\n        if (metadata.dbType === types.DB_TYPE_BINARY_DOUBLE || metadata.dbType === types.DB_TYPE_BINARY_FLOAT || metadata.dbType === types.DB_TYPE_DATE || metadata.dbType === types.DB_TYPE_TIMESTAMP || metadata.dbType === types.DB_TYPE_TIMESTAMP_LTZ || metadata.dbType === types.DB_TYPE_TIMESTAMP_TZ) {\n          converter = v => v === null ? null : v.toString();\n        } else if (metadata.dbType === types.DB_TYPE_RAW) {\n          converter = v => v === null ? null : v.toString('hex').toUpperCase();\n        }\n      } else if (metadata.dbType === types.DB_TYPE_XMLTYPE) {\n        const xmlConverter = async function (val) {\n          if (!val) {\n            return val;\n          }\n          if (typeof val === 'string') {\n            return val;\n          }\n          return await val.getData();\n        };\n        converter = xmlConverter;\n      }\n      if (userConverter && converter) {\n        const internalConverter = converter;\n        converter = v => userConverter(internalConverter(v));\n      }\n    }\n    if (converter) {\n      metadata.converter = converter;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _getConnImpl()\n  //\n  // Common method on all classes that make use of a connection -- used to\n  // ensure serialization of all use of the connection.\n  //---------------------------------------------------------------------------\n  _getConnImpl() {\n    return this._parentObj;\n  }\n\n  //---------------------------------------------------------------------------\n  // _setup()\n  //\n  // Setup a result set. The metadata is examined to to determine if any\n  // columns need to be manipulated before being returned to the caller. If the\n  // rows fetched from the result set are expected to be objects, a unique set\n  // of attribute names are also determined.\n  //---------------------------------------------------------------------------\n  _setup(options, metaData) {\n    this._parentObj = options.connection._impl;\n    this.metaData = metaData;\n    this.lobIndices = [];\n    this.dbObjectIndices = [];\n    this.nestedCursorIndices = [];\n    this.converterIndices = [];\n    this.outFormat = options.outFormat;\n    this.fetchArraySize = options.fetchArraySize;\n    this.dbObjectAsPojo = options.dbObjectAsPojo;\n    this.maxRows = options.maxRows;\n    const names = new Map();\n    for (let i = 0; i < metaData.length; i++) {\n      const name = metaData[i].name;\n      if (!names.has(name)) {\n        names.set(name, i);\n      }\n    }\n    for (let i = 0; i < metaData.length; i++) {\n      const info = metaData[i];\n      if (info.dbTypeClass) {\n        const cls = options.connection._getDbObjectClass(info.dbTypeClass);\n        info.dbTypeClass = cls;\n      }\n      nodbUtil.addTypeProperties(info, \"dbType\");\n      this._determineFetchType(info, options);\n      if (info.fetchType === types.DB_TYPE_CURSOR) {\n        this.nestedCursorIndices.push(i);\n      } else if (info.fetchType === types.DB_TYPE_CLOB || info.fetchType === types.DB_TYPE_NCLOB || info.fetchType === types.DB_TYPE_BLOB || info.fetchType === types.DB_TYPE_BFILE) {\n        this.lobIndices.push(i);\n      } else if (info.fetchType === types.DB_TYPE_OBJECT) {\n        this.dbObjectIndices.push(i);\n      }\n      if (info.converter) {\n        this.converterIndices.push(i);\n      }\n      let name = info.name;\n      if (names.get(name) !== i) {\n        let seqNum = 0;\n        while (names.has(name)) {\n          seqNum = seqNum + 1;\n          name = `${info.name}_${seqNum}`;\n        }\n        names.set(name, i);\n        info.name = name;\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // close()\n  //\n  // Closes the result set.\n  //---------------------------------------------------------------------------\n  close() {\n    errors.throwNotImplemented(\"closing a result set\");\n  }\n\n  //---------------------------------------------------------------------------\n  // getRows()\n  //\n  // Returns rows from a result set.\n  //---------------------------------------------------------------------------\n  getRows() {\n    errors.throwNotImplemented(\"getting rows\");\n  }\n\n  //---------------------------------------------------------------------------\n  // _getAllRows() [INTERNAL]\n  //\n  // Fetches all the rows from the database to use internally.\n  //---------------------------------------------------------------------------\n  async _getAllRows() {\n    const fetchArraySize = 100;\n    // fetch all rows\n    let rowsFetched = [];\n    while (true) {\n      // eslint-disable-line\n      // constant default value for fetchArraySize\n      const rows = await this.getRows(fetchArraySize, {});\n      if (rows) {\n        await this._processRows(rows, false);\n        rowsFetched = rowsFetched.concat(rows);\n      }\n      if (rows.length < fetchArraySize) {\n        break;\n      }\n    }\n    return rowsFetched;\n  }\n}\nmodule.exports = ResultSetImpl;","map":{"version":3,"names":["constants","require","errors","nodbUtil","settings","future","types","Lob","oson","ResultSetImpl","_determineFetchType","metadata","options","fetchType","converter","fetchTypeHandler","result","undefined","assert","ERR_FETCH_TYPE_HANDLER_RETURN_VALUE","type","DbType","ERR_FETCH_TYPE_HANDLER_TYPE","ERR_FETCH_TYPE_HANDLER_CONVERTER","fetchTypeMap","has","name","get","DEFAULT","DB_TYPE_FETCH_TYPE_MAP","dbType","map","DB_TYPE_CONVERSION_MAP","actualFetchType","throwErr","ERR_UNSUPPORTED_CONVERSION","userConverter","DB_TYPE_JSON","oldJsonColumnAsObj","outConverter","isOson","val","getData","decoder","OsonDecoder","decode","isJson","Buffer","toString","JSON","parse","thin","DB_TYPE_NUMBER","v","parseFloat","DB_TYPE_VARCHAR","DB_TYPE_BINARY_DOUBLE","DB_TYPE_BINARY_FLOAT","DB_TYPE_DATE","DB_TYPE_TIMESTAMP","DB_TYPE_TIMESTAMP_LTZ","DB_TYPE_TIMESTAMP_TZ","DB_TYPE_RAW","toUpperCase","DB_TYPE_XMLTYPE","xmlConverter","internalConverter","_getConnImpl","_parentObj","_setup","metaData","connection","_impl","lobIndices","dbObjectIndices","nestedCursorIndices","converterIndices","outFormat","fetchArraySize","dbObjectAsPojo","maxRows","names","Map","i","length","set","info","dbTypeClass","cls","_getDbObjectClass","addTypeProperties","DB_TYPE_CURSOR","push","DB_TYPE_CLOB","DB_TYPE_NCLOB","DB_TYPE_BLOB","DB_TYPE_BFILE","DB_TYPE_OBJECT","seqNum","close","throwNotImplemented","getRows","_getAllRows","rowsFetched","rows","_processRows","concat","module","exports"],"sources":["C:/Users/Koliv/Desktop/Software/my-react-app/node_modules/oracledb/lib/impl/resultset.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst constants = require('../constants.js');\nconst errors = require('../errors.js');\nconst nodbUtil = require('../util.js');\nconst settings = require('../settings.js');\nconst future = require('../future.js');\nconst types = require('../types.js');\nconst Lob = require('../lob.js');\nconst oson = require('./datahandlers/oson.js');\n\n// define implementation class\nclass ResultSetImpl {\n\n  //---------------------------------------------------------------------------\n  // _determineFetchType()\n  //\n  // Determine the fetch type to use for the specified metadata.\n  //---------------------------------------------------------------------------\n  _determineFetchType(metadata, options) {\n\n    // clear any previous fetch type and converter functions that may have been\n    // retained\n    delete metadata.fetchType;\n    delete metadata.converter;\n\n    // if a fetch type handler is specified, call it; if no value (undefined)\n    // is returned, the normal processing takes place\n    if (options.fetchTypeHandler) {\n      const result = options.fetchTypeHandler(metadata);\n      if (result !== undefined) {\n        errors.assert(typeof result === 'object',\n          errors.ERR_FETCH_TYPE_HANDLER_RETURN_VALUE);\n        if (result.type !== undefined) {\n          errors.assert(result.type instanceof types.DbType,\n            errors.ERR_FETCH_TYPE_HANDLER_TYPE);\n        }\n        if (result.converter !== undefined) {\n          errors.assert(typeof result.converter === 'function',\n            errors.ERR_FETCH_TYPE_HANDLER_CONVERTER);\n        }\n        metadata.fetchType = result.type;\n        metadata.converter = result.converter;\n      }\n    }\n\n    // continue processing if no fetch type was specified or no fetch type\n    // handler was supplied\n    if (!metadata.fetchType) {\n\n      // if the fetchTypeMap exists (calculated from the fetchInfo argument),\n      // use it to determine the fetch type\n      if (options.fetchTypeMap && options.fetchTypeMap.has(metadata.name)) {\n        metadata.fetchType = options.fetchTypeMap.get(metadata.name);\n        if (metadata.fetchType === constants.DEFAULT) {\n          metadata.fetchType =\n            types.DB_TYPE_FETCH_TYPE_MAP.get(metadata.dbType);\n        }\n\n      // otherwise, use the default fetch type map (calculated from the\n      // fetchAsString and fetchAsBuffer settings\n      } else {\n        metadata.fetchType = settings.fetchTypeMap.get(metadata.dbType);\n      }\n\n    }\n\n    // if the types do not match, verify that the conversion is supported and\n    // adjust the final fetch type to match what the database expects\n    if (metadata.fetchType !== metadata.dbType) {\n      const map = types.DB_TYPE_CONVERSION_MAP.get(metadata.dbType);\n      const actualFetchType = map && map.get(metadata.fetchType);\n      if (!actualFetchType) {\n        errors.throwErr(errors.ERR_UNSUPPORTED_CONVERSION,\n          metadata.dbType.name, metadata.fetchType.name);\n      }\n      metadata.fetchType = actualFetchType;\n    }\n\n    let converter;\n    const userConverter = metadata.converter;\n\n    // If IsJson or IsOson is set, convert to JSON objects unless\n    // user defined output type handler overwrites it.\n    if (metadata.dbType !== types.DB_TYPE_JSON && future.oldJsonColumnAsObj\n      && userConverter === undefined) {\n      let outConverter;\n      if (metadata.isOson) {\n        outConverter = async function(val) {\n          if (!val) {\n            return val;\n          }\n          let result = val;\n          if (val instanceof Lob) {\n            result = await val.getData();\n          }\n          const decoder = new oson.OsonDecoder(result);\n          return decoder.decode();\n        };\n        converter = outConverter;\n      } else if (metadata.isJson) {\n        outConverter = async function(val) {\n          if (!val) {\n            return val;\n          }\n\n          let result = val;\n          if (val instanceof Lob) {\n            result = await val.getData();\n          }\n          if (result instanceof Buffer) {\n            result = result.toString();\n          }\n          result = JSON.parse(result);\n          return result;\n        };\n        converter = outConverter;\n      }\n    }\n\n    // in thin mode, Oracle NUMBER values are internally fetched as string in\n    // order to preserve precision so must be converted to JavaScript Number\n    // when needed; other numeric and date types are fetched natively as\n    // JavaScript Number and Date values and are converted to string using\n    // toString() when desired\n    if (settings.thin) {\n      if (metadata.dbType === types.DB_TYPE_NUMBER &&\n        metadata.fetchType === types.DB_TYPE_NUMBER) {\n        converter = (v) => (v === null) ? null : parseFloat(v);\n      } else if (metadata.fetchType === types.DB_TYPE_VARCHAR) {\n        if (metadata.dbType === types.DB_TYPE_BINARY_DOUBLE ||\n          metadata.dbType === types.DB_TYPE_BINARY_FLOAT ||\n          metadata.dbType === types.DB_TYPE_DATE ||\n          metadata.dbType === types.DB_TYPE_TIMESTAMP ||\n          metadata.dbType === types.DB_TYPE_TIMESTAMP_LTZ ||\n          metadata.dbType === types.DB_TYPE_TIMESTAMP_TZ) {\n          converter = (v) => (v === null) ? null : v.toString();\n        } else if (metadata.dbType === types.DB_TYPE_RAW) {\n          converter = (v) => (v === null) ? null : v.toString('hex').toUpperCase();\n        }\n      } else if (metadata.dbType === types.DB_TYPE_XMLTYPE) {\n        const xmlConverter = async function(val) {\n          if (!val) {\n            return val;\n          }\n          if (typeof val === 'string') {\n            return val;\n          }\n          return await val.getData();\n        };\n        converter = xmlConverter;\n      }\n      if (userConverter && converter) {\n        const internalConverter = converter;\n        converter = (v) => userConverter(internalConverter(v));\n      }\n    }\n\n    if (converter) {\n      metadata.converter = converter;\n    }\n\n  }\n\n  //---------------------------------------------------------------------------\n  // _getConnImpl()\n  //\n  // Common method on all classes that make use of a connection -- used to\n  // ensure serialization of all use of the connection.\n  //---------------------------------------------------------------------------\n  _getConnImpl() {\n    return this._parentObj;\n  }\n\n  //---------------------------------------------------------------------------\n  // _setup()\n  //\n  // Setup a result set. The metadata is examined to to determine if any\n  // columns need to be manipulated before being returned to the caller. If the\n  // rows fetched from the result set are expected to be objects, a unique set\n  // of attribute names are also determined.\n  //---------------------------------------------------------------------------\n  _setup(options, metaData) {\n    this._parentObj = options.connection._impl;\n    this.metaData = metaData;\n    this.lobIndices = [];\n    this.dbObjectIndices = [];\n    this.nestedCursorIndices = [];\n    this.converterIndices = [];\n    this.outFormat = options.outFormat;\n    this.fetchArraySize = options.fetchArraySize;\n    this.dbObjectAsPojo = options.dbObjectAsPojo;\n    this.maxRows = options.maxRows;\n    const names = new Map();\n    for (let i = 0; i < metaData.length; i++) {\n      const name = metaData[i].name;\n      if (!names.has(name)) {\n        names.set(name, i);\n      }\n    }\n    for (let i = 0; i < metaData.length; i++) {\n      const info = metaData[i];\n      if (info.dbTypeClass) {\n        const cls = options.connection._getDbObjectClass(info.dbTypeClass);\n        info.dbTypeClass = cls;\n      }\n      nodbUtil.addTypeProperties(info, \"dbType\");\n      this._determineFetchType(info, options);\n      if (info.fetchType === types.DB_TYPE_CURSOR) {\n        this.nestedCursorIndices.push(i);\n      } else if (info.fetchType === types.DB_TYPE_CLOB ||\n          info.fetchType === types.DB_TYPE_NCLOB ||\n          info.fetchType === types.DB_TYPE_BLOB ||\n          info.fetchType === types.DB_TYPE_BFILE) {\n        this.lobIndices.push(i);\n      } else if (info.fetchType === types.DB_TYPE_OBJECT) {\n        this.dbObjectIndices.push(i);\n      }\n      if (info.converter) {\n        this.converterIndices.push(i);\n      }\n      let name = info.name;\n      if (names.get(name) !== i) {\n        let seqNum = 0;\n        while (names.has(name)) {\n          seqNum = seqNum + 1;\n          name = `${info.name}_${seqNum}`;\n        }\n        names.set(name, i);\n        info.name = name;\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // close()\n  //\n  // Closes the result set.\n  //---------------------------------------------------------------------------\n  close() {\n    errors.throwNotImplemented(\"closing a result set\");\n  }\n\n  //---------------------------------------------------------------------------\n  // getRows()\n  //\n  // Returns rows from a result set.\n  //---------------------------------------------------------------------------\n  getRows() {\n    errors.throwNotImplemented(\"getting rows\");\n  }\n\n  //---------------------------------------------------------------------------\n  // _getAllRows() [INTERNAL]\n  //\n  // Fetches all the rows from the database to use internally.\n  //---------------------------------------------------------------------------\n  async _getAllRows() {\n    const fetchArraySize = 100;\n    // fetch all rows\n    let rowsFetched = [];\n    while (true) {    // eslint-disable-line\n      // constant default value for fetchArraySize\n      const rows = await this.getRows(fetchArraySize, {});\n      if (rows) {\n        await this._processRows(rows, false);\n        rowsFetched = rowsFetched.concat(rows);\n      }\n      if (rows.length < fetchArraySize) {\n        break;\n      }\n    }\n\n    return rowsFetched;\n  }\n\n}\n\nmodule.exports = ResultSetImpl;\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,YAAY;;AAEZ,MAAMA,SAAS,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAC5C,MAAMC,MAAM,GAAGD,OAAO,CAAC,cAAc,CAAC;AACtC,MAAME,QAAQ,GAAGF,OAAO,CAAC,YAAY,CAAC;AACtC,MAAMG,QAAQ,GAAGH,OAAO,CAAC,gBAAgB,CAAC;AAC1C,MAAMI,MAAM,GAAGJ,OAAO,CAAC,cAAc,CAAC;AACtC,MAAMK,KAAK,GAAGL,OAAO,CAAC,aAAa,CAAC;AACpC,MAAMM,GAAG,GAAGN,OAAO,CAAC,WAAW,CAAC;AAChC,MAAMO,IAAI,GAAGP,OAAO,CAAC,wBAAwB,CAAC;;AAE9C;AACA,MAAMQ,aAAa,CAAC;EAElB;EACA;EACA;EACA;EACA;EACAC,mBAAmBA,CAACC,QAAQ,EAAEC,OAAO,EAAE;IAErC;IACA;IACA,OAAOD,QAAQ,CAACE,SAAS;IACzB,OAAOF,QAAQ,CAACG,SAAS;;IAEzB;IACA;IACA,IAAIF,OAAO,CAACG,gBAAgB,EAAE;MAC5B,MAAMC,MAAM,GAAGJ,OAAO,CAACG,gBAAgB,CAACJ,QAAQ,CAAC;MACjD,IAAIK,MAAM,KAAKC,SAAS,EAAE;QACxBf,MAAM,CAACgB,MAAM,CAAC,OAAOF,MAAM,KAAK,QAAQ,EACtCd,MAAM,CAACiB,mCAAmC,CAAC;QAC7C,IAAIH,MAAM,CAACI,IAAI,KAAKH,SAAS,EAAE;UAC7Bf,MAAM,CAACgB,MAAM,CAACF,MAAM,CAACI,IAAI,YAAYd,KAAK,CAACe,MAAM,EAC/CnB,MAAM,CAACoB,2BAA2B,CAAC;QACvC;QACA,IAAIN,MAAM,CAACF,SAAS,KAAKG,SAAS,EAAE;UAClCf,MAAM,CAACgB,MAAM,CAAC,OAAOF,MAAM,CAACF,SAAS,KAAK,UAAU,EAClDZ,MAAM,CAACqB,gCAAgC,CAAC;QAC5C;QACAZ,QAAQ,CAACE,SAAS,GAAGG,MAAM,CAACI,IAAI;QAChCT,QAAQ,CAACG,SAAS,GAAGE,MAAM,CAACF,SAAS;MACvC;IACF;;IAEA;IACA;IACA,IAAI,CAACH,QAAQ,CAACE,SAAS,EAAE;MAEvB;MACA;MACA,IAAID,OAAO,CAACY,YAAY,IAAIZ,OAAO,CAACY,YAAY,CAACC,GAAG,CAACd,QAAQ,CAACe,IAAI,CAAC,EAAE;QACnEf,QAAQ,CAACE,SAAS,GAAGD,OAAO,CAACY,YAAY,CAACG,GAAG,CAAChB,QAAQ,CAACe,IAAI,CAAC;QAC5D,IAAIf,QAAQ,CAACE,SAAS,KAAKb,SAAS,CAAC4B,OAAO,EAAE;UAC5CjB,QAAQ,CAACE,SAAS,GAChBP,KAAK,CAACuB,sBAAsB,CAACF,GAAG,CAAChB,QAAQ,CAACmB,MAAM,CAAC;QACrD;;QAEF;QACA;MACA,CAAC,MAAM;QACLnB,QAAQ,CAACE,SAAS,GAAGT,QAAQ,CAACoB,YAAY,CAACG,GAAG,CAAChB,QAAQ,CAACmB,MAAM,CAAC;MACjE;IAEF;;IAEA;IACA;IACA,IAAInB,QAAQ,CAACE,SAAS,KAAKF,QAAQ,CAACmB,MAAM,EAAE;MAC1C,MAAMC,GAAG,GAAGzB,KAAK,CAAC0B,sBAAsB,CAACL,GAAG,CAAChB,QAAQ,CAACmB,MAAM,CAAC;MAC7D,MAAMG,eAAe,GAAGF,GAAG,IAAIA,GAAG,CAACJ,GAAG,CAAChB,QAAQ,CAACE,SAAS,CAAC;MAC1D,IAAI,CAACoB,eAAe,EAAE;QACpB/B,MAAM,CAACgC,QAAQ,CAAChC,MAAM,CAACiC,0BAA0B,EAC/CxB,QAAQ,CAACmB,MAAM,CAACJ,IAAI,EAAEf,QAAQ,CAACE,SAAS,CAACa,IAAI,CAAC;MAClD;MACAf,QAAQ,CAACE,SAAS,GAAGoB,eAAe;IACtC;IAEA,IAAInB,SAAS;IACb,MAAMsB,aAAa,GAAGzB,QAAQ,CAACG,SAAS;;IAExC;IACA;IACA,IAAIH,QAAQ,CAACmB,MAAM,KAAKxB,KAAK,CAAC+B,YAAY,IAAIhC,MAAM,CAACiC,kBAAkB,IAClEF,aAAa,KAAKnB,SAAS,EAAE;MAChC,IAAIsB,YAAY;MAChB,IAAI5B,QAAQ,CAAC6B,MAAM,EAAE;QACnBD,YAAY,GAAG,eAAAA,CAAeE,GAAG,EAAE;UACjC,IAAI,CAACA,GAAG,EAAE;YACR,OAAOA,GAAG;UACZ;UACA,IAAIzB,MAAM,GAAGyB,GAAG;UAChB,IAAIA,GAAG,YAAYlC,GAAG,EAAE;YACtBS,MAAM,GAAG,MAAMyB,GAAG,CAACC,OAAO,CAAC,CAAC;UAC9B;UACA,MAAMC,OAAO,GAAG,IAAInC,IAAI,CAACoC,WAAW,CAAC5B,MAAM,CAAC;UAC5C,OAAO2B,OAAO,CAACE,MAAM,CAAC,CAAC;QACzB,CAAC;QACD/B,SAAS,GAAGyB,YAAY;MAC1B,CAAC,MAAM,IAAI5B,QAAQ,CAACmC,MAAM,EAAE;QAC1BP,YAAY,GAAG,eAAAA,CAAeE,GAAG,EAAE;UACjC,IAAI,CAACA,GAAG,EAAE;YACR,OAAOA,GAAG;UACZ;UAEA,IAAIzB,MAAM,GAAGyB,GAAG;UAChB,IAAIA,GAAG,YAAYlC,GAAG,EAAE;YACtBS,MAAM,GAAG,MAAMyB,GAAG,CAACC,OAAO,CAAC,CAAC;UAC9B;UACA,IAAI1B,MAAM,YAAY+B,MAAM,EAAE;YAC5B/B,MAAM,GAAGA,MAAM,CAACgC,QAAQ,CAAC,CAAC;UAC5B;UACAhC,MAAM,GAAGiC,IAAI,CAACC,KAAK,CAAClC,MAAM,CAAC;UAC3B,OAAOA,MAAM;QACf,CAAC;QACDF,SAAS,GAAGyB,YAAY;MAC1B;IACF;;IAEA;IACA;IACA;IACA;IACA;IACA,IAAInC,QAAQ,CAAC+C,IAAI,EAAE;MACjB,IAAIxC,QAAQ,CAACmB,MAAM,KAAKxB,KAAK,CAAC8C,cAAc,IAC1CzC,QAAQ,CAACE,SAAS,KAAKP,KAAK,CAAC8C,cAAc,EAAE;QAC7CtC,SAAS,GAAIuC,CAAC,IAAMA,CAAC,KAAK,IAAI,GAAI,IAAI,GAAGC,UAAU,CAACD,CAAC,CAAC;MACxD,CAAC,MAAM,IAAI1C,QAAQ,CAACE,SAAS,KAAKP,KAAK,CAACiD,eAAe,EAAE;QACvD,IAAI5C,QAAQ,CAACmB,MAAM,KAAKxB,KAAK,CAACkD,qBAAqB,IACjD7C,QAAQ,CAACmB,MAAM,KAAKxB,KAAK,CAACmD,oBAAoB,IAC9C9C,QAAQ,CAACmB,MAAM,KAAKxB,KAAK,CAACoD,YAAY,IACtC/C,QAAQ,CAACmB,MAAM,KAAKxB,KAAK,CAACqD,iBAAiB,IAC3ChD,QAAQ,CAACmB,MAAM,KAAKxB,KAAK,CAACsD,qBAAqB,IAC/CjD,QAAQ,CAACmB,MAAM,KAAKxB,KAAK,CAACuD,oBAAoB,EAAE;UAChD/C,SAAS,GAAIuC,CAAC,IAAMA,CAAC,KAAK,IAAI,GAAI,IAAI,GAAGA,CAAC,CAACL,QAAQ,CAAC,CAAC;QACvD,CAAC,MAAM,IAAIrC,QAAQ,CAACmB,MAAM,KAAKxB,KAAK,CAACwD,WAAW,EAAE;UAChDhD,SAAS,GAAIuC,CAAC,IAAMA,CAAC,KAAK,IAAI,GAAI,IAAI,GAAGA,CAAC,CAACL,QAAQ,CAAC,KAAK,CAAC,CAACe,WAAW,CAAC,CAAC;QAC1E;MACF,CAAC,MAAM,IAAIpD,QAAQ,CAACmB,MAAM,KAAKxB,KAAK,CAAC0D,eAAe,EAAE;QACpD,MAAMC,YAAY,GAAG,eAAAA,CAAexB,GAAG,EAAE;UACvC,IAAI,CAACA,GAAG,EAAE;YACR,OAAOA,GAAG;UACZ;UACA,IAAI,OAAOA,GAAG,KAAK,QAAQ,EAAE;YAC3B,OAAOA,GAAG;UACZ;UACA,OAAO,MAAMA,GAAG,CAACC,OAAO,CAAC,CAAC;QAC5B,CAAC;QACD5B,SAAS,GAAGmD,YAAY;MAC1B;MACA,IAAI7B,aAAa,IAAItB,SAAS,EAAE;QAC9B,MAAMoD,iBAAiB,GAAGpD,SAAS;QACnCA,SAAS,GAAIuC,CAAC,IAAKjB,aAAa,CAAC8B,iBAAiB,CAACb,CAAC,CAAC,CAAC;MACxD;IACF;IAEA,IAAIvC,SAAS,EAAE;MACbH,QAAQ,CAACG,SAAS,GAAGA,SAAS;IAChC;EAEF;;EAEA;EACA;EACA;EACA;EACA;EACA;EACAqD,YAAYA,CAAA,EAAG;IACb,OAAO,IAAI,CAACC,UAAU;EACxB;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACAC,MAAMA,CAACzD,OAAO,EAAE0D,QAAQ,EAAE;IACxB,IAAI,CAACF,UAAU,GAAGxD,OAAO,CAAC2D,UAAU,CAACC,KAAK;IAC1C,IAAI,CAACF,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACG,UAAU,GAAG,EAAE;IACpB,IAAI,CAACC,eAAe,GAAG,EAAE;IACzB,IAAI,CAACC,mBAAmB,GAAG,EAAE;IAC7B,IAAI,CAACC,gBAAgB,GAAG,EAAE;IAC1B,IAAI,CAACC,SAAS,GAAGjE,OAAO,CAACiE,SAAS;IAClC,IAAI,CAACC,cAAc,GAAGlE,OAAO,CAACkE,cAAc;IAC5C,IAAI,CAACC,cAAc,GAAGnE,OAAO,CAACmE,cAAc;IAC5C,IAAI,CAACC,OAAO,GAAGpE,OAAO,CAACoE,OAAO;IAC9B,MAAMC,KAAK,GAAG,IAAIC,GAAG,CAAC,CAAC;IACvB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,QAAQ,CAACc,MAAM,EAAED,CAAC,EAAE,EAAE;MACxC,MAAMzD,IAAI,GAAG4C,QAAQ,CAACa,CAAC,CAAC,CAACzD,IAAI;MAC7B,IAAI,CAACuD,KAAK,CAACxD,GAAG,CAACC,IAAI,CAAC,EAAE;QACpBuD,KAAK,CAACI,GAAG,CAAC3D,IAAI,EAAEyD,CAAC,CAAC;MACpB;IACF;IACA,KAAK,IAAIA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGb,QAAQ,CAACc,MAAM,EAAED,CAAC,EAAE,EAAE;MACxC,MAAMG,IAAI,GAAGhB,QAAQ,CAACa,CAAC,CAAC;MACxB,IAAIG,IAAI,CAACC,WAAW,EAAE;QACpB,MAAMC,GAAG,GAAG5E,OAAO,CAAC2D,UAAU,CAACkB,iBAAiB,CAACH,IAAI,CAACC,WAAW,CAAC;QAClED,IAAI,CAACC,WAAW,GAAGC,GAAG;MACxB;MACArF,QAAQ,CAACuF,iBAAiB,CAACJ,IAAI,EAAE,QAAQ,CAAC;MAC1C,IAAI,CAAC5E,mBAAmB,CAAC4E,IAAI,EAAE1E,OAAO,CAAC;MACvC,IAAI0E,IAAI,CAACzE,SAAS,KAAKP,KAAK,CAACqF,cAAc,EAAE;QAC3C,IAAI,CAAChB,mBAAmB,CAACiB,IAAI,CAACT,CAAC,CAAC;MAClC,CAAC,MAAM,IAAIG,IAAI,CAACzE,SAAS,KAAKP,KAAK,CAACuF,YAAY,IAC5CP,IAAI,CAACzE,SAAS,KAAKP,KAAK,CAACwF,aAAa,IACtCR,IAAI,CAACzE,SAAS,KAAKP,KAAK,CAACyF,YAAY,IACrCT,IAAI,CAACzE,SAAS,KAAKP,KAAK,CAAC0F,aAAa,EAAE;QAC1C,IAAI,CAACvB,UAAU,CAACmB,IAAI,CAACT,CAAC,CAAC;MACzB,CAAC,MAAM,IAAIG,IAAI,CAACzE,SAAS,KAAKP,KAAK,CAAC2F,cAAc,EAAE;QAClD,IAAI,CAACvB,eAAe,CAACkB,IAAI,CAACT,CAAC,CAAC;MAC9B;MACA,IAAIG,IAAI,CAACxE,SAAS,EAAE;QAClB,IAAI,CAAC8D,gBAAgB,CAACgB,IAAI,CAACT,CAAC,CAAC;MAC/B;MACA,IAAIzD,IAAI,GAAG4D,IAAI,CAAC5D,IAAI;MACpB,IAAIuD,KAAK,CAACtD,GAAG,CAACD,IAAI,CAAC,KAAKyD,CAAC,EAAE;QACzB,IAAIe,MAAM,GAAG,CAAC;QACd,OAAOjB,KAAK,CAACxD,GAAG,CAACC,IAAI,CAAC,EAAE;UACtBwE,MAAM,GAAGA,MAAM,GAAG,CAAC;UACnBxE,IAAI,GAAG,GAAG4D,IAAI,CAAC5D,IAAI,IAAIwE,MAAM,EAAE;QACjC;QACAjB,KAAK,CAACI,GAAG,CAAC3D,IAAI,EAAEyD,CAAC,CAAC;QAClBG,IAAI,CAAC5D,IAAI,GAAGA,IAAI;MAClB;IACF;EACF;;EAEA;EACA;EACA;EACA;EACA;EACAyE,KAAKA,CAAA,EAAG;IACNjG,MAAM,CAACkG,mBAAmB,CAAC,sBAAsB,CAAC;EACpD;;EAEA;EACA;EACA;EACA;EACA;EACAC,OAAOA,CAAA,EAAG;IACRnG,MAAM,CAACkG,mBAAmB,CAAC,cAAc,CAAC;EAC5C;;EAEA;EACA;EACA;EACA;EACA;EACA,MAAME,WAAWA,CAAA,EAAG;IAClB,MAAMxB,cAAc,GAAG,GAAG;IAC1B;IACA,IAAIyB,WAAW,GAAG,EAAE;IACpB,OAAO,IAAI,EAAE;MAAK;MAChB;MACA,MAAMC,IAAI,GAAG,MAAM,IAAI,CAACH,OAAO,CAACvB,cAAc,EAAE,CAAC,CAAC,CAAC;MACnD,IAAI0B,IAAI,EAAE;QACR,MAAM,IAAI,CAACC,YAAY,CAACD,IAAI,EAAE,KAAK,CAAC;QACpCD,WAAW,GAAGA,WAAW,CAACG,MAAM,CAACF,IAAI,CAAC;MACxC;MACA,IAAIA,IAAI,CAACpB,MAAM,GAAGN,cAAc,EAAE;QAChC;MACF;IACF;IAEA,OAAOyB,WAAW;EACpB;AAEF;AAEAI,MAAM,CAACC,OAAO,GAAGnG,aAAa","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}