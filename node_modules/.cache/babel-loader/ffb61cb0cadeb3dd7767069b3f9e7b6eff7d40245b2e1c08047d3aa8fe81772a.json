{"ast":null,"code":"// Copyright (c) 2023, 2024, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst {\n  BaseBuffer,\n  GrowableBuffer\n} = require('./buffer.js');\nconst {\n  Buffer\n} = require('buffer');\nconst constants = require(\"./constants.js\");\nconst errors = require(\"../../errors.js\");\nconst types = require(\"../../types.js\");\nconst util = require(\"util\");\nconst vector = require(\"./vector.js\");\nconst nodbUtil = require(\"../../util.js\");\n\n/**\n * Class used for decoding\n */\nclass OsonDecoder extends BaseBuffer {\n  //---------------------------------------------------------------------------\n  // _decodeContainerNode()\n  //\n  // Decodes a container node (object or array) from the tree segment and\n  // returns the JavaScript equivalent.\n  //---------------------------------------------------------------------------\n  _decodeContainerNode(nodeType) {\n    // determine the number of children by examining the 4th and 5th most\n    // significant bits of the node type; determine the offsets in the tree\n    // segment to the field ids array and the value offsets array\n    let container, offsetsPos, fieldIdsPos;\n    const containerOffset = this.pos - this.treeSegPos - 1;\n    let numChildren = this._getNumChildren(nodeType);\n    const isObject = (nodeType & 0x40) === 0;\n    if (numChildren === undefined) {\n      const offset = this._getOffset(nodeType);\n      offsetsPos = this.pos;\n      this.pos = this.treeSegPos + offset;\n      const sharedNodeType = this.readUInt8();\n      numChildren = this._getNumChildren(sharedNodeType);\n      container = isObject ? {} : new Array(numChildren);\n      fieldIdsPos = this.pos;\n    } else if (isObject) {\n      container = {};\n      fieldIdsPos = this.pos;\n      offsetsPos = this.pos + this.fieldIdLength * numChildren;\n    } else {\n      container = new Array(numChildren);\n      offsetsPos = this.pos;\n    }\n    for (let i = 0; i < numChildren; i++) {\n      let name;\n      if (isObject) {\n        let fieldId;\n        if (this.fieldIdLength === 1) {\n          fieldId = this.buf[fieldIdsPos];\n        } else if (this.fieldIdLength == 2) {\n          fieldId = this.buf.readUInt16BE(fieldIdsPos);\n        } else {\n          fieldId = this.buf.readUInt32BE(fieldIdsPos);\n        }\n        name = this.fieldNames[fieldId - 1];\n        fieldIdsPos += this.fieldIdLength;\n      }\n      this.pos = offsetsPos;\n      let offset = this._getOffset(nodeType);\n      if (this.relativeOffsets) {\n        offset += containerOffset;\n      }\n      offsetsPos = this.pos;\n      this.pos = this.treeSegPos + offset;\n      if (isObject) {\n        container[name] = this._decodeNode();\n      } else {\n        container[i] = this._decodeNode();\n      }\n    }\n    return container;\n  }\n\n  //---------------------------------------------------------------------------\n  // _decodeNode()\n  //\n  // Decodes a node from the tree segment and returns the JavaScript\n  // equivalent.\n  //---------------------------------------------------------------------------\n  _decodeNode() {\n    // if the most significant bit is set the node refers to a container\n    let nodeType = this.readUInt8();\n    if (nodeType & 0x80) {\n      return this._decodeContainerNode(nodeType);\n    }\n\n    // handle simple scalars\n    if (nodeType === constants.TNS_JSON_TYPE_NULL) {\n      return null;\n    } else if (nodeType === constants.TNS_JSON_TYPE_TRUE) {\n      return true;\n    } else if (nodeType === constants.TNS_JSON_TYPE_FALSE) {\n      return false;\n\n      // handle fixed length scalars\n    } else if (nodeType === constants.TNS_JSON_TYPE_DATE || nodeType === constants.TNS_JSON_TYPE_TIMESTAMP7) {\n      return this.parseOracleDate(this.readBytes(7));\n    } else if (nodeType === constants.TNS_JSON_TYPE_TIMESTAMP) {\n      return this.parseOracleDate(this.readBytes(11));\n    } else if (nodeType === constants.TNS_JSON_TYPE_TIMESTAMP_TZ) {\n      return this.parseOracleDate(this.readBytes(13));\n    } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_FLOAT) {\n      return this.parseBinaryFloat(this.readBytes(4));\n    } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_DOUBLE) {\n      return this.parseBinaryDouble(this.readBytes(8));\n\n      // handle scalars with lengths stored outside the node itself\n    } else if (nodeType === constants.TNS_JSON_TYPE_STRING_LENGTH_UINT8) {\n      return this.readBytes(this.readUInt8()).toString();\n    } else if (nodeType === constants.TNS_JSON_TYPE_STRING_LENGTH_UINT16) {\n      return this.readBytes(this.readUInt16BE()).toString();\n    } else if (nodeType === constants.TNS_JSON_TYPE_STRING_LENGTH_UINT32) {\n      return this.readBytes(this.readUInt32BE()).toString();\n    } else if (nodeType === constants.TNS_JSON_TYPE_NUMBER_LENGTH_UINT8) {\n      return parseFloat(this.readOracleNumber());\n    } else if (nodeType === constants.TNS_JSON_TYPE_ID) {\n      const buf = this.readBytes(this.readUInt8());\n      const jsonId = new types.JsonId(buf.length);\n      buf.copy(jsonId);\n      return jsonId;\n    } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT16) {\n      return Buffer.from(this.readBytes(this.readUInt16BE()));\n    } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT32) {\n      return Buffer.from(this.readBytes(this.readUInt32BE()));\n    } else if (nodeType === constants.TNS_JSON_TYPE_EXTENDED) {\n      nodeType = this.readUInt8();\n      if (nodeType === constants.TNS_JSON_TYPE_VECTOR) {\n        const vecImage = this.readBytes(this.readUInt32BE());\n        const decoder = new vector.VectorDecoder(vecImage);\n        return decoder.decode();\n      }\n    }\n\n    // handle number/decimal with length stored inside the node itself\n    const typeBits = nodeType & 0xf0;\n    if (typeBits === 0x20 || typeBits === 0x60) {\n      const len = nodeType & 0x0f;\n      return parseFloat(this.parseOracleNumber(this.readBytes(len + 1)));\n\n      // handle integer with length stored inside the node itself\n    } else if (typeBits === 0x40 || typeBits === 0x50) {\n      const len = nodeType & 0x0f;\n      return parseFloat(this.parseOracleNumber(this.readBytes(len)));\n\n      // handle string with length stored inside the node itself\n    } else if ((nodeType & 0xe0) == 0) {\n      if (nodeType === 0) return '';\n      return this.readBytes(nodeType).toString();\n    }\n    errors.throwErr(errors.ERR_UNSUPPORTED_DATA_TYPE_IN_JSON, nodeType);\n  }\n\n  //---------------------------------------------------------------------------\n  // _getNumChildren()\n  //\n  // Returns the number of children a container has. This is determined by\n  // looking at the 4th and 5th most significant bits of the node type.\n  //\n  //   00 - number of children is uint8_t\n  //   01 - number of children is uint16_t\n  //   10 - number of children is uint32_t\n  //   11 - field ids are shared with another object whose offset follows\n  //\n  // In the latter case the value undefined is returned and the number of\n  // children must be read from the shared object at the specified offset.\n  //---------------------------------------------------------------------------\n  _getNumChildren(nodeType) {\n    const childrenBits = nodeType & 0x18;\n    if (childrenBits === 0) {\n      return this.readUInt8();\n    } else if (childrenBits === 0x08) {\n      return this.readUInt16BE();\n    } else if (childrenBits === 0x10) {\n      return this.readUInt32BE();\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _getOffset()\n  //\n  // Returns an offset. The offset will be either a 16-bit or 32-bit value\n  // depending on the value of the 3rd significant bit of the node type.\n  //---------------------------------------------------------------------------\n  _getOffset(nodeType) {\n    if (nodeType & 0x20) {\n      return this.readUInt32BE();\n    } else {\n      return this.readUInt16BE();\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _getFieldNames\n  //\n  // Reads the field names from the buffer.\n  //---------------------------------------------------------------------------\n  _getFieldNames(arrStartPos, numFields, offsetsSize, fieldNamesSegSize, fieldNamesSize) {\n    // skip the hash id array (1 byte * fieldNamesSize for each field)\n    this.skipBytes(numFields * fieldNamesSize);\n\n    // skip the field name offsets array for now\n    const offsetsPos = this.pos;\n    this.skipBytes(numFields * offsetsSize);\n    const ptr = this.readBytes(fieldNamesSegSize);\n    const finalPos = this.pos;\n\n    // determine the names of the fields\n    this.pos = offsetsPos;\n    let offset;\n    for (let i = arrStartPos; i < arrStartPos + numFields; i++) {\n      if (offsetsSize === 2) {\n        offset = this.readUInt16BE();\n      } else {\n        offset = this.readUInt32BE();\n      }\n\n      // get the field name object\n      let temp;\n      if (fieldNamesSize === 1) {\n        // Short Field Name\n        temp = ptr.readUInt8(offset);\n      } else {\n        // Long Field Name\n        temp = ptr.readUInt16BE(offset);\n      }\n      this.fieldNames[i] = ptr.subarray(offset + fieldNamesSize, offset + temp + fieldNamesSize).toString();\n    }\n    this.pos = finalPos;\n  }\n\n  //---------------------------------------------------------------------------\n  // decode()\n  //\n  // Decodes the OSON and returns a JavaScript object corresponding to its\n  // contents.\n  //---------------------------------------------------------------------------\n  decode() {\n    // parse root header\n    const magic = this.readBytes(3);\n    if (magic[0] !== constants.TNS_JSON_MAGIC_BYTE_1 || magic[1] !== constants.TNS_JSON_MAGIC_BYTE_2 || magic[2] !== constants.TNS_JSON_MAGIC_BYTE_3) {\n      errors.throwErr(errors.ERR_UNEXPECTED_DATA, magic.toString('hex'));\n    }\n    const version = this.readUInt8();\n    if (version !== constants.TNS_JSON_VERSION_MAX_FNAME_255 && version !== constants.TNS_JSON_VERSION_MAX_FNAME_65535) {\n      errors.throwErr(errors.ERR_OSON_VERSION_NOT_SUPPORTED, version);\n    }\n    const primaryFlags = this.readUInt16BE();\n    this.relativeOffsets = primaryFlags & constants.TNS_JSON_FLAG_REL_OFFSET_MODE;\n\n    // scalar values are much simpler\n    if (primaryFlags & constants.TNS_JSON_FLAG_IS_SCALAR) {\n      if (primaryFlags & constants.TNS_JSON_FLAG_TREE_SEG_UINT32) {\n        this.skipBytes(4);\n      } else {\n        this.skipBytes(2);\n      }\n      return this._decodeNode();\n    }\n\n    // determine the number of short field names\n    let numShortFieldNames;\n    if (primaryFlags & constants.TNS_JSON_FLAG_NUM_FNAMES_UINT32) {\n      numShortFieldNames = this.readUInt32BE();\n      this.fieldIdLength = 4;\n    } else if (primaryFlags & constants.TNS_JSON_FLAG_NUM_FNAMES_UINT16) {\n      numShortFieldNames = this.readUInt16BE();\n      this.fieldIdLength = 2;\n    } else {\n      numShortFieldNames = this.readUInt8();\n      this.fieldIdLength = 1;\n    }\n\n    // determine the size of the short field names segment\n    let shortFieldNameOffsetsSize, shortFieldNamesSegSize;\n    if (primaryFlags & constants.TNS_JSON_FLAG_FNAMES_SEG_UINT32) {\n      shortFieldNameOffsetsSize = 4;\n      shortFieldNamesSegSize = this.readUInt32BE();\n    } else {\n      shortFieldNameOffsetsSize = 2;\n      shortFieldNamesSegSize = this.readUInt16BE();\n    }\n\n    // if the version indicates that field names > 255 bytes exist, parse\n    // the information about that segment\n    let longFieldNameOffsetsSize, longFieldNamesSegSize;\n    let numLongFieldNames = 0;\n    if (version === constants.TNS_JSON_VERSION_MAX_FNAME_65535) {\n      const secondaryFlags = this.readUInt16BE();\n      if (secondaryFlags & constants.TNS_JSON_FLAG_SEC_FNAMES_SEG_UINT16) {\n        longFieldNameOffsetsSize = 2;\n      } else {\n        longFieldNameOffsetsSize = 4;\n      }\n      numLongFieldNames = this.readUInt32BE();\n      longFieldNamesSegSize = this.readUInt32BE();\n    }\n\n    // skip the size of the tree segment\n    if (primaryFlags & constants.TNS_JSON_FLAG_TREE_SEG_UINT32) {\n      this.skipBytes(4);\n    } else {\n      this.skipBytes(2);\n    }\n\n    // skip the number of \"tiny\" nodes\n    this.skipBytes(2);\n    this.fieldNames = new Array(numShortFieldNames + numLongFieldNames);\n\n    // if there are any short names, read them now\n    if (numShortFieldNames > 0) {\n      this._getFieldNames(0, numShortFieldNames, shortFieldNameOffsetsSize, shortFieldNamesSegSize, 1);\n    }\n\n    // if there are any long names, read them now\n    if (numLongFieldNames > 0) {\n      this._getFieldNames(numShortFieldNames, numLongFieldNames, longFieldNameOffsetsSize, longFieldNamesSegSize, 2);\n    }\n\n    // determine tree segment position in the buffer\n    this.treeSegPos = this.pos;\n\n    // decode the root node\n    return this._decodeNode();\n  }\n}\nclass OsonFieldName {\n  constructor(name, maxFieldNameSize) {\n    this.name = name;\n    this.nameBytes = Buffer.from(name);\n    if (this.nameBytes.length > maxFieldNameSize) {\n      errors.throwErr(errors.ERR_OSON_FIELD_NAME_LIMITATION, maxFieldNameSize);\n    }\n\n    // BigInt constants for calculating Hash ID for the OSON Field Name\n    const INITIAL_HASHID = 0x811C9DC5n;\n    const HASH_MULTIPLIER = 16777619n;\n    const HASH_MASK = 0xffffffffn;\n    this.hashId = INITIAL_HASHID;\n    for (let i = 0; i < this.nameBytes.length; i++) {\n      const c = BigInt(this.nameBytes[i]);\n      this.hashId = (this.hashId ^ c) * HASH_MULTIPLIER & HASH_MASK;\n    }\n    this.hashId = Number(this.hashId) & 0xff;\n  }\n}\nclass OsonFieldNamesSegment extends GrowableBuffer {\n  constructor() {\n    super();\n    this.fieldNames = [];\n  }\n\n  //---------------------------------------------------------------------------\n  // addName()\n  //\n  // Adds a name to the field names segment.\n  //---------------------------------------------------------------------------\n  addName(fieldName) {\n    fieldName.offset = this.pos;\n    if (fieldName.nameBytes.length <= 255) {\n      this.writeUInt8(fieldName.nameBytes.length);\n    } else {\n      this.writeUInt16BE(fieldName.nameBytes.length);\n    }\n    this.writeBytes(fieldName.nameBytes);\n    this.fieldNames.push(fieldName);\n  }\n\n  //---------------------------------------------------------------------------\n  // _processFieldNames()\n  //\n  // Processes the field names in preparation for encoding within OSON.\n  //---------------------------------------------------------------------------\n  _processFieldNames(fieldIdOffset) {\n    this.fieldNames.sort((a, b) => {\n      if (a.hashId < b.hashId) return -1;\n      if (a.hashId > b.hashId) return 1;\n      if (a.nameBytes.length < b.nameBytes.length) return -1;\n      if (a.nameBytes.length > b.nameBytes.length) return 1;\n      if (a.name < b.name) return -1;\n      if (a.name > b.name) return 1;\n      return 0;\n    });\n    for (let i = 0; i < this.fieldNames.length; i++) {\n      this.fieldNames[i].fieldId = fieldIdOffset + i + 1;\n    }\n    if (this.fieldNames.length < 256) {\n      this.fieldIdSize = 1;\n    } else if (this.fieldNames.length < 65536) {\n      this.fieldIdSize = 2;\n    } else {\n      this.fieldIdSize = 4;\n    }\n  }\n}\nclass OsonTreeSegment extends GrowableBuffer {\n  //---------------------------------------------------------------------------\n  // _encodeArray()\n  //\n  // Encodes an array in the OSON tree segment.\n  //---------------------------------------------------------------------------\n  _encodeArray(value, encoder) {\n    this._encodeContainer(constants.TNS_JSON_TYPE_ARRAY, value.length);\n    const len = value.length * 4;\n    const pos = this.reserveBytes(len);\n    let offsetsBufPos = pos;\n    for (const element of value) {\n      this.buf.writeUInt32BE(this.pos, offsetsBufPos);\n      offsetsBufPos += 4;\n      this.encodeNode(element, encoder);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _encodeContainer()\n  //\n  // Encodes the first part of a container (array or object) in the OSON tree\n  // segment.\n  //---------------------------------------------------------------------------\n  _encodeContainer(nodeType, numChildren) {\n    nodeType |= 0x20; // use uint32_t for offsets\n    if (numChildren > 65535) {\n      nodeType |= 0x10; // num children is uint32_t\n    } else if (numChildren > 255) {\n      nodeType |= 0x08; // num children is uint16_t\n    }\n    this.writeUInt8(nodeType);\n    if (numChildren < 256) {\n      this.writeUInt8(numChildren);\n    } else if (numChildren < 65536) {\n      this.writeUInt16BE(numChildren);\n    } else {\n      this.writeUInt32BE(numChildren);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _encodeObject()\n  //\n  // Encodes an object in the OSON tree segment.\n  //---------------------------------------------------------------------------\n  _encodeObject(value, encoder) {\n    const numChildren = value.values.length;\n    this._encodeContainer(constants.TNS_JSON_TYPE_OBJECT, numChildren);\n    let fieldIdOffset = this.pos;\n    let valueOffset = this.pos + numChildren * encoder.fieldIdSize;\n    const finalOffset = valueOffset + numChildren * 4;\n    this.reserveBytes(finalOffset - this.pos);\n    for (let i = 0; i < value.fields.length; i++) {\n      const fieldName = encoder.fieldNamesMap.get(value.fields[i]);\n      if (encoder.fieldIdSize == 1) {\n        this.buf[fieldIdOffset] = fieldName.fieldId;\n      } else if (encoder.fieldIdSize == 2) {\n        this.buf.writeUInt16BE(fieldName.fieldId, fieldIdOffset);\n      } else {\n        this.buf.writeUInt32BE(fieldName.fieldId, fieldIdOffset);\n      }\n      this.buf.writeUInt32BE(this.pos, valueOffset);\n      fieldIdOffset += encoder.fieldIdSize;\n      valueOffset += 4;\n      this.encodeNode(value.values[i], encoder);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // encodeNode()\n  //\n  // Encodes a value (node) in the OSON tree segment.\n  //---------------------------------------------------------------------------\n  encodeNode(value, encoder) {\n    // handle null\n    if (value === undefined || value === null) {\n      this.writeUInt8(constants.TNS_JSON_TYPE_NULL);\n\n      // handle booleans\n    } else if (typeof value === 'boolean') {\n      if (value) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_TRUE);\n      } else {\n        this.writeUInt8(constants.TNS_JSON_TYPE_FALSE);\n      }\n\n      // handle numbers\n    } else if (typeof value === 'number') {\n      this.writeUInt8(constants.TNS_JSON_TYPE_NUMBER_LENGTH_UINT8);\n      this.writeOracleNumber(value.toString());\n\n      // handle strings\n    } else if (typeof value === 'string') {\n      const buf = Buffer.from(value);\n      if (buf.length < 256) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_STRING_LENGTH_UINT8);\n        this.writeUInt8(buf.length);\n      } else if (buf.length < 65536) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_STRING_LENGTH_UINT16);\n        this.writeUInt16BE(buf.length);\n      } else {\n        this.writeUInt8(constants.TNS_JSON_TYPE_STRING_LENGTH_UINT32);\n        this.writeUInt32BE(buf.length);\n      }\n      if (buf.length > 0) {\n        this.writeBytes(buf);\n      }\n\n      // handle dates\n    } else if (util.types.isDate(value)) {\n      if (value.getUTCMilliseconds() === 0) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_TIMESTAMP7);\n        this.writeOracleDate(value, types.DB_TYPE_DATE, false);\n      } else {\n        this.writeUInt8(constants.TNS_JSON_TYPE_TIMESTAMP);\n        this.writeOracleDate(value, types.DB_TYPE_TIMESTAMP, false);\n      }\n\n      // handle buffers\n    } else if (Buffer.isBuffer(value)) {\n      if (value.length < 65536) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT16);\n        this.writeUInt16BE(value.length);\n      } else {\n        this.writeUInt8(constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT32);\n        this.writeUInt32BE(value.length);\n      }\n      this.writeBytes(value);\n\n      // handle arrays\n    } else if (Array.isArray(value)) {\n      this._encodeArray(value, encoder);\n\n      // handle vectors\n    } else if (nodbUtil.isVectorValue(value)) {\n      this.writeUInt8(constants.TNS_JSON_TYPE_EXTENDED);\n      this.writeUInt8(constants.TNS_JSON_TYPE_VECTOR);\n      const encoder = new vector.VectorEncoder();\n      const buf = encoder.encode(value);\n      this.writeUInt32BE(buf.length);\n      this.writeBytes(buf);\n    } else if (value instanceof types.JsonId) {\n      this.writeUInt8(constants.TNS_JSON_TYPE_ID);\n      this.writeUInt8(value.length);\n      this.writeBytes(Buffer.from(value.buffer));\n\n      // handle objects\n    } else {\n      this._encodeObject(value, encoder);\n    }\n  }\n}\n\n/**\n * Class used for encoding\n */\n\nclass OsonEncoder extends GrowableBuffer {\n  //---------------------------------------------------------------------------\n  // _addFieldName()\n  //\n  // Add a field with the given name.\n  //---------------------------------------------------------------------------\n  _addFieldName(name) {\n    const fieldName = new OsonFieldName(name, this.maxFieldNameSize);\n    this.fieldNamesMap.set(name, fieldName);\n    if (fieldName.nameBytes.length <= 255) {\n      this.shortFieldNamesSeg.addName(fieldName);\n    } else {\n      if (!this.longFieldNamesSeg) {\n        this.longFieldNamesSeg = new OsonFieldNamesSegment();\n      }\n      this.longFieldNamesSeg.addName(fieldName);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _examineNode()\n  //\n  // Examines the value. If it contains fields, unique names are retained. The\n  // values are then examined to see if they also contain fields. Arrays are\n  // examined to determine they contain elements that contain fields.\n  //---------------------------------------------------------------------------\n  _examineNode(value) {\n    if (Array.isArray(value)) {\n      for (const element of value) {\n        this._examineNode(element);\n      }\n    } else if (value && Array.isArray(value.fields)) {\n      for (let i = 0; i < value.fields.length; i++) {\n        const name = value.fields[i];\n        const element = value.values[i];\n        if (!this.fieldNamesMap.has(name)) {\n          this._addFieldName(name);\n        }\n        this._examineNode(element);\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _writeExtendedHeader()\n  //\n  // Write the extended header containing information about the short and long\n  // field name segments.\n  //---------------------------------------------------------------------------\n  _writeExtendedHeader() {\n    // write number of short field names\n    if (this.fieldIdSize === 1) {\n      this.writeUInt8(this.shortFieldNamesSeg.fieldNames.length);\n    } else if (this.fieldIdSize === 2) {\n      this.writeUInt16BE(this.shortFieldNamesSeg.fieldNames.length);\n    } else {\n      this.writeUInt32BE(this.shortFieldNamesSeg.fieldNames.length);\n    }\n\n    // write size of short field names segment\n    if (this.shortFieldNamesSeg.pos < 65536) {\n      this.writeUInt16BE(this.shortFieldNamesSeg.pos);\n    } else {\n      this.writeUInt32BE(this.shortFieldNamesSeg.pos);\n    }\n\n    // write fields for long field names segment, if applicable\n    if (this.longFieldNamesSeg) {\n      let secondaryFlags = 0;\n      if (this.longFieldNamesSeg.pos < 65536) {\n        secondaryFlags = constants.TNS_JSON_FLAG_SEC_FNAMES_SEG_UINT16;\n      }\n      this.writeUInt16BE(secondaryFlags);\n      this.writeUInt32BE(this.longFieldNamesSeg.fieldNames.length);\n      this.writeUInt32BE(this.longFieldNamesSeg.pos);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _writeFieldNamesSeg()\n  //\n  // Write the contents of the field names segment to the buffer.\n  //---------------------------------------------------------------------------\n  _writeFieldNamesSeg(fieldNamesSeg) {\n    // write array of hash ids\n    for (const fieldName of fieldNamesSeg.fieldNames) {\n      if (fieldName.nameBytes.length <= 255) {\n        this.writeUInt8(fieldName.hashId);\n      } else {\n        this.writeUInt16BE(fieldName.hashId);\n      }\n    }\n\n    // write array of field name offsets for the short field names\n    for (const fieldName of fieldNamesSeg.fieldNames) {\n      if (fieldNamesSeg.pos < 65536) {\n        this.writeUInt16BE(fieldName.offset);\n      } else {\n        this.writeUInt32BE(fieldName.offset);\n      }\n    }\n\n    // write field names\n    if (fieldNamesSeg.pos > 0) {\n      this.writeBytes(fieldNamesSeg.buf.subarray(0, fieldNamesSeg.pos));\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // encode()\n  //\n  // Encodes the value as OSON and returns a buffer containing the OSON bytes.\n  //---------------------------------------------------------------------------\n  encode(value, maxFieldNameSize) {\n    this.maxFieldNameSize = maxFieldNameSize;\n\n    // determine the flags to use\n    let flags = constants.TNS_JSON_FLAG_INLINE_LEAF;\n    if (Array.isArray(value) || value && Array.isArray(value.fields)) {\n      // examine all values recursively to determine the unique set of field\n      // names and whether they need to be added to the long field names\n      // segment (> 255 bytes) or short field names segment (<= 255 bytes)\n      this.fieldNamesMap = new Map();\n      this.shortFieldNamesSeg = new OsonFieldNamesSegment();\n      this._examineNode(value);\n\n      // perform processing of field names segments and determine the total\n      // number of unique field names in the value\n      let totalNumFieldNames = 0;\n      if (this.shortFieldNamesSeg) {\n        this.shortFieldNamesSeg._processFieldNames(0);\n        totalNumFieldNames += this.shortFieldNamesSeg.fieldNames.length;\n      }\n      if (this.longFieldNamesSeg) {\n        this.longFieldNamesSeg._processFieldNames(totalNumFieldNames);\n        totalNumFieldNames += this.longFieldNamesSeg.fieldNames.length;\n      }\n\n      // determine remaining flags and field id size\n      flags |= constants.TNS_JSON_FLAG_HASH_ID_UINT8 | constants.TNS_JSON_FLAG_TINY_NODES_STAT;\n      if (totalNumFieldNames > 65535) {\n        flags |= constants.TNS_JSON_FLAG_NUM_FNAMES_UINT32;\n        this.fieldIdSize = 4;\n      } else if (totalNumFieldNames > 255) {\n        flags |= constants.TNS_JSON_FLAG_NUM_FNAMES_UINT16;\n        this.fieldIdSize = 2;\n      } else {\n        this.fieldIdSize = 1;\n      }\n      if (this.shortFieldNamesSeg.pos > 65535) {\n        flags |= constants.TNS_JSON_FLAG_FNAMES_SEG_UINT32;\n      }\n    } else {\n      // if the value is a simple scalar\n      flags |= constants.TNS_JSON_FLAG_IS_SCALAR;\n    }\n\n    // encode values into the OSON tree segment\n    const treeSeg = new OsonTreeSegment();\n    treeSeg.encodeNode(value, this);\n    if (treeSeg.pos > 65535) {\n      flags |= constants.TNS_JSON_FLAG_TREE_SEG_UINT32;\n    }\n\n    // write initial header\n    this.writeUInt8(constants.TNS_JSON_MAGIC_BYTE_1);\n    this.writeUInt8(constants.TNS_JSON_MAGIC_BYTE_2);\n    this.writeUInt8(constants.TNS_JSON_MAGIC_BYTE_3);\n    if (this.longFieldNamesSeg) {\n      this.writeUInt8(constants.TNS_JSON_VERSION_MAX_FNAME_65535);\n    } else {\n      this.writeUInt8(constants.TNS_JSON_VERSION_MAX_FNAME_255);\n    }\n    this.writeUInt16BE(flags);\n\n    // write extended header (when value is not scalar)\n    if (this.shortFieldNamesSeg) {\n      this._writeExtendedHeader();\n    }\n\n    // write size of tree segment\n    if (treeSeg.pos < 65536) {\n      this.writeUInt16BE(treeSeg.pos);\n    } else {\n      this.writeUInt32BE(treeSeg.pos);\n    }\n\n    // write remainder of header and any data (when value is not scalar)\n    if (this.shortFieldNamesSeg) {\n      // write number of \"tiny\" nodes (always zero)\n      this.writeUInt16BE(0);\n\n      // write the field names segments\n      this._writeFieldNamesSeg(this.shortFieldNamesSeg);\n      if (this.longFieldNamesSeg) {\n        this._writeFieldNamesSeg(this.longFieldNamesSeg);\n      }\n    }\n\n    // write tree segment data\n    this.writeBytes(treeSeg.buf.subarray(0, treeSeg.pos));\n    return this.buf.subarray(0, this.pos);\n  }\n}\nmodule.exports = {\n  OsonDecoder,\n  OsonEncoder\n};","map":{"version":3,"names":["BaseBuffer","GrowableBuffer","require","Buffer","constants","errors","types","util","vector","nodbUtil","OsonDecoder","_decodeContainerNode","nodeType","container","offsetsPos","fieldIdsPos","containerOffset","pos","treeSegPos","numChildren","_getNumChildren","isObject","undefined","offset","_getOffset","sharedNodeType","readUInt8","Array","fieldIdLength","i","name","fieldId","buf","readUInt16BE","readUInt32BE","fieldNames","relativeOffsets","_decodeNode","TNS_JSON_TYPE_NULL","TNS_JSON_TYPE_TRUE","TNS_JSON_TYPE_FALSE","TNS_JSON_TYPE_DATE","TNS_JSON_TYPE_TIMESTAMP7","parseOracleDate","readBytes","TNS_JSON_TYPE_TIMESTAMP","TNS_JSON_TYPE_TIMESTAMP_TZ","TNS_JSON_TYPE_BINARY_FLOAT","parseBinaryFloat","TNS_JSON_TYPE_BINARY_DOUBLE","parseBinaryDouble","TNS_JSON_TYPE_STRING_LENGTH_UINT8","toString","TNS_JSON_TYPE_STRING_LENGTH_UINT16","TNS_JSON_TYPE_STRING_LENGTH_UINT32","TNS_JSON_TYPE_NUMBER_LENGTH_UINT8","parseFloat","readOracleNumber","TNS_JSON_TYPE_ID","jsonId","JsonId","length","copy","TNS_JSON_TYPE_BINARY_LENGTH_UINT16","from","TNS_JSON_TYPE_BINARY_LENGTH_UINT32","TNS_JSON_TYPE_EXTENDED","TNS_JSON_TYPE_VECTOR","vecImage","decoder","VectorDecoder","decode","typeBits","len","parseOracleNumber","throwErr","ERR_UNSUPPORTED_DATA_TYPE_IN_JSON","childrenBits","_getFieldNames","arrStartPos","numFields","offsetsSize","fieldNamesSegSize","fieldNamesSize","skipBytes","ptr","finalPos","temp","subarray","magic","TNS_JSON_MAGIC_BYTE_1","TNS_JSON_MAGIC_BYTE_2","TNS_JSON_MAGIC_BYTE_3","ERR_UNEXPECTED_DATA","version","TNS_JSON_VERSION_MAX_FNAME_255","TNS_JSON_VERSION_MAX_FNAME_65535","ERR_OSON_VERSION_NOT_SUPPORTED","primaryFlags","TNS_JSON_FLAG_REL_OFFSET_MODE","TNS_JSON_FLAG_IS_SCALAR","TNS_JSON_FLAG_TREE_SEG_UINT32","numShortFieldNames","TNS_JSON_FLAG_NUM_FNAMES_UINT32","TNS_JSON_FLAG_NUM_FNAMES_UINT16","shortFieldNameOffsetsSize","shortFieldNamesSegSize","TNS_JSON_FLAG_FNAMES_SEG_UINT32","longFieldNameOffsetsSize","longFieldNamesSegSize","numLongFieldNames","secondaryFlags","TNS_JSON_FLAG_SEC_FNAMES_SEG_UINT16","OsonFieldName","constructor","maxFieldNameSize","nameBytes","ERR_OSON_FIELD_NAME_LIMITATION","INITIAL_HASHID","HASH_MULTIPLIER","HASH_MASK","hashId","c","BigInt","Number","OsonFieldNamesSegment","addName","fieldName","writeUInt8","writeUInt16BE","writeBytes","push","_processFieldNames","fieldIdOffset","sort","a","b","fieldIdSize","OsonTreeSegment","_encodeArray","value","encoder","_encodeContainer","TNS_JSON_TYPE_ARRAY","reserveBytes","offsetsBufPos","element","writeUInt32BE","encodeNode","_encodeObject","values","TNS_JSON_TYPE_OBJECT","valueOffset","finalOffset","fields","fieldNamesMap","get","writeOracleNumber","isDate","getUTCMilliseconds","writeOracleDate","DB_TYPE_DATE","DB_TYPE_TIMESTAMP","isBuffer","isArray","isVectorValue","VectorEncoder","encode","buffer","OsonEncoder","_addFieldName","set","shortFieldNamesSeg","longFieldNamesSeg","_examineNode","has","_writeExtendedHeader","_writeFieldNamesSeg","fieldNamesSeg","flags","TNS_JSON_FLAG_INLINE_LEAF","Map","totalNumFieldNames","TNS_JSON_FLAG_HASH_ID_UINT8","TNS_JSON_FLAG_TINY_NODES_STAT","treeSeg","module","exports"],"sources":["C:/Users/Koliv/Desktop/Software/my-react-app/node_modules/oracledb/lib/impl/datahandlers/oson.js"],"sourcesContent":["// Copyright (c) 2023, 2024, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst { BaseBuffer, GrowableBuffer } = require('./buffer.js');\nconst { Buffer } = require('buffer');\nconst constants = require(\"./constants.js\");\nconst errors = require(\"../../errors.js\");\nconst types = require(\"../../types.js\");\nconst util = require(\"util\");\nconst vector = require(\"./vector.js\");\nconst nodbUtil = require(\"../../util.js\");\n\n/**\n * Class used for decoding\n */\nclass OsonDecoder extends BaseBuffer {\n\n  //---------------------------------------------------------------------------\n  // _decodeContainerNode()\n  //\n  // Decodes a container node (object or array) from the tree segment and\n  // returns the JavaScript equivalent.\n  //---------------------------------------------------------------------------\n  _decodeContainerNode(nodeType) {\n\n    // determine the number of children by examining the 4th and 5th most\n    // significant bits of the node type; determine the offsets in the tree\n    // segment to the field ids array and the value offsets array\n    let container, offsetsPos, fieldIdsPos;\n    const containerOffset = this.pos - this.treeSegPos - 1;\n    let numChildren = this._getNumChildren(nodeType);\n    const isObject = ((nodeType & 0x40) === 0);\n    if (numChildren === undefined) {\n      const offset = this._getOffset(nodeType);\n      offsetsPos = this.pos;\n      this.pos = this.treeSegPos + offset;\n      const sharedNodeType = this.readUInt8();\n      numChildren = this._getNumChildren(sharedNodeType);\n      container = (isObject) ? {} : new Array(numChildren);\n      fieldIdsPos = this.pos;\n    } else if (isObject) {\n      container = {};\n      fieldIdsPos = this.pos;\n      offsetsPos = this.pos + this.fieldIdLength * numChildren;\n    } else {\n      container = new Array(numChildren);\n      offsetsPos = this.pos;\n    }\n\n    for (let i = 0; i < numChildren; i++) {\n      let name;\n      if (isObject) {\n        let fieldId;\n        if (this.fieldIdLength === 1) {\n          fieldId = this.buf[fieldIdsPos];\n        } else if (this.fieldIdLength == 2) {\n          fieldId = this.buf.readUInt16BE(fieldIdsPos);\n        } else {\n          fieldId = this.buf.readUInt32BE(fieldIdsPos);\n        }\n        name = this.fieldNames[fieldId - 1];\n        fieldIdsPos += this.fieldIdLength;\n      }\n      this.pos = offsetsPos;\n      let offset = this._getOffset(nodeType);\n      if (this.relativeOffsets) {\n        offset += containerOffset;\n      }\n      offsetsPos = this.pos;\n      this.pos = this.treeSegPos + offset;\n      if (isObject) {\n        container[name] = this._decodeNode();\n      } else {\n        container[i] = this._decodeNode();\n      }\n    }\n\n    return container;\n  }\n\n  //---------------------------------------------------------------------------\n  // _decodeNode()\n  //\n  // Decodes a node from the tree segment and returns the JavaScript\n  // equivalent.\n  //---------------------------------------------------------------------------\n  _decodeNode() {\n\n    // if the most significant bit is set the node refers to a container\n    let nodeType = this.readUInt8();\n    if (nodeType & 0x80) {\n      return this._decodeContainerNode(nodeType);\n    }\n\n    // handle simple scalars\n    if (nodeType === constants.TNS_JSON_TYPE_NULL) {\n      return null;\n    } else if (nodeType === constants.TNS_JSON_TYPE_TRUE) {\n      return true;\n    } else if (nodeType === constants.TNS_JSON_TYPE_FALSE) {\n      return false;\n\n    // handle fixed length scalars\n    } else if (nodeType === constants.TNS_JSON_TYPE_DATE ||\n        nodeType === constants.TNS_JSON_TYPE_TIMESTAMP7) {\n      return this.parseOracleDate(this.readBytes(7));\n    } else if (nodeType === constants.TNS_JSON_TYPE_TIMESTAMP) {\n      return this.parseOracleDate(this.readBytes(11));\n    } else if (nodeType === constants.TNS_JSON_TYPE_TIMESTAMP_TZ) {\n      return this.parseOracleDate(this.readBytes(13));\n    } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_FLOAT) {\n      return this.parseBinaryFloat(this.readBytes(4));\n    } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_DOUBLE) {\n      return this.parseBinaryDouble(this.readBytes(8));\n\n    // handle scalars with lengths stored outside the node itself\n    } else if (nodeType === constants.TNS_JSON_TYPE_STRING_LENGTH_UINT8) {\n      return this.readBytes(this.readUInt8()).toString();\n    } else if (nodeType === constants.TNS_JSON_TYPE_STRING_LENGTH_UINT16) {\n      return this.readBytes(this.readUInt16BE()).toString();\n    } else if (nodeType === constants.TNS_JSON_TYPE_STRING_LENGTH_UINT32) {\n      return this.readBytes(this.readUInt32BE()).toString();\n    } else if (nodeType === constants.TNS_JSON_TYPE_NUMBER_LENGTH_UINT8) {\n      return parseFloat(this.readOracleNumber());\n    } else if (nodeType === constants.TNS_JSON_TYPE_ID) {\n      const buf = this.readBytes(this.readUInt8());\n      const jsonId = new types.JsonId(buf.length);\n      buf.copy(jsonId);\n      return jsonId;\n    } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT16) {\n      return Buffer.from(this.readBytes(this.readUInt16BE()));\n    } else if (nodeType === constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT32) {\n      return Buffer.from(this.readBytes(this.readUInt32BE()));\n    } else if (nodeType === constants.TNS_JSON_TYPE_EXTENDED) {\n      nodeType = this.readUInt8();\n      if (nodeType === constants.TNS_JSON_TYPE_VECTOR) {\n        const vecImage = this.readBytes(this.readUInt32BE());\n        const decoder = new vector.VectorDecoder(vecImage);\n        return decoder.decode();\n      }\n    }\n\n    // handle number/decimal with length stored inside the node itself\n    const typeBits = nodeType & 0xf0;\n    if (typeBits === 0x20 || typeBits === 0x60) {\n      const len = nodeType & 0x0f;\n      return parseFloat(this.parseOracleNumber(this.readBytes(len + 1)));\n\n    // handle integer with length stored inside the node itself\n    } else if (typeBits === 0x40 || typeBits === 0x50) {\n      const len = nodeType & 0x0f;\n      return parseFloat(this.parseOracleNumber(this.readBytes(len)));\n\n    // handle string with length stored inside the node itself\n    } else if ((nodeType & 0xe0) == 0) {\n      if (nodeType === 0)\n        return '';\n      return this.readBytes(nodeType).toString();\n    }\n\n    errors.throwErr(errors.ERR_UNSUPPORTED_DATA_TYPE_IN_JSON, nodeType);\n  }\n\n  //---------------------------------------------------------------------------\n  // _getNumChildren()\n  //\n  // Returns the number of children a container has. This is determined by\n  // looking at the 4th and 5th most significant bits of the node type.\n  //\n  //   00 - number of children is uint8_t\n  //   01 - number of children is uint16_t\n  //   10 - number of children is uint32_t\n  //   11 - field ids are shared with another object whose offset follows\n  //\n  // In the latter case the value undefined is returned and the number of\n  // children must be read from the shared object at the specified offset.\n  //---------------------------------------------------------------------------\n  _getNumChildren(nodeType) {\n    const childrenBits = (nodeType & 0x18);\n    if (childrenBits === 0) {\n      return this.readUInt8();\n    } else if (childrenBits === 0x08) {\n      return this.readUInt16BE();\n    } else if (childrenBits === 0x10) {\n      return this.readUInt32BE();\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _getOffset()\n  //\n  // Returns an offset. The offset will be either a 16-bit or 32-bit value\n  // depending on the value of the 3rd significant bit of the node type.\n  //---------------------------------------------------------------------------\n  _getOffset(nodeType) {\n    if (nodeType & 0x20) {\n      return this.readUInt32BE();\n    } else {\n      return this.readUInt16BE();\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _getFieldNames\n  //\n  // Reads the field names from the buffer.\n  //---------------------------------------------------------------------------\n  _getFieldNames(arrStartPos, numFields, offsetsSize, fieldNamesSegSize, fieldNamesSize) {\n\n    // skip the hash id array (1 byte * fieldNamesSize for each field)\n    this.skipBytes(numFields * fieldNamesSize);\n\n    // skip the field name offsets array for now\n    const offsetsPos = this.pos;\n    this.skipBytes(numFields * offsetsSize);\n    const ptr = this.readBytes(fieldNamesSegSize);\n    const finalPos = this.pos;\n\n    // determine the names of the fields\n    this.pos = offsetsPos;\n    let offset;\n    for (let i = arrStartPos; i < arrStartPos + numFields; i++) {\n      if (offsetsSize === 2) {\n        offset = this.readUInt16BE();\n      } else {\n        offset = this.readUInt32BE();\n      }\n\n      // get the field name object\n      let temp;\n      if (fieldNamesSize === 1) {\n        // Short Field Name\n        temp = ptr.readUInt8(offset);\n      } else {\n        // Long Field Name\n        temp = ptr.readUInt16BE(offset);\n      }\n      this.fieldNames[i] = ptr.subarray(offset + fieldNamesSize, offset + temp + fieldNamesSize).toString();\n    }\n    this.pos = finalPos;\n  }\n\n  //---------------------------------------------------------------------------\n  // decode()\n  //\n  // Decodes the OSON and returns a JavaScript object corresponding to its\n  // contents.\n  //---------------------------------------------------------------------------\n  decode() {\n\n    // parse root header\n    const magic = this.readBytes(3);\n    if (magic[0] !== constants.TNS_JSON_MAGIC_BYTE_1 ||\n        magic[1] !== constants.TNS_JSON_MAGIC_BYTE_2 ||\n        magic[2] !== constants.TNS_JSON_MAGIC_BYTE_3) {\n      errors.throwErr(errors.ERR_UNEXPECTED_DATA, magic.toString('hex'));\n    }\n    const version = this.readUInt8();\n    if (version !== constants.TNS_JSON_VERSION_MAX_FNAME_255 &&\n        version !== constants.TNS_JSON_VERSION_MAX_FNAME_65535) {\n      errors.throwErr(errors.ERR_OSON_VERSION_NOT_SUPPORTED, version);\n    }\n    const primaryFlags = this.readUInt16BE();\n    this.relativeOffsets = primaryFlags & constants.TNS_JSON_FLAG_REL_OFFSET_MODE;\n\n    // scalar values are much simpler\n    if (primaryFlags & constants.TNS_JSON_FLAG_IS_SCALAR) {\n      if (primaryFlags & constants.TNS_JSON_FLAG_TREE_SEG_UINT32) {\n        this.skipBytes(4);\n      } else {\n        this.skipBytes(2);\n      }\n      return this._decodeNode();\n    }\n\n    // determine the number of short field names\n    let numShortFieldNames;\n    if (primaryFlags & constants.TNS_JSON_FLAG_NUM_FNAMES_UINT32) {\n      numShortFieldNames = this.readUInt32BE();\n      this.fieldIdLength = 4;\n    } else if (primaryFlags & constants.TNS_JSON_FLAG_NUM_FNAMES_UINT16) {\n      numShortFieldNames = this.readUInt16BE();\n      this.fieldIdLength = 2;\n    } else {\n      numShortFieldNames = this.readUInt8();\n      this.fieldIdLength = 1;\n    }\n\n    // determine the size of the short field names segment\n    let shortFieldNameOffsetsSize, shortFieldNamesSegSize;\n    if (primaryFlags & constants.TNS_JSON_FLAG_FNAMES_SEG_UINT32) {\n      shortFieldNameOffsetsSize = 4;\n      shortFieldNamesSegSize = this.readUInt32BE();\n    } else {\n      shortFieldNameOffsetsSize = 2;\n      shortFieldNamesSegSize = this.readUInt16BE();\n    }\n\n    // if the version indicates that field names > 255 bytes exist, parse\n    // the information about that segment\n    let longFieldNameOffsetsSize, longFieldNamesSegSize;\n    let numLongFieldNames = 0;\n    if (version === constants.TNS_JSON_VERSION_MAX_FNAME_65535) {\n      const secondaryFlags = this.readUInt16BE();\n      if (secondaryFlags & constants.TNS_JSON_FLAG_SEC_FNAMES_SEG_UINT16) {\n        longFieldNameOffsetsSize = 2;\n      } else {\n        longFieldNameOffsetsSize = 4;\n      }\n      numLongFieldNames = this.readUInt32BE();\n      longFieldNamesSegSize = this.readUInt32BE();\n    }\n\n    // skip the size of the tree segment\n    if (primaryFlags & constants.TNS_JSON_FLAG_TREE_SEG_UINT32) {\n      this.skipBytes(4);\n    } else {\n      this.skipBytes(2);\n    }\n\n    // skip the number of \"tiny\" nodes\n    this.skipBytes(2);\n\n    this.fieldNames = new Array(numShortFieldNames + numLongFieldNames);\n\n    // if there are any short names, read them now\n    if (numShortFieldNames > 0) {\n      this._getFieldNames(0, numShortFieldNames,\n        shortFieldNameOffsetsSize, shortFieldNamesSegSize, 1);\n    }\n\n    // if there are any long names, read them now\n    if (numLongFieldNames > 0) {\n      this._getFieldNames(numShortFieldNames, numLongFieldNames,\n        longFieldNameOffsetsSize, longFieldNamesSegSize, 2);\n    }\n\n    // determine tree segment position in the buffer\n    this.treeSegPos = this.pos;\n\n    // decode the root node\n    return this._decodeNode();\n  }\n\n}\n\nclass OsonFieldName {\n\n  constructor(name, maxFieldNameSize) {\n    this.name = name;\n    this.nameBytes = Buffer.from(name);\n    if (this.nameBytes.length > maxFieldNameSize) {\n      errors.throwErr(errors.ERR_OSON_FIELD_NAME_LIMITATION, maxFieldNameSize);\n    }\n\n    // BigInt constants for calculating Hash ID for the OSON Field Name\n    const INITIAL_HASHID = 0x811C9DC5n;\n    const HASH_MULTIPLIER = 16777619n;\n    const HASH_MASK = 0xffffffffn;\n\n    this.hashId = INITIAL_HASHID;\n    for (let i = 0; i < this.nameBytes.length; i++) {\n      const c = BigInt(this.nameBytes[i]);\n      this.hashId = ((this.hashId ^ c) * HASH_MULTIPLIER) & HASH_MASK;\n    }\n    this.hashId = Number(this.hashId) & 0xff;\n  }\n\n}\n\nclass OsonFieldNamesSegment extends GrowableBuffer {\n\n  constructor() {\n    super();\n    this.fieldNames = [];\n  }\n\n  //---------------------------------------------------------------------------\n  // addName()\n  //\n  // Adds a name to the field names segment.\n  //---------------------------------------------------------------------------\n  addName(fieldName) {\n    fieldName.offset = this.pos;\n    if (fieldName.nameBytes.length <= 255) {\n      this.writeUInt8(fieldName.nameBytes.length);\n    } else {\n      this.writeUInt16BE(fieldName.nameBytes.length);\n    }\n    this.writeBytes(fieldName.nameBytes);\n    this.fieldNames.push(fieldName);\n  }\n\n  //---------------------------------------------------------------------------\n  // _processFieldNames()\n  //\n  // Processes the field names in preparation for encoding within OSON.\n  //---------------------------------------------------------------------------\n  _processFieldNames(fieldIdOffset) {\n    this.fieldNames.sort((a, b) => {\n      if (a.hashId < b.hashId)\n        return -1;\n      if (a.hashId > b.hashId)\n        return 1;\n      if (a.nameBytes.length < b.nameBytes.length)\n        return -1;\n      if (a.nameBytes.length > b.nameBytes.length)\n        return 1;\n      if (a.name < b.name)\n        return -1;\n      if (a.name > b.name)\n        return 1;\n      return 0;\n    });\n    for (let i = 0; i < this.fieldNames.length; i++) {\n      this.fieldNames[i].fieldId = fieldIdOffset + i + 1;\n    }\n    if (this.fieldNames.length < 256) {\n      this.fieldIdSize = 1;\n    } else if (this.fieldNames.length < 65536) {\n      this.fieldIdSize = 2;\n    } else {\n      this.fieldIdSize = 4;\n    }\n  }\n\n}\n\nclass OsonTreeSegment extends GrowableBuffer {\n\n  //---------------------------------------------------------------------------\n  // _encodeArray()\n  //\n  // Encodes an array in the OSON tree segment.\n  //---------------------------------------------------------------------------\n  _encodeArray(value, encoder) {\n    this._encodeContainer(constants.TNS_JSON_TYPE_ARRAY, value.length);\n    const len = value.length * 4;\n    const pos = this.reserveBytes(len);\n    let offsetsBufPos = pos;\n    for (const element of value) {\n      this.buf.writeUInt32BE(this.pos, offsetsBufPos);\n      offsetsBufPos += 4;\n      this.encodeNode(element, encoder);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _encodeContainer()\n  //\n  // Encodes the first part of a container (array or object) in the OSON tree\n  // segment.\n  //---------------------------------------------------------------------------\n  _encodeContainer(nodeType, numChildren) {\n    nodeType |= 0x20;                   // use uint32_t for offsets\n    if (numChildren > 65535) {\n      nodeType |= 0x10;                 // num children is uint32_t\n    } else if (numChildren > 255) {\n      nodeType |= 0x08;                 // num children is uint16_t\n    }\n    this.writeUInt8(nodeType);\n    if (numChildren < 256) {\n      this.writeUInt8(numChildren);\n    } else if (numChildren < 65536) {\n      this.writeUInt16BE(numChildren);\n    } else {\n      this.writeUInt32BE(numChildren);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _encodeObject()\n  //\n  // Encodes an object in the OSON tree segment.\n  //---------------------------------------------------------------------------\n  _encodeObject(value, encoder) {\n    const numChildren = value.values.length;\n    this._encodeContainer(constants.TNS_JSON_TYPE_OBJECT, numChildren);\n    let fieldIdOffset = this.pos;\n    let valueOffset = this.pos + (numChildren * encoder.fieldIdSize);\n    const finalOffset = valueOffset + numChildren * 4;\n    this.reserveBytes(finalOffset - this.pos);\n\n    for (let i = 0; i < value.fields.length; i++) {\n      const fieldName = encoder.fieldNamesMap.get(value.fields[i]);\n      if (encoder.fieldIdSize == 1) {\n        this.buf[fieldIdOffset] = fieldName.fieldId;\n      } else if (encoder.fieldIdSize == 2) {\n        this.buf.writeUInt16BE(fieldName.fieldId, fieldIdOffset);\n      } else {\n        this.buf.writeUInt32BE(fieldName.fieldId, fieldIdOffset);\n      }\n      this.buf.writeUInt32BE(this.pos, valueOffset);\n      fieldIdOffset += encoder.fieldIdSize;\n      valueOffset += 4;\n      this.encodeNode(value.values[i], encoder);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // encodeNode()\n  //\n  // Encodes a value (node) in the OSON tree segment.\n  //---------------------------------------------------------------------------\n  encodeNode(value, encoder) {\n\n    // handle null\n    if (value === undefined || value === null) {\n      this.writeUInt8(constants.TNS_JSON_TYPE_NULL);\n\n    // handle booleans\n    } else if (typeof value === 'boolean') {\n      if (value) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_TRUE);\n      } else {\n        this.writeUInt8(constants.TNS_JSON_TYPE_FALSE);\n      }\n\n    // handle numbers\n    } else if (typeof value === 'number') {\n      this.writeUInt8(constants.TNS_JSON_TYPE_NUMBER_LENGTH_UINT8);\n      this.writeOracleNumber(value.toString());\n\n    // handle strings\n    } else if (typeof value === 'string') {\n      const buf = Buffer.from(value);\n      if (buf.length < 256) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_STRING_LENGTH_UINT8);\n        this.writeUInt8(buf.length);\n      } else if (buf.length < 65536) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_STRING_LENGTH_UINT16);\n        this.writeUInt16BE(buf.length);\n      } else {\n        this.writeUInt8(constants.TNS_JSON_TYPE_STRING_LENGTH_UINT32);\n        this.writeUInt32BE(buf.length);\n      }\n      if (buf.length > 0) {\n        this.writeBytes(buf);\n      }\n\n    // handle dates\n    } else if (util.types.isDate(value)) {\n      if (value.getUTCMilliseconds() === 0) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_TIMESTAMP7);\n        this.writeOracleDate(value, types.DB_TYPE_DATE, false);\n      } else {\n        this.writeUInt8(constants.TNS_JSON_TYPE_TIMESTAMP);\n        this.writeOracleDate(value, types.DB_TYPE_TIMESTAMP, false);\n      }\n\n    // handle buffers\n    } else if (Buffer.isBuffer(value)) {\n      if (value.length < 65536) {\n        this.writeUInt8(constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT16);\n        this.writeUInt16BE(value.length);\n      } else {\n        this.writeUInt8(constants.TNS_JSON_TYPE_BINARY_LENGTH_UINT32);\n        this.writeUInt32BE(value.length);\n      }\n      this.writeBytes(value);\n\n    // handle arrays\n    } else if (Array.isArray(value)) {\n      this._encodeArray(value, encoder);\n\n    // handle vectors\n    } else if (nodbUtil.isVectorValue(value)) {\n      this.writeUInt8(constants.TNS_JSON_TYPE_EXTENDED);\n      this.writeUInt8(constants.TNS_JSON_TYPE_VECTOR);\n      const encoder = new vector.VectorEncoder();\n      const buf = encoder.encode(value);\n      this.writeUInt32BE(buf.length);\n      this.writeBytes(buf);\n\n    } else if (value instanceof types.JsonId) {\n      this.writeUInt8(constants.TNS_JSON_TYPE_ID);\n      this.writeUInt8(value.length);\n      this.writeBytes(Buffer.from(value.buffer));\n\n    // handle objects\n    } else {\n      this._encodeObject(value, encoder);\n    }\n\n  }\n\n}\n\n/**\n * Class used for encoding\n */\n\nclass OsonEncoder extends GrowableBuffer {\n\n  //---------------------------------------------------------------------------\n  // _addFieldName()\n  //\n  // Add a field with the given name.\n  //---------------------------------------------------------------------------\n  _addFieldName(name) {\n    const fieldName = new OsonFieldName(name, this.maxFieldNameSize);\n    this.fieldNamesMap.set(name, fieldName);\n    if (fieldName.nameBytes.length <= 255) {\n      this.shortFieldNamesSeg.addName(fieldName);\n    } else {\n      if (!this.longFieldNamesSeg) {\n        this.longFieldNamesSeg = new OsonFieldNamesSegment();\n      }\n      this.longFieldNamesSeg.addName(fieldName);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _examineNode()\n  //\n  // Examines the value. If it contains fields, unique names are retained. The\n  // values are then examined to see if they also contain fields. Arrays are\n  // examined to determine they contain elements that contain fields.\n  //---------------------------------------------------------------------------\n  _examineNode(value) {\n    if (Array.isArray(value)) {\n      for (const element of value) {\n        this._examineNode(element);\n      }\n    } else if (value && Array.isArray(value.fields)) {\n      for (let i = 0; i < value.fields.length; i++) {\n        const name = value.fields[i];\n        const element = value.values[i];\n        if (!this.fieldNamesMap.has(name)) {\n          this._addFieldName(name);\n        }\n        this._examineNode(element);\n      }\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _writeExtendedHeader()\n  //\n  // Write the extended header containing information about the short and long\n  // field name segments.\n  //---------------------------------------------------------------------------\n  _writeExtendedHeader() {\n    // write number of short field names\n    if (this.fieldIdSize === 1) {\n      this.writeUInt8(this.shortFieldNamesSeg.fieldNames.length);\n    } else if (this.fieldIdSize === 2) {\n      this.writeUInt16BE(this.shortFieldNamesSeg.fieldNames.length);\n    } else {\n      this.writeUInt32BE(this.shortFieldNamesSeg.fieldNames.length);\n    }\n\n    // write size of short field names segment\n    if (this.shortFieldNamesSeg.pos < 65536) {\n      this.writeUInt16BE(this.shortFieldNamesSeg.pos);\n    } else {\n      this.writeUInt32BE(this.shortFieldNamesSeg.pos);\n    }\n\n    // write fields for long field names segment, if applicable\n    if (this.longFieldNamesSeg) {\n      let secondaryFlags = 0;\n      if (this.longFieldNamesSeg.pos < 65536) {\n        secondaryFlags = constants.TNS_JSON_FLAG_SEC_FNAMES_SEG_UINT16;\n      }\n      this.writeUInt16BE(secondaryFlags);\n      this.writeUInt32BE(this.longFieldNamesSeg.fieldNames.length);\n      this.writeUInt32BE(this.longFieldNamesSeg.pos);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // _writeFieldNamesSeg()\n  //\n  // Write the contents of the field names segment to the buffer.\n  //---------------------------------------------------------------------------\n  _writeFieldNamesSeg(fieldNamesSeg) {\n    // write array of hash ids\n    for (const fieldName of fieldNamesSeg.fieldNames) {\n      if (fieldName.nameBytes.length <= 255) {\n        this.writeUInt8(fieldName.hashId);\n      } else {\n        this.writeUInt16BE(fieldName.hashId);\n      }\n    }\n\n    // write array of field name offsets for the short field names\n    for (const fieldName of fieldNamesSeg.fieldNames) {\n      if (fieldNamesSeg.pos < 65536) {\n        this.writeUInt16BE(fieldName.offset);\n      } else {\n        this.writeUInt32BE(fieldName.offset);\n      }\n    }\n\n    // write field names\n    if (fieldNamesSeg.pos > 0) {\n      this.writeBytes(fieldNamesSeg.buf.subarray(0, fieldNamesSeg.pos));\n    }\n\n  }\n\n  //---------------------------------------------------------------------------\n  // encode()\n  //\n  // Encodes the value as OSON and returns a buffer containing the OSON bytes.\n  //---------------------------------------------------------------------------\n  encode(value, maxFieldNameSize) {\n\n    this.maxFieldNameSize = maxFieldNameSize;\n\n    // determine the flags to use\n    let flags = constants.TNS_JSON_FLAG_INLINE_LEAF;\n    if (Array.isArray(value) || (value && Array.isArray(value.fields))) {\n      // examine all values recursively to determine the unique set of field\n      // names and whether they need to be added to the long field names\n      // segment (> 255 bytes) or short field names segment (<= 255 bytes)\n      this.fieldNamesMap = new Map();\n      this.shortFieldNamesSeg = new OsonFieldNamesSegment();\n      this._examineNode(value);\n\n      // perform processing of field names segments and determine the total\n      // number of unique field names in the value\n      let totalNumFieldNames = 0;\n      if (this.shortFieldNamesSeg) {\n        this.shortFieldNamesSeg._processFieldNames(0);\n        totalNumFieldNames += this.shortFieldNamesSeg.fieldNames.length;\n      }\n      if (this.longFieldNamesSeg) {\n        this.longFieldNamesSeg._processFieldNames(totalNumFieldNames);\n        totalNumFieldNames += this.longFieldNamesSeg.fieldNames.length;\n      }\n\n      // determine remaining flags and field id size\n      flags |= constants.TNS_JSON_FLAG_HASH_ID_UINT8 |\n        constants.TNS_JSON_FLAG_TINY_NODES_STAT;\n      if (totalNumFieldNames > 65535) {\n        flags |= constants.TNS_JSON_FLAG_NUM_FNAMES_UINT32;\n        this.fieldIdSize = 4;\n      } else if (totalNumFieldNames > 255) {\n        flags |= constants.TNS_JSON_FLAG_NUM_FNAMES_UINT16;\n        this.fieldIdSize = 2;\n      } else {\n        this.fieldIdSize = 1;\n      }\n      if (this.shortFieldNamesSeg.pos > 65535) {\n        flags |= constants.TNS_JSON_FLAG_FNAMES_SEG_UINT32;\n      }\n    } else {\n      // if the value is a simple scalar\n      flags |= constants.TNS_JSON_FLAG_IS_SCALAR;\n    }\n\n    // encode values into the OSON tree segment\n    const treeSeg = new OsonTreeSegment();\n    treeSeg.encodeNode(value, this);\n    if (treeSeg.pos > 65535) {\n      flags |= constants.TNS_JSON_FLAG_TREE_SEG_UINT32;\n    }\n\n    // write initial header\n    this.writeUInt8(constants.TNS_JSON_MAGIC_BYTE_1);\n    this.writeUInt8(constants.TNS_JSON_MAGIC_BYTE_2);\n    this.writeUInt8(constants.TNS_JSON_MAGIC_BYTE_3);\n    if (this.longFieldNamesSeg) {\n      this.writeUInt8(constants.TNS_JSON_VERSION_MAX_FNAME_65535);\n    } else {\n      this.writeUInt8(constants.TNS_JSON_VERSION_MAX_FNAME_255);\n    }\n    this.writeUInt16BE(flags);\n\n    // write extended header (when value is not scalar)\n    if (this.shortFieldNamesSeg) {\n      this._writeExtendedHeader();\n    }\n\n    // write size of tree segment\n    if (treeSeg.pos < 65536) {\n      this.writeUInt16BE(treeSeg.pos);\n    } else {\n      this.writeUInt32BE(treeSeg.pos);\n    }\n\n    // write remainder of header and any data (when value is not scalar)\n    if (this.shortFieldNamesSeg) {\n\n      // write number of \"tiny\" nodes (always zero)\n      this.writeUInt16BE(0);\n\n      // write the field names segments\n      this._writeFieldNamesSeg(this.shortFieldNamesSeg);\n      if (this.longFieldNamesSeg) {\n        this._writeFieldNamesSeg(this.longFieldNamesSeg);\n      }\n    }\n\n    // write tree segment data\n    this.writeBytes(treeSeg.buf.subarray(0, treeSeg.pos));\n\n    return this.buf.subarray(0, this.pos);\n  }\n\n}\n\nmodule.exports = {\n  OsonDecoder,\n  OsonEncoder\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}