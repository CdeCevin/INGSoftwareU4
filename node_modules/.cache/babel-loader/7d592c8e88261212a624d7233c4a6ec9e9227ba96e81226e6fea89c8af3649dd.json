{"ast":null,"code":"// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst MessageWithData = require(\"./withData.js\");\nconst constants = require(\"../constants.js\");\nconst errors = require(\"../../../errors.js\");\n\n/**\n *\n * Executes OALL8 RPC function\n *\n * @class ExecuteMessage\n * @extends {MessageWithData}\n */\nclass ExecuteMessage extends MessageWithData {\n  /**\n   *\n   * @param {object} statement\n   * @param {object} options\n   */\n  constructor(connection, statement, options, resultSet) {\n    super(connection, statement, options);\n    if (!resultSet && statement.isQuery) {\n      resultSet = connection._createResultSet(options, statement);\n    }\n    this.resultSet = resultSet;\n    this.functionCode = constants.TNS_FUNC_EXECUTE;\n    this.bindParams = undefined;\n    this.currentRow = 0;\n  }\n\n  //-------------------------------------------------------------------------\n  // writeReExecuteMessage()\n  //\n  // Write the message for a full execute.\n  //-------------------------------------------------------------------------\n  writeExecuteMessage(buf) {\n    let options = 0x0;\n    let dmlOptions = 0;\n    let numParams = 0;\n    let numIters = 1;\n    // Configuring the options field thats send to the server\n    const stmt = this.statement;\n    const params = stmt.bindInfoList;\n    if (this.noImplicitRelease) {\n      dmlOptions |= constants.TNS_EXEC_OPTION_NO_IMPL_REL;\n    }\n    if (!stmt.requiresDefine && !this.parseOnly && params) {\n      numParams = params.length;\n    }\n    if (stmt.requiresDefine) {\n      options |= constants.TNS_EXEC_OPTION_DEFINE;\n    } else if (!this.parseOnly && stmt.sql) {\n      dmlOptions |= constants.TNS_EXEC_OPTION_IMPLICIT_RESULTSET;\n      options |= constants.TNS_EXEC_OPTION_EXECUTE;\n    }\n    if (stmt.cursorId === 0 || stmt.isDdl) {\n      options |= constants.TNS_EXEC_OPTION_PARSE;\n    }\n    if (stmt.isQuery) {\n      if (this.parseOnly) {\n        options |= constants.TNS_EXEC_OPTION_DESCRIBE;\n      } else {\n        if (stmt.cursorId === 0 || stmt.requiresDefine) {\n          numIters = this.options.prefetchRows;\n        } else {\n          numIters = this.options.fetchArraySize;\n        }\n        if (numIters > 0 && !stmt.noPrefetch) {\n          options |= constants.TNS_EXEC_OPTION_FETCH;\n        }\n      }\n    }\n    if (!stmt.isPlSql && !this.parseOnly) {\n      options |= constants.TNS_EXEC_OPTION_NOT_PLSQL;\n    } else if (stmt.isPlSql && numParams > 0) {\n      options |= constants.TNS_EXEC_OPTION_PLSQL_BIND;\n    }\n    if (numParams > 0) {\n      options |= constants.TNS_EXEC_OPTION_BIND;\n    }\n    if (this.batchErrors) {\n      options |= constants.TNS_EXEC_OPTION_BATCH_ERRORS;\n    }\n    if (this.arrayDmlRowCounts) {\n      dmlOptions = constants.TNS_EXEC_OPTION_DML_ROWCOUNTS;\n    }\n    if (this.options.autoCommit) {\n      options |= constants.TNS_EXEC_OPTION_COMMIT;\n    }\n    this.writePiggybacks(buf);\n    this.writeFunctionHeader(buf);\n    buf.writeUB4(options); // execute options\n    buf.writeUB4(stmt.cursorId); // cursor id\n    if (stmt.cursorId === 0 || stmt.isDdl) {\n      buf.writeUInt8(1); // pointer (cursor id)\n      buf.writeUB4(stmt.sqlLength);\n    } else {\n      buf.writeUInt8(0); // pointer (cursor id)\n      buf.writeUB4(0);\n    }\n    buf.writeUInt8(1); // pointer (vector)\n    buf.writeUB4(13); // al8i4 array length\n    buf.writeUInt8(0); // pointer (al8o4)\n    buf.writeUInt8(0); // pointer (al8o4l)\n    buf.writeUInt8(0); // prefetc buffer size\n    buf.writeUB4(numIters); // prefetch num rows\n    buf.writeUB4(constants.TNS_MAX_LONG_LENGTH); // maximum long size\n    if (numParams === 0) {\n      buf.writeUInt8(0); // pointer (binds)\n      buf.writeUB4(0); // number of binds\n    } else {\n      buf.writeUInt8(1); // pointer (binds)\n      buf.writeUB4(numParams); // number of binds\n    }\n    buf.writeUInt8(0); // pointer (al8pp)\n    buf.writeUInt8(0); // pointer (al8txn)\n    buf.writeUInt8(0); // pointer (al8txl)\n    buf.writeUInt8(0); // pointer (al8kv)\n    buf.writeUInt8(0); // pointer (al8kvl)\n    if (stmt.requiresDefine) {\n      buf.writeUInt8(1); // pointer (al8doac)\n      buf.writeUB4(this.statement.queryVars.length); // number of defines\n    } else {\n      buf.writeUInt8(0);\n      buf.writeUB4(0);\n    }\n    buf.writeUB4(0); // registration id\n    buf.writeUInt8(0); // pointer (al8objlist)\n    buf.writeUInt8(1); // pointer (al8objlen)\n    buf.writeUInt8(0); // pointer (al8blv)\n    buf.writeUB4(0); // al8blv\n    buf.writeUInt8(0); // pointer (al8dnam)\n    buf.writeUB4(0); // al8dnaml\n    buf.writeUB4(0); // al8regid_msb\n    if (this.arrayDmlRowCounts) {\n      buf.writeUInt8(1); // pointer (al8pidmlrc)\n      buf.writeUB4(this.numExecs); // al8pidmlrcbl\n      buf.writeUInt8(1); // pointer (al8pidmlrcl)\n    } else {\n      buf.writeUInt8(0); // pointer (al8pidmlrc)\n      buf.writeUB4(0); // al8pidmlrcbl\n      buf.writeUInt8(0); // pointer (al8pidmlrcl)\n    }\n    if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_12_2) {\n      buf.writeUInt8(0); // pointer (al8sqlsig)\n      buf.writeUB4(0); // SQL signature length\n      buf.writeUInt8(0); // pointer (SQL ID)\n      buf.writeUB4(0); // allocated size of SQL ID\n      buf.writeUInt8(0); // pointer (length of SQL ID)\n      if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_12_2_EXT1) {\n        buf.writeUInt8(0); // pointer (chunk ids)\n        buf.writeUB4(0); // number of chunk ids\n      }\n    }\n    if (stmt.cursorId === 0 || stmt.isDdl) {\n      if (stmt.sql) {\n        buf.writeBytesWithLength(stmt.sqlBytes);\n        buf.writeUB4(1); // al8i4[0] parse\n      } else {\n        errors.throwErr(errors.ERR_INVALID_REF_CURSOR);\n      }\n    } else {\n      buf.writeUB4(0); // al8i4[0] parse\n    }\n    if (stmt.isQuery) {\n      if (stmt.cursorId === 0) {\n        buf.writeUB4(0); // al8i4[1] execution count\n      } else {\n        buf.writeUB4(numIters);\n      }\n    } else {\n      buf.writeUB4(this.numExecs); // al8i4[1] execution count\n    }\n    buf.writeUB4(0); // al8i4[2]\n    buf.writeUB4(0); // al8i4[3]\n    buf.writeUB4(0); // al8i4[4]\n    buf.writeUB4(0); // al8i4[5] SCN (part 1)\n    buf.writeUB4(0); // al8i4[6] SCN (part 2)\n    buf.writeUB4(stmt.isQuery ? 1 : 0); // al8i4[7] is query\n    buf.writeUB4(0); // al8i4[8]\n    buf.writeUB4(dmlOptions); // al8i4[9] DML row counts/implicit\n    buf.writeUB4(0); // al8i4[10]\n    buf.writeUB4(0); // al8i4[11]\n    buf.writeUB4(0); // al8i4[12]\n\n    /*\n     * write column metadata and bind params\n     */\n    if (stmt.requiresDefine) {\n      this.writeColumnMetadata(buf, this.statement.queryVars);\n    } else if (numParams > 0) {\n      return this.processBindParams(buf, params);\n    }\n  }\n\n  //-------------------------------------------------------------------------\n  // writeReExecuteMessage()\n  //\n  // Write the message header for a re-execute and return the bind parameters.\n  //-------------------------------------------------------------------------\n  writeReExecuteMessage(buf) {\n    const stmt = this.statement;\n    let params = stmt.bindInfoList;\n    let execFlag1 = 0,\n      execFlag2 = 0,\n      numIters;\n    if (params !== undefined) {\n      if (!stmt.isQuery) {\n        this.outVariables = [];\n        params.forEach(info => {\n          if (info.bindDir !== constants.TNS_BIND_DIR_INPUT) {\n            this.outVariables.push(info.bindVar);\n          }\n        });\n      }\n      const tmpparams = [];\n      params.forEach(info => {\n        if (info.bindDir !== constants.TNS_BIND_DIR_OUTPUT && !info.isReturnBind) {\n          tmpparams.push(info);\n        }\n      });\n      params = tmpparams;\n    }\n    if (this.functionCode === constants.TNS_FUNC_REEXECUTE_AND_FETCH) {\n      execFlag1 |= constants.TNS_EXEC_OPTION_EXECUTE;\n      numIters = this.options.prefetchRows;\n    } else {\n      if (this.options.autoCommit) {\n        execFlag2 |= constants.TNS_EXEC_OPTION_COMMIT_REEXECUTE;\n      }\n      numIters = this.numExecs;\n    }\n    this.writePiggybacks(buf);\n    this.writeFunctionHeader(buf);\n    buf.writeUB4(stmt.cursorId);\n    buf.writeUB4(numIters);\n    buf.writeUB4(execFlag1);\n    buf.writeUB4(execFlag2);\n    return params;\n  }\n\n  //-------------------------------------------------------------------------\n  // encode()\n  //\n  // Write the execute message to the buffer. Two types of execute messages\n  // are possible: one for a full execute and the second, simpler message,\n  // for when an existing cursor is being re-executed.\n  //-------------------------------------------------------------------------\n  encode(buf) {\n    // no rows have yet been sent so the header information needs to be sent\n    if (this.currentRow === 0) {\n      const stmt = this.statement;\n      if (stmt.cursorId !== 0 && !stmt.requiresFullExecute && !this.parseOnly && !stmt.requiresDefine && !stmt.noPrefetch && !stmt.isDdl && !this.batchErrors) {\n        if (stmt.isQuery && this.options.prefetchRows > 0) {\n          this.functionCode = constants.TNS_FUNC_REEXECUTE_AND_FETCH;\n        } else {\n          this.functionCode = constants.TNS_FUNC_REEXECUTE;\n        }\n        this.bindParams = this.writeReExecuteMessage(buf);\n      } else {\n        this.functionCode = constants.TNS_FUNC_EXECUTE;\n        this.bindParams = this.writeExecuteMessage(buf);\n      }\n    }\n\n    // if any bind parameters need to be sent, do that\n    // after each row is sent, check to see whether a pause should be performed\n    if (this.bindParams && this.bindParams.length > 0) {\n      const adapter = buf.nsi.ntAdapter;\n      while (this.currentRow < this.numExecs) {\n        buf.writeUInt8(constants.TNS_MSG_TYPE_ROW_DATA);\n        this.writeBindParamsRow(buf, this.bindParams, this.currentRow);\n        this.currentRow++;\n        if (this.currentRow < this.numExecs && adapter.shouldPauseWrite()) return true;\n      }\n    }\n\n    // reset state in case message is resent\n    this.currentRow = 0;\n    this.bindParams = undefined;\n  }\n}\nmodule.exports = ExecuteMessage;","map":{"version":3,"names":["MessageWithData","require","constants","errors","ExecuteMessage","constructor","connection","statement","options","resultSet","isQuery","_createResultSet","functionCode","TNS_FUNC_EXECUTE","bindParams","undefined","currentRow","writeExecuteMessage","buf","dmlOptions","numParams","numIters","stmt","params","bindInfoList","noImplicitRelease","TNS_EXEC_OPTION_NO_IMPL_REL","requiresDefine","parseOnly","length","TNS_EXEC_OPTION_DEFINE","sql","TNS_EXEC_OPTION_IMPLICIT_RESULTSET","TNS_EXEC_OPTION_EXECUTE","cursorId","isDdl","TNS_EXEC_OPTION_PARSE","TNS_EXEC_OPTION_DESCRIBE","prefetchRows","fetchArraySize","noPrefetch","TNS_EXEC_OPTION_FETCH","isPlSql","TNS_EXEC_OPTION_NOT_PLSQL","TNS_EXEC_OPTION_PLSQL_BIND","TNS_EXEC_OPTION_BIND","batchErrors","TNS_EXEC_OPTION_BATCH_ERRORS","arrayDmlRowCounts","TNS_EXEC_OPTION_DML_ROWCOUNTS","autoCommit","TNS_EXEC_OPTION_COMMIT","writePiggybacks","writeFunctionHeader","writeUB4","writeUInt8","sqlLength","TNS_MAX_LONG_LENGTH","queryVars","numExecs","caps","ttcFieldVersion","TNS_CCAP_FIELD_VERSION_12_2","TNS_CCAP_FIELD_VERSION_12_2_EXT1","writeBytesWithLength","sqlBytes","throwErr","ERR_INVALID_REF_CURSOR","writeColumnMetadata","processBindParams","writeReExecuteMessage","execFlag1","execFlag2","outVariables","forEach","info","bindDir","TNS_BIND_DIR_INPUT","push","bindVar","tmpparams","TNS_BIND_DIR_OUTPUT","isReturnBind","TNS_FUNC_REEXECUTE_AND_FETCH","TNS_EXEC_OPTION_COMMIT_REEXECUTE","encode","requiresFullExecute","TNS_FUNC_REEXECUTE","adapter","nsi","ntAdapter","TNS_MSG_TYPE_ROW_DATA","writeBindParamsRow","shouldPauseWrite","module","exports"],"sources":["C:/Users/Koliv/Desktop/Software/my-react-app/node_modules/oracledb/lib/thin/protocol/messages/execute.js"],"sourcesContent":["// Copyright (c) 2022, 2023, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst MessageWithData = require(\"./withData.js\");\nconst constants = require(\"../constants.js\");\nconst errors = require(\"../../../errors.js\");\n\n/**\n *\n * Executes OALL8 RPC function\n *\n * @class ExecuteMessage\n * @extends {MessageWithData}\n */\nclass ExecuteMessage extends MessageWithData {\n  /**\n   *\n   * @param {object} statement\n   * @param {object} options\n   */\n  constructor(connection, statement, options, resultSet) {\n    super(connection, statement, options);\n    if (!resultSet && statement.isQuery) {\n      resultSet = connection._createResultSet(options, statement);\n    }\n    this.resultSet = resultSet;\n    this.functionCode = constants.TNS_FUNC_EXECUTE;\n    this.bindParams = undefined;\n    this.currentRow = 0;\n  }\n\n  //-------------------------------------------------------------------------\n  // writeReExecuteMessage()\n  //\n  // Write the message for a full execute.\n  //-------------------------------------------------------------------------\n  writeExecuteMessage(buf) {\n    let options = 0x0;\n    let dmlOptions = 0;\n    let numParams = 0;\n    let numIters = 1;\n    // Configuring the options field thats send to the server\n    const stmt = this.statement;\n    const params = stmt.bindInfoList;\n\n    if (this.noImplicitRelease) {\n      dmlOptions |= constants.TNS_EXEC_OPTION_NO_IMPL_REL;\n    }\n\n    if (!stmt.requiresDefine && !this.parseOnly && params) {\n      numParams = params.length;\n    }\n    if (stmt.requiresDefine) {\n      options |= constants.TNS_EXEC_OPTION_DEFINE;\n    } else if (!this.parseOnly && stmt.sql) {\n      dmlOptions |= constants.TNS_EXEC_OPTION_IMPLICIT_RESULTSET;\n      options |= constants.TNS_EXEC_OPTION_EXECUTE;\n    }\n    if (stmt.cursorId === 0 || stmt.isDdl) {\n      options |= constants.TNS_EXEC_OPTION_PARSE;\n    }\n    if (stmt.isQuery) {\n      if (this.parseOnly) {\n        options |= constants.TNS_EXEC_OPTION_DESCRIBE;\n      } else {\n        if (stmt.cursorId === 0 || stmt.requiresDefine) {\n          numIters = this.options.prefetchRows;\n        } else {\n          numIters = this.options.fetchArraySize;\n        }\n        if (numIters > 0 && !stmt.noPrefetch) {\n          options |= constants.TNS_EXEC_OPTION_FETCH;\n        }\n      }\n    }\n    if (!stmt.isPlSql && !this.parseOnly) {\n      options |= constants.TNS_EXEC_OPTION_NOT_PLSQL;\n    } else if (stmt.isPlSql && numParams > 0) {\n      options |= constants.TNS_EXEC_OPTION_PLSQL_BIND;\n    }\n    if (numParams > 0) {\n      options |= constants.TNS_EXEC_OPTION_BIND;\n    }\n    if (this.batchErrors) {\n      options |= constants.TNS_EXEC_OPTION_BATCH_ERRORS;\n    }\n    if (this.arrayDmlRowCounts) {\n      dmlOptions = constants.TNS_EXEC_OPTION_DML_ROWCOUNTS;\n    }\n    if (this.options.autoCommit) {\n      options |= constants.TNS_EXEC_OPTION_COMMIT;\n    }\n    this.writePiggybacks(buf);\n    this.writeFunctionHeader(buf);\n    buf.writeUB4(options);                           // execute options\n    buf.writeUB4(stmt.cursorId);                     // cursor id\n    if (stmt.cursorId === 0 || stmt.isDdl) {\n      buf.writeUInt8(1);                             // pointer (cursor id)\n      buf.writeUB4(stmt.sqlLength);\n    } else {\n      buf.writeUInt8(0);                             // pointer (cursor id)\n      buf.writeUB4(0);\n    }\n    buf.writeUInt8(1);                               // pointer (vector)\n    buf.writeUB4(13);                                // al8i4 array length\n    buf.writeUInt8(0);                               // pointer (al8o4)\n    buf.writeUInt8(0);                               // pointer (al8o4l)\n    buf.writeUInt8(0);                               // prefetc buffer size\n    buf.writeUB4(numIters);                          // prefetch num rows\n    buf.writeUB4(constants.TNS_MAX_LONG_LENGTH);     // maximum long size\n    if (numParams === 0) {\n      buf.writeUInt8(0);                             // pointer (binds)\n      buf.writeUB4(0);                               // number of binds\n    } else {\n      buf.writeUInt8(1);                             // pointer (binds)\n      buf.writeUB4(numParams);                       // number of binds\n    }\n    buf.writeUInt8(0);                               // pointer (al8pp)\n    buf.writeUInt8(0);                               // pointer (al8txn)\n    buf.writeUInt8(0);                               // pointer (al8txl)\n    buf.writeUInt8(0);                               // pointer (al8kv)\n    buf.writeUInt8(0);                               // pointer (al8kvl)\n    if (stmt.requiresDefine) {\n      buf.writeUInt8(1);                             // pointer (al8doac)\n      buf.writeUB4(this.statement.queryVars.length);     // number of defines\n    } else {\n      buf.writeUInt8(0);\n      buf.writeUB4(0);\n    }\n    buf.writeUB4(0);                                 // registration id\n    buf.writeUInt8(0);                               // pointer (al8objlist)\n    buf.writeUInt8(1);                               // pointer (al8objlen)\n    buf.writeUInt8(0);                               // pointer (al8blv)\n    buf.writeUB4(0);                                 // al8blv\n    buf.writeUInt8(0);                               // pointer (al8dnam)\n    buf.writeUB4(0);                                 // al8dnaml\n    buf.writeUB4(0);                                 // al8regid_msb\n    if (this.arrayDmlRowCounts) {\n      buf.writeUInt8(1);                             // pointer (al8pidmlrc)\n      buf.writeUB4(this.numExecs);                   // al8pidmlrcbl\n      buf.writeUInt8(1);                             // pointer (al8pidmlrcl)\n    } else {\n      buf.writeUInt8(0);                             // pointer (al8pidmlrc)\n      buf.writeUB4(0);                               // al8pidmlrcbl\n      buf.writeUInt8(0);                             // pointer (al8pidmlrcl)\n    }\n    if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_12_2) {\n      buf.writeUInt8(0);                             // pointer (al8sqlsig)\n      buf.writeUB4(0);                               // SQL signature length\n      buf.writeUInt8(0);                             // pointer (SQL ID)\n      buf.writeUB4(0);                               // allocated size of SQL ID\n      buf.writeUInt8(0);                             // pointer (length of SQL ID)\n      if (buf.caps.ttcFieldVersion >= constants.TNS_CCAP_FIELD_VERSION_12_2_EXT1) {\n        buf.writeUInt8(0);                           // pointer (chunk ids)\n        buf.writeUB4(0);                             // number of chunk ids\n      }\n    }\n    if (stmt.cursorId === 0 || stmt.isDdl) {\n      if (stmt.sql) {\n        buf.writeBytesWithLength(stmt.sqlBytes);\n        buf.writeUB4(1);                             // al8i4[0] parse\n      } else {\n        errors.throwErr(errors.ERR_INVALID_REF_CURSOR);\n      }\n    } else {\n      buf.writeUB4(0);                               // al8i4[0] parse\n    }\n    if (stmt.isQuery) {\n      if (stmt.cursorId === 0) {\n        buf.writeUB4(0);                             // al8i4[1] execution count\n      } else {\n        buf.writeUB4(numIters);\n      }\n    } else {\n      buf.writeUB4(this.numExecs);                   // al8i4[1] execution count\n    }\n    buf.writeUB4(0);                                 // al8i4[2]\n    buf.writeUB4(0);                                 // al8i4[3]\n    buf.writeUB4(0);                                 // al8i4[4]\n    buf.writeUB4(0);                                 // al8i4[5] SCN (part 1)\n    buf.writeUB4(0);                                 // al8i4[6] SCN (part 2)\n    buf.writeUB4((stmt.isQuery) ? 1 : 0);            // al8i4[7] is query\n    buf.writeUB4(0);                                 // al8i4[8]\n    buf.writeUB4(dmlOptions);                        // al8i4[9] DML row counts/implicit\n    buf.writeUB4(0);                                 // al8i4[10]\n    buf.writeUB4(0);                                 // al8i4[11]\n    buf.writeUB4(0);                                 // al8i4[12]\n\n    /*\n     * write column metadata and bind params\n     */\n    if (stmt.requiresDefine) {\n      this.writeColumnMetadata(buf, this.statement.queryVars);\n    } else if (numParams > 0) {\n      return this.processBindParams(buf, params);\n    }\n  }\n\n  //-------------------------------------------------------------------------\n  // writeReExecuteMessage()\n  //\n  // Write the message header for a re-execute and return the bind parameters.\n  //-------------------------------------------------------------------------\n  writeReExecuteMessage(buf) {\n    const stmt = this.statement;\n    let params = stmt.bindInfoList;\n    let execFlag1 = 0, execFlag2 = 0, numIters;\n    if (params !== undefined) {\n      if (!stmt.isQuery) {\n        this.outVariables = [];\n        params.forEach(info => {\n          if (info.bindDir !== constants.TNS_BIND_DIR_INPUT) {\n            this.outVariables.push(info.bindVar);\n          }\n        });\n      }\n\n      const tmpparams = [];\n      params.forEach(info => {\n        if (info.bindDir !== constants.TNS_BIND_DIR_OUTPUT && !info.isReturnBind) {\n          tmpparams.push(info);\n        }\n      });\n      params = tmpparams;\n    }\n\n    if (this.functionCode === constants.TNS_FUNC_REEXECUTE_AND_FETCH) {\n      execFlag1 |= constants.TNS_EXEC_OPTION_EXECUTE;\n      numIters = this.options.prefetchRows;\n    } else {\n      if (this.options.autoCommit) {\n        execFlag2 |= constants.TNS_EXEC_OPTION_COMMIT_REEXECUTE;\n      }\n      numIters = this.numExecs;\n    }\n    this.writePiggybacks(buf);\n    this.writeFunctionHeader(buf);\n    buf.writeUB4(stmt.cursorId);\n    buf.writeUB4(numIters);\n    buf.writeUB4(execFlag1);\n    buf.writeUB4(execFlag2);\n    return params;\n  }\n\n  //-------------------------------------------------------------------------\n  // encode()\n  //\n  // Write the execute message to the buffer. Two types of execute messages\n  // are possible: one for a full execute and the second, simpler message,\n  // for when an existing cursor is being re-executed.\n  //-------------------------------------------------------------------------\n  encode(buf) {\n\n    // no rows have yet been sent so the header information needs to be sent\n    if (this.currentRow === 0) {\n      const stmt = this.statement;\n      if (stmt.cursorId !== 0 && !stmt.requiresFullExecute && !this.parseOnly && !stmt.requiresDefine && !stmt.noPrefetch && !stmt.isDdl && !this.batchErrors) {\n        if (stmt.isQuery && this.options.prefetchRows > 0) {\n          this.functionCode = constants.TNS_FUNC_REEXECUTE_AND_FETCH;\n        } else {\n          this.functionCode = constants.TNS_FUNC_REEXECUTE;\n        }\n        this.bindParams = this.writeReExecuteMessage(buf);\n      } else {\n        this.functionCode = constants.TNS_FUNC_EXECUTE;\n        this.bindParams = this.writeExecuteMessage(buf);\n      }\n    }\n\n    // if any bind parameters need to be sent, do that\n    // after each row is sent, check to see whether a pause should be performed\n    if (this.bindParams && this.bindParams.length > 0) {\n      const adapter = buf.nsi.ntAdapter;\n      while (this.currentRow < this.numExecs) {\n        buf.writeUInt8(constants.TNS_MSG_TYPE_ROW_DATA);\n        this.writeBindParamsRow(buf, this.bindParams, this.currentRow);\n        this.currentRow++;\n        if (this.currentRow < this.numExecs && adapter.shouldPauseWrite())\n          return true;\n      }\n    }\n\n    // reset state in case message is resent\n    this.currentRow = 0;\n    this.bindParams = undefined;\n\n  }\n\n}\n\nmodule.exports = ExecuteMessage;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}