{"ast":null,"code":"// Copyright (c) 2022, 2024, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst PoolImpl = require('../impl/pool.js');\nconst ThinConnectionImpl = require('./connection.js');\nconst protocolUtil = require('./protocol/utils.js');\nconst errors = require('../errors.js');\nconst settings = require('../settings.js');\nconst util = require('../util.js');\nconst thinUtil = require('./util.js');\nconst {\n  getConnectionInfo\n} = require('./sqlnet/networkSession.js');\nconst crypto = require('crypto');\nconst EventEmitter = require('events');\nconst Timers = require('timers');\nclass ThinPoolImpl extends PoolImpl {\n  _init(params) {\n    if (!params.homogeneous) {\n      errors.throwErr(errors.ERR_NOT_IMPLEMENTED, 'Heterogeneous Pooling');\n    }\n    thinUtil.checkCredentials(params);\n    this._availableObjects = [];\n    this._name = 'node-thin';\n    this._poolMin = params.poolMin;\n    this._poolMax = params.poolMax;\n    this._poolIncrement = params.poolIncrement;\n    this._poolTimeout = params.poolTimeout;\n    this._poolPingInterval = params.poolPingInterval;\n    this._poolPingTimeout = params.poolPingTimeout;\n    this._stmtCacheSize = params.stmtCacheSize;\n\n    // The user Config filterd from common layer is cached except\n    // sensitive data as sensitive data is obfuscated in the pool\n    // and de-obfuscated as necessary.\n    this._userConfig = params;\n    this._freeConnectionList = [];\n    this._usedConnectionList = new Set();\n    this._password = params.password;\n    this._walletPassword = params.walletPassword;\n    this._walletContent = params.walletContent;\n    this._obfuscatedPassword = [];\n    this._obfuscatedWalletPassword = [];\n    this._token = params.token;\n    this._obfuscatedToken = [];\n    this._privateKey = params.privateKey;\n    this._obfuscatedPrivateKey = [];\n    this._schedulerJob = null;\n    this._poolCloseWaiter = null;\n    this._pendingRequests = [];\n\n    // password obfuscation\n    if (this._password !== undefined) {\n      const obj = protocolUtil.setObfuscatedValue(this._password);\n      this._password = obj.value;\n      this._obfuscatedPassword = obj.obfuscatedValue;\n      this._userConfig.password = null;\n    }\n    // wallet password obfuscation\n    if (this._walletPassword !== undefined) {\n      const obj = protocolUtil.setObfuscatedValue(this._walletPassword);\n      this._walletPassword = obj.value;\n      this._obfuscatedWalletPassword = obj.obfuscatedValue;\n      this._userConfig.walletPassword = null;\n    }\n    // wallet content obfuscation\n    if (this._walletContent !== undefined) {\n      const obj = protocolUtil.setObfuscatedValue(this._walletContent);\n      this._walletContent = obj.value;\n      this._obfuscatedWalletContent = obj.obfuscatedValue;\n      this._userConfig.walletConent = null;\n    }\n    // token obfuscation\n    if (this._token !== undefined) {\n      const obj = protocolUtil.setObfuscatedValue(this._token);\n      this._token = obj.value;\n      this._obfuscatedToken = obj.obfuscatedValue;\n      this._userConfig.token = null;\n    }\n    // privateKey obfuscation\n    if (this._privateKey !== undefined) {\n      const obj = protocolUtil.setObfuscatedValue(this._privateKey);\n      this._privateKey = obj.value;\n      this._obfuscatedPrivateKey = obj.obfuscatedValue;\n      this._userConfig.privateKey = null;\n    }\n    this._accessTokenFn = params.accessTokenFn;\n    this._accessTokenConfig = params.accessTokenConfig;\n    this._isDRCPEnabled = false;\n    this._implicitPool = null;\n    this.eventEmitter = new EventEmitter();\n    // listener to remove dead or idle connections\n    this.eventEmitter.on('_removePoolConnection', async connImpl => {\n      await this._destroy(connImpl);\n    });\n  }\n\n  //---------------------------------------------------------------------------\n  // create pool with specified parameters and miminum number of connections as\n  // specified by poolMin\n  //---------------------------------------------------------------------------\n  async create(params) {\n    this._init(params);\n    this._userConfig._connInfo = await getConnectionInfo(params);\n    this._isDRCPEnabled = String(this._userConfig._connInfo[0]).toLowerCase() === 'pooled';\n    // generate connection class when none is provided by user\n    if (this._isDRCPEnabled && settings.connectionClass === '') {\n      this._generateConnectionClass();\n    }\n\n    // create a background task. It will create minimum connections in the pool\n    // and expand the pool as required.\n    this.bgThreadFunc();\n  }\n\n  //---------------------------------------------------------------------------\n  // set new token and private key in pool\n  //---------------------------------------------------------------------------\n  setAccessToken(params) {\n    if (params.token) {\n      this._token = params.token;\n      const objToken = protocolUtil.setObfuscatedValue(this._token);\n      this._token = objToken.value;\n      this._obfuscatedToken = objToken.obfuscatedValue;\n    }\n    if (params.privateKey) {\n      this._privateKey = params.privateKey;\n      const objKey = protocolUtil.setObfuscatedValue(this._privateKey);\n      this._privateKey = objKey.value;\n      this._obfuscatedPrivateKey = objKey.obfuscatedValue;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // credentials are obfuscated and stored in an object(userConfig) during\n  // pool creation. _getConnAttrs() method is used to deobfuscate encrypted\n  // credentials for creating new connections\n  //---------------------------------------------------------------------------\n  async _getConnAttrs() {\n    let accessToken;\n    const clonedAttrs = Object.assign({}, this._userConfig);\n    // deobfuscate password\n    if (clonedAttrs.password === null) {\n      clonedAttrs.password = protocolUtil.getDeobfuscatedValue(this._password, this._obfuscatedPassword);\n    }\n\n    // deobfuscate wallet password\n    if (clonedAttrs.walletPassword === null) {\n      clonedAttrs.walletPassword = protocolUtil.getDeobfuscatedValue(this._walletPassword, this._obfuscatedWalletPassword);\n    }\n\n    // deobfuscate wallet content\n    if (clonedAttrs.walletContent === null) {\n      clonedAttrs.walletContent = protocolUtil.getDeobfuscatedValue(this._walletContent, this._obfuscatedWalletContent);\n    }\n\n    // deobfuscate token and private key\n    // check for token expiry\n    if (clonedAttrs.token === null) {\n      clonedAttrs.token = protocolUtil.getDeobfuscatedValue(this._token, this._obfuscatedToken);\n      if (util.isTokenExpired(clonedAttrs.token)) {\n        if (typeof this._accessTokenFn === 'function') {\n          accessToken = await this._accessTokenFn(true, this._accessTokenConfig);\n          if (typeof accessToken === 'string') {\n            clonedAttrs.token = accessToken;\n            if (util.isTokenExpired(clonedAttrs.token)) {\n              // OAuth2 token is expired\n              errors.throwErr(errors.ERR_TOKEN_HAS_EXPIRED);\n            } else {\n              // update pool with OAuth2 token\n              const obj = protocolUtil.setObfuscatedValue(clonedAttrs.token);\n              this._token = obj.value;\n              this._obfuscatedToken = obj.obfuscatedValue;\n            }\n          } else if (typeof accessToken === 'object') {\n            clonedAttrs.token = accessToken.token;\n            clonedAttrs.privateKey = accessToken.privateKey;\n            if (util.isTokenExpired(clonedAttrs.token)) {\n              // IAM token is expired\n              errors.throwErr(errors.ERR_TOKEN_HAS_EXPIRED);\n            } else {\n              // update pool with IAM token and private key\n              const objToken = protocolUtil.setObfuscatedValue(clonedAttrs.token);\n              this._token = objToken.value;\n              this._obfuscatedToken = objToken.obfuscatedValue;\n              const objKey = protocolUtil.setObfuscatedValue(clonedAttrs.privateKey);\n              this._privateKey = objKey.value;\n              this._obfuscatedPrivateKey = objKey.obfuscatedValue;\n            }\n          }\n        } else {\n          errors.throwErr(errors.ERR_TOKEN_HAS_EXPIRED);\n        }\n      }\n    }\n    if (clonedAttrs.privateKey === null) {\n      clonedAttrs.privateKey = protocolUtil.getDeobfuscatedValue(this._privateKey, this._obfuscatedPrivateKey);\n    }\n    return clonedAttrs;\n  }\n\n  //---------------------------------------------------------------------------\n  // return available connection if present in pool else\n  // create new connection and return it\n  //---------------------------------------------------------------------------\n  async getConnection() {\n    return await this.acquire();\n  }\n\n  //---------------------------------------------------------------------------\n  // destroy connection when pool close operation is called\n  //---------------------------------------------------------------------------\n  async _destroy(connection) {\n    if (connection.nscon.ntAdapter.connected) {\n      connection._dropSess = true;\n      await connection.close();\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // close pool by destroying available connections\n  //---------------------------------------------------------------------------\n  async close() {\n    // wait till background task for pool expansion is finished; if it is not\n    // currently running, wake it up!\n    await new Promise(resolve => {\n      this._poolCloseWaiter = resolve;\n      if (this.bgWaiter) {\n        this.bgWaiter();\n      }\n    });\n\n    // clear scheduled job\n    if (this._schedulerJob) {\n      clearTimeout(this._schedulerJob);\n      this._schedulerJob = null;\n    }\n\n    // destroy all free connections\n    for (const conn of this._freeConnectionList) {\n      await this._destroy(conn);\n    }\n\n    // destroy all used connections\n    for (const conn of this._usedConnectionList) {\n      await this._destroy(conn);\n    }\n    this.eventEmitter.removeAllListeners();\n  }\n\n  //---------------------------------------------------------------------------\n  // returns poolMax from configuration\n  //---------------------------------------------------------------------------\n  getPoolMax() {\n    return this._poolMax;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns poolMin from configuration\n  //---------------------------------------------------------------------------\n  getPoolMin() {\n    return this._poolMin;\n  }\n\n  //---------------------------------------------------------------------------\n  // get number of used connection\n  //---------------------------------------------------------------------------\n  getConnectionsInUse() {\n    return this._usedConnectionList.size;\n  }\n\n  //---------------------------------------------------------------------------\n  // get number of free connection\n  //---------------------------------------------------------------------------\n  getConnectionsOpen() {\n    return this._freeConnectionList.length + this._usedConnectionList.size;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns poolIncrement from configuration\n  //---------------------------------------------------------------------------\n  getPoolIncrement() {\n    return this._poolIncrement;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns maximum number of connections allowed per shard in the pool\n  //---------------------------------------------------------------------------\n  getPoolMaxPerShard() {\n    return;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns the pool ping interval (seconds)\n  //---------------------------------------------------------------------------\n  getPoolPingInterval() {\n    return this._poolPingInterval;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns the pool ping Timeout (milliseconds)\n  //---------------------------------------------------------------------------\n  getPoolPingTimeout() {\n    return this._poolPingTimeout;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns the pool timeout\n  //---------------------------------------------------------------------------\n  getPoolTimeout() {\n    return this._poolTimeout;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns whether the SODA metadata cache is enabled or not\n  //---------------------------------------------------------------------------\n  getSodaMetaDataCache() {\n    return;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns the statement cache size associate with the pool\n  //---------------------------------------------------------------------------\n  getStmtCacheSize() {\n    return this._stmtCacheSize;\n  }\n\n  //---------------------------------------------------------------------------\n  // _setScheduler()\n  //\n  // set scheduler to scan and remove idle connections\n  //---------------------------------------------------------------------------\n  _setScheduler() {\n    if (!this._schedulerJob && this._poolTimeout > 0 && this._freeConnectionList.length > 0 && this._freeConnectionList.length + this._usedConnectionList.size > this._poolMin) {\n      this._schedulerJob = setTimeout(() => {\n        this._scanIdleConnection();\n      }, this._poolTimeout * 1000);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // scanIdleConnection()\n  //\n  // scan connection list and removes idle connections from pool\n  //---------------------------------------------------------------------------\n  _scanIdleConnection() {\n    while (this._usedConnectionList.size + this._freeConnectionList.length > this._poolMin && this._freeConnectionList.length > 0) {\n      const conn = this._freeConnectionList[0];\n      if (Date.now() - conn._lastTimeUsed < this._poolTimeout * 1000) {\n        break;\n      }\n      this.eventEmitter.emit('_removePoolConnection', conn);\n      this._freeConnectionList.shift();\n    }\n    this._schedulerJob = null;\n    this._setScheduler();\n  }\n\n  //---------------------------------------------------------------------------\n  // _getNumConnsToCreate()\n  //\n  // get number of connections need to be created\n  //---------------------------------------------------------------------------\n  _getNumConnsToCreate() {\n    const usedConns = this._freeConnectionList.length + this._usedConnectionList.size;\n    // less connections in the pool than poolMin? restore to poolMin\n    if (usedConns < this._poolMin) {\n      return this._poolMin - usedConns;\n      // connections need to be created? create up to poolIncrement without exceeding poolMax\n    } else if (this._pendingRequests.length > 0) {\n      return Math.min(this._poolIncrement, this._poolMax - usedConns);\n      // no pending requests and we are already at poolMin so nothing to do!\n    } else {\n      return 0;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // bgThreadFunc()\n  //\n  // method which runs in a background thread and is used to create connections.\n  // When first started, it creates poolMin connections. After that, it creates\n  // poolIncrement connections up to the value of poolMax when needed.\n  // The thread terminates automatically when the pool is closed.\n  //---------------------------------------------------------------------------\n  async bgThreadFunc() {\n    // continue until a close request is received\n    while (!this._poolCloseWaiter) {\n      // eliminate connections that exceed the poolMax (this should only happen\n      // after a reconfiguration has taken place where the maximum number of\n      // connections is reduced)\n      let numToDestroy = this._poolMax - this.getConnectionsOpen();\n      while (numToDestroy > 0 && this._freeConnectionList.length > 0) {\n        const connToBeRemoved = this._freeConnectionList.shift();\n        this.eventEmitter.emit('_removePoolConnection', connToBeRemoved);\n        numToDestroy--;\n      }\n      const numToCreate = this._getNumConnsToCreate();\n      // connection creation is going on serially and not concurrently\n      for (let i = 0; i < numToCreate; i++) {\n        try {\n          // get deobfuscated value\n          const config = await this._getConnAttrs();\n          const conn = new ThinConnectionImpl();\n          conn._pool = this;\n          await conn.connect(config);\n          conn._newSession = true;\n          conn._dropSess = false;\n          conn._lastTimeUsed = Date.now();\n          this._freeConnectionList.push(conn);\n        } catch (err) {\n          this._bgErr = err;\n        }\n        if (this._poolIncrement > 1 && this._poolMax - this._usedConnectionList.size - this._freeConnectionList.length > 1) {\n          this._setScheduler();\n        }\n\n        // resolve pending request\n        if (this._pendingRequests.length > 0) {\n          const payload = this._pendingRequests.shift();\n          payload.resolve();\n        }\n\n        // give an opportunity for other \"threads\" to do their work.\n        await new Promise(resolve => Timers.setImmediate(resolve));\n\n        // break loop when pool is closing\n        if (this._poolCloseWaiter) {\n          break;\n        }\n      }\n\n      // when pool is closing, break from while loop\n      if (this._poolCloseWaiter) {\n        break;\n      }\n\n      // if no pending requests, wait for pending requests to appear!\n      if (this._pendingRequests.length == 0 || this._bgErr) {\n        await new Promise(resolve => {\n          this.bgWaiter = resolve;\n        });\n        this.bgWaiter = null;\n      }\n    }\n\n    // notify the closer that the close can actually take place\n    this._poolCloseWaiter();\n  }\n\n  //---------------------------------------------------------------------------\n  // acquire()\n  //\n  // acquire a connection from connection pool\n  //---------------------------------------------------------------------------\n  async acquire() {\n    // return first connection from the free list that passes health checks\n    while (this._freeConnectionList.length > 0) {\n      const conn = this._freeConnectionList.pop();\n\n      // if connection is unhealthy, drop it from the pool\n      if (!conn.isHealthy()) {\n        this.eventEmitter.emit('_removePoolConnection', conn);\n        continue;\n      }\n\n      // perform a ping, if necessary; a ping interval less than 0 disables\n      // pings; a ping interval of 0 forces a ping for each use of the\n      // connection and a value greater than 0 will be performed if the\n      // connection has not been used for that period of time; if the ping is\n      // unsuccessful, drop the connection from the pool\n      let requiresPing = false;\n      if (this._poolPingInterval === 0) {\n        requiresPing = true;\n      } else if (this._poolPingInterval > 0) {\n        const elapsed = Date.now() - conn._lastTimeUsed;\n        if (elapsed > this._poolPingInterval * 1000) requiresPing = true;\n      }\n      if (requiresPing) {\n        let pingTimer;\n        try {\n          if (this._poolPingTimeout) {\n            pingTimer = setTimeout(() => {\n              // force disconnect causes ping task to unblock\n              // and return.\n              conn.nscon.forceDisconnect();\n            }, this._poolPingTimeout);\n          }\n          await conn.ping();\n        } catch {\n          conn.nscon.forceDisconnect();\n          continue;\n        } finally {\n          clearTimeout(pingTimer);\n        }\n      }\n\n      // connection has passed health checks, return it immediately\n      this._usedConnectionList.add(conn);\n      return conn;\n    }\n\n    // no free connections exist at this point; if less than poolMin\n    // connections exist, grow the pool to poolMin again; otherwise, increase\n    // the pool by poolIncrement up to poolMax. We are deferring this\n    // to the background thread function!\n    await new Promise(resolve => {\n      this._pendingRequests.push({\n        resolve: resolve\n      });\n      if (this.bgWaiter) {\n        // this wakes up the function to do some more work\n        this.bgWaiter();\n      }\n    });\n    if (this._bgErr) {\n      const err = this._bgErr;\n      this._bgErr = null;\n\n      // if an error has occurred in the background thread we clear it and then,\n      // if there are more pending requests we request the background thread\n      // function to try again.\n      if (this._pendingRequests.length > 0 && this.bgWaiter) {\n        this.bgWaiter();\n      }\n      throw err;\n    }\n    // return a connection from the ones that were just built\n    const conn = this._freeConnectionList.pop();\n    this._usedConnectionList.add(conn);\n    return conn;\n  }\n\n  // release connection to connection pool\n  release(conn) {\n    conn.warning = undefined;\n    this._usedConnectionList.delete(conn);\n    if (conn.nscon.connected) {\n      conn._lastTimeUsed = Date.now();\n      conn._newSession = false;\n      if (this._freeConnectionList.length + this._usedConnectionList.size < this._poolMax) {\n        this._freeConnectionList.push(conn);\n      } else {\n        this.eventEmitter.emit('_removePoolConnection', conn);\n      }\n    }\n    this._setScheduler();\n  }\n\n  //---------------------------------------------------------------------------\n  // _generateConnectionClass()\n  //\n  // generate connection class for drcp if none is provided by user\n  //---------------------------------------------------------------------------\n  _generateConnectionClass() {\n    this._userConfig.connectionClass = crypto.randomBytes(16).toString('base64');\n    this._userConfig.connectionClass = \"NJS:\" + this._userConfig.connectionClass;\n  }\n\n  //---------------------------------------------------------------------------\n  // reconfigure()\n  //\n  // Reconfigures the pool with new parameters\n  //---------------------------------------------------------------------------\n  reconfigure(params) {\n    if (params.poolIncrement !== undefined) {\n      this._poolIncrement = params.poolIncrement;\n    }\n    if (params.poolTimeout !== undefined && this._poolTimeout !== params.poolTimeout) {\n      this._poolTimeout = params.poolTimeout;\n      // clear scheduled job\n      if (this._schedulerJob) {\n        clearTimeout(this._schedulerJob);\n        this._schedulerJob = null;\n      }\n    }\n    if (params.poolPingInterval !== undefined) {\n      this._poolPingInterval = params.poolPingInterval;\n    }\n    if (params.stmtCacheSize !== undefined) {\n      this._stmtCacheSize = params.stmtCacheSize;\n    }\n    if (params.poolMax !== undefined) {\n      this._poolMax = params.poolMax;\n    }\n    if (params.poolMin !== undefined) {\n      this._poolMin = params.poolMin;\n    }\n    if (this.bgWaiter) {\n      this.bgWaiter();\n    }\n  }\n}\nmodule.exports = ThinPoolImpl;","map":{"version":3,"names":["PoolImpl","require","ThinConnectionImpl","protocolUtil","errors","settings","util","thinUtil","getConnectionInfo","crypto","EventEmitter","Timers","ThinPoolImpl","_init","params","homogeneous","throwErr","ERR_NOT_IMPLEMENTED","checkCredentials","_availableObjects","_name","_poolMin","poolMin","_poolMax","poolMax","_poolIncrement","poolIncrement","_poolTimeout","poolTimeout","_poolPingInterval","poolPingInterval","_poolPingTimeout","poolPingTimeout","_stmtCacheSize","stmtCacheSize","_userConfig","_freeConnectionList","_usedConnectionList","Set","_password","password","_walletPassword","walletPassword","_walletContent","walletContent","_obfuscatedPassword","_obfuscatedWalletPassword","_token","token","_obfuscatedToken","_privateKey","privateKey","_obfuscatedPrivateKey","_schedulerJob","_poolCloseWaiter","_pendingRequests","undefined","obj","setObfuscatedValue","value","obfuscatedValue","_obfuscatedWalletContent","walletConent","_accessTokenFn","accessTokenFn","_accessTokenConfig","accessTokenConfig","_isDRCPEnabled","_implicitPool","eventEmitter","on","connImpl","_destroy","create","_connInfo","String","toLowerCase","connectionClass","_generateConnectionClass","bgThreadFunc","setAccessToken","objToken","objKey","_getConnAttrs","accessToken","clonedAttrs","Object","assign","getDeobfuscatedValue","isTokenExpired","ERR_TOKEN_HAS_EXPIRED","getConnection","acquire","connection","nscon","ntAdapter","connected","_dropSess","close","Promise","resolve","bgWaiter","clearTimeout","conn","removeAllListeners","getPoolMax","getPoolMin","getConnectionsInUse","size","getConnectionsOpen","length","getPoolIncrement","getPoolMaxPerShard","getPoolPingInterval","getPoolPingTimeout","getPoolTimeout","getSodaMetaDataCache","getStmtCacheSize","_setScheduler","setTimeout","_scanIdleConnection","Date","now","_lastTimeUsed","emit","shift","_getNumConnsToCreate","usedConns","Math","min","numToDestroy","connToBeRemoved","numToCreate","i","config","_pool","connect","_newSession","push","err","_bgErr","payload","setImmediate","pop","isHealthy","requiresPing","elapsed","pingTimer","forceDisconnect","ping","add","release","warning","delete","randomBytes","toString","reconfigure","module","exports"],"sources":["C:/Users/Koliv/Desktop/Software/my-react-app/node_modules/oracledb/lib/thin/pool.js"],"sourcesContent":["// Copyright (c) 2022, 2024, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst PoolImpl = require('../impl/pool.js');\nconst ThinConnectionImpl = require('./connection.js');\nconst protocolUtil = require('./protocol/utils.js');\nconst errors = require('../errors.js');\nconst settings = require('../settings.js');\nconst util = require('../util.js');\nconst thinUtil = require('./util.js');\nconst {getConnectionInfo} = require('./sqlnet/networkSession.js');\nconst crypto = require('crypto');\nconst EventEmitter = require('events');\nconst Timers = require('timers');\n\nclass ThinPoolImpl extends PoolImpl {\n\n  _init(params) {\n    if (!params.homogeneous) {\n      errors.throwErr(errors.ERR_NOT_IMPLEMENTED, 'Heterogeneous Pooling');\n    }\n    thinUtil.checkCredentials(params);\n\n    this._availableObjects = [];\n    this._name = 'node-thin';\n    this._poolMin = params.poolMin;\n    this._poolMax = params.poolMax;\n    this._poolIncrement = params.poolIncrement;\n    this._poolTimeout = params.poolTimeout;\n    this._poolPingInterval = params.poolPingInterval;\n    this._poolPingTimeout = params.poolPingTimeout;\n    this._stmtCacheSize = params.stmtCacheSize;\n\n    // The user Config filterd from common layer is cached except\n    // sensitive data as sensitive data is obfuscated in the pool\n    // and de-obfuscated as necessary.\n    this._userConfig = params;\n    this._freeConnectionList = [];\n    this._usedConnectionList = new Set();\n    this._password = params.password;\n    this._walletPassword = params.walletPassword;\n    this._walletContent = params.walletContent;\n    this._obfuscatedPassword = [];\n    this._obfuscatedWalletPassword = [];\n    this._token = params.token;\n    this._obfuscatedToken = [];\n    this._privateKey = params.privateKey;\n    this._obfuscatedPrivateKey = [];\n    this._schedulerJob = null;\n    this._poolCloseWaiter = null;\n    this._pendingRequests = [];\n\n    // password obfuscation\n    if (this._password !== undefined) {\n      const obj = protocolUtil.setObfuscatedValue(this._password);\n      this._password = obj.value;\n      this._obfuscatedPassword = obj.obfuscatedValue;\n      this._userConfig.password = null;\n    }\n    // wallet password obfuscation\n    if (this._walletPassword !== undefined) {\n      const obj = protocolUtil.setObfuscatedValue(this._walletPassword);\n      this._walletPassword = obj.value;\n      this._obfuscatedWalletPassword = obj.obfuscatedValue;\n      this._userConfig.walletPassword = null;\n    }\n    // wallet content obfuscation\n    if (this._walletContent !== undefined) {\n      const obj = protocolUtil.setObfuscatedValue(this._walletContent);\n      this._walletContent = obj.value;\n      this._obfuscatedWalletContent = obj.obfuscatedValue;\n      this._userConfig.walletConent = null;\n    }\n    // token obfuscation\n    if (this._token !== undefined) {\n      const obj = protocolUtil.setObfuscatedValue(this._token);\n      this._token = obj.value;\n      this._obfuscatedToken = obj.obfuscatedValue;\n      this._userConfig.token = null;\n    }\n    // privateKey obfuscation\n    if (this._privateKey !== undefined) {\n      const obj = protocolUtil.setObfuscatedValue(this._privateKey);\n      this._privateKey = obj.value;\n      this._obfuscatedPrivateKey = obj.obfuscatedValue;\n      this._userConfig.privateKey = null;\n    }\n    this._accessTokenFn = params.accessTokenFn;\n    this._accessTokenConfig = params.accessTokenConfig;\n    this._isDRCPEnabled = false;\n    this._implicitPool = null;\n    this.eventEmitter = new EventEmitter();\n    // listener to remove dead or idle connections\n    this.eventEmitter.on('_removePoolConnection', async (connImpl) => {\n      await this._destroy(connImpl);\n    });\n  }\n\n  //---------------------------------------------------------------------------\n  // create pool with specified parameters and miminum number of connections as\n  // specified by poolMin\n  //---------------------------------------------------------------------------\n  async create(params) {\n    this._init(params);\n    this._userConfig._connInfo =\n      await getConnectionInfo(params);\n    this._isDRCPEnabled =\n      String(this._userConfig._connInfo[0]).toLowerCase() === 'pooled';\n    // generate connection class when none is provided by user\n    if (this._isDRCPEnabled && settings.connectionClass === '') {\n      this._generateConnectionClass();\n    }\n\n    // create a background task. It will create minimum connections in the pool\n    // and expand the pool as required.\n    this.bgThreadFunc();\n  }\n\n  //---------------------------------------------------------------------------\n  // set new token and private key in pool\n  //---------------------------------------------------------------------------\n  setAccessToken(params) {\n    if (params.token) {\n      this._token = params.token;\n      const objToken = protocolUtil.setObfuscatedValue(this._token);\n      this._token = objToken.value;\n      this._obfuscatedToken = objToken.obfuscatedValue;\n    }\n    if (params.privateKey) {\n      this._privateKey = params.privateKey;\n      const objKey = protocolUtil.setObfuscatedValue(this._privateKey);\n      this._privateKey = objKey.value;\n      this._obfuscatedPrivateKey = objKey.obfuscatedValue;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // credentials are obfuscated and stored in an object(userConfig) during\n  // pool creation. _getConnAttrs() method is used to deobfuscate encrypted\n  // credentials for creating new connections\n  //---------------------------------------------------------------------------\n  async _getConnAttrs() {\n    let accessToken;\n    const clonedAttrs = Object.assign({}, this._userConfig);\n    // deobfuscate password\n    if (clonedAttrs.password === null) {\n      clonedAttrs.password = protocolUtil.getDeobfuscatedValue(this._password,\n        this._obfuscatedPassword);\n    }\n\n    // deobfuscate wallet password\n    if (clonedAttrs.walletPassword === null) {\n      clonedAttrs.walletPassword =\n        protocolUtil.getDeobfuscatedValue(this._walletPassword,\n          this._obfuscatedWalletPassword);\n    }\n\n    // deobfuscate wallet content\n    if (clonedAttrs.walletContent === null) {\n      clonedAttrs.walletContent =\n            protocolUtil.getDeobfuscatedValue(this._walletContent,\n              this._obfuscatedWalletContent);\n    }\n\n    // deobfuscate token and private key\n    // check for token expiry\n    if (clonedAttrs.token === null) {\n      clonedAttrs.token =\n        protocolUtil.getDeobfuscatedValue(this._token, this._obfuscatedToken);\n      if (util.isTokenExpired(clonedAttrs.token)) {\n        if (typeof this._accessTokenFn === 'function') {\n          accessToken = await this._accessTokenFn(true, this._accessTokenConfig);\n          if (typeof accessToken === 'string') {\n            clonedAttrs.token = accessToken;\n            if (util.isTokenExpired(clonedAttrs.token)) {\n              // OAuth2 token is expired\n              errors.throwErr(errors.ERR_TOKEN_HAS_EXPIRED);\n            } else {\n              // update pool with OAuth2 token\n              const obj = protocolUtil.setObfuscatedValue(clonedAttrs.token);\n              this._token = obj.value;\n              this._obfuscatedToken = obj.obfuscatedValue;\n            }\n          } else if (typeof accessToken === 'object') {\n            clonedAttrs.token = accessToken.token;\n            clonedAttrs.privateKey = accessToken.privateKey;\n            if (util.isTokenExpired(clonedAttrs.token)) {\n              // IAM token is expired\n              errors.throwErr(errors.ERR_TOKEN_HAS_EXPIRED);\n            } else {\n              // update pool with IAM token and private key\n              const objToken = protocolUtil.setObfuscatedValue(clonedAttrs.token);\n              this._token = objToken.value;\n              this._obfuscatedToken = objToken.obfuscatedValue;\n              const objKey = protocolUtil.setObfuscatedValue(clonedAttrs.privateKey);\n              this._privateKey = objKey.value;\n              this._obfuscatedPrivateKey = objKey.obfuscatedValue;\n            }\n          }\n        } else {\n          errors.throwErr(errors.ERR_TOKEN_HAS_EXPIRED);\n        }\n      }\n    }\n    if (clonedAttrs.privateKey === null) {\n      clonedAttrs.privateKey =\n        protocolUtil.getDeobfuscatedValue(this._privateKey,\n          this._obfuscatedPrivateKey);\n    }\n    return clonedAttrs;\n  }\n\n  //---------------------------------------------------------------------------\n  // return available connection if present in pool else\n  // create new connection and return it\n  //---------------------------------------------------------------------------\n  async getConnection() {\n    return await this.acquire();\n  }\n\n  //---------------------------------------------------------------------------\n  // destroy connection when pool close operation is called\n  //---------------------------------------------------------------------------\n  async _destroy(connection) {\n    if (connection.nscon.ntAdapter.connected) {\n      connection._dropSess = true;\n      await connection.close();\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // close pool by destroying available connections\n  //---------------------------------------------------------------------------\n  async close() {\n\n    // wait till background task for pool expansion is finished; if it is not\n    // currently running, wake it up!\n    await new Promise((resolve) => {\n      this._poolCloseWaiter = resolve;\n      if (this.bgWaiter) {\n        this.bgWaiter();\n      }\n    });\n\n    // clear scheduled job\n    if (this._schedulerJob) {\n      clearTimeout(this._schedulerJob);\n      this._schedulerJob = null;\n    }\n\n    // destroy all free connections\n    for (const conn of this._freeConnectionList) {\n      await this._destroy(conn);\n    }\n\n    // destroy all used connections\n    for (const conn of this._usedConnectionList) {\n      await this._destroy(conn);\n    }\n\n    this.eventEmitter.removeAllListeners();\n  }\n\n  //---------------------------------------------------------------------------\n  // returns poolMax from configuration\n  //---------------------------------------------------------------------------\n  getPoolMax() {\n    return this._poolMax;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns poolMin from configuration\n  //---------------------------------------------------------------------------\n  getPoolMin() {\n    return this._poolMin;\n  }\n\n  //---------------------------------------------------------------------------\n  // get number of used connection\n  //---------------------------------------------------------------------------\n  getConnectionsInUse() {\n    return this._usedConnectionList.size;\n  }\n\n  //---------------------------------------------------------------------------\n  // get number of free connection\n  //---------------------------------------------------------------------------\n  getConnectionsOpen() {\n    return this._freeConnectionList.length + this._usedConnectionList.size;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns poolIncrement from configuration\n  //---------------------------------------------------------------------------\n  getPoolIncrement() {\n    return this._poolIncrement;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns maximum number of connections allowed per shard in the pool\n  //---------------------------------------------------------------------------\n  getPoolMaxPerShard() {\n    return;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns the pool ping interval (seconds)\n  //---------------------------------------------------------------------------\n  getPoolPingInterval() {\n    return this._poolPingInterval;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns the pool ping Timeout (milliseconds)\n  //---------------------------------------------------------------------------\n  getPoolPingTimeout() {\n    return this._poolPingTimeout;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns the pool timeout\n  //---------------------------------------------------------------------------\n  getPoolTimeout() {\n    return this._poolTimeout;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns whether the SODA metadata cache is enabled or not\n  //---------------------------------------------------------------------------\n  getSodaMetaDataCache() {\n    return;\n  }\n\n  //---------------------------------------------------------------------------\n  // returns the statement cache size associate with the pool\n  //---------------------------------------------------------------------------\n  getStmtCacheSize() {\n    return this._stmtCacheSize;\n  }\n\n  //---------------------------------------------------------------------------\n  // _setScheduler()\n  //\n  // set scheduler to scan and remove idle connections\n  //---------------------------------------------------------------------------\n  _setScheduler() {\n    if (!this._schedulerJob && this._poolTimeout > 0 &&\n        this._freeConnectionList.length > 0 &&\n        (this._freeConnectionList.length + this._usedConnectionList.size >\n        this._poolMin)) {\n      this._schedulerJob = setTimeout(() => {\n        this._scanIdleConnection();\n      }, this._poolTimeout * 1000);\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // scanIdleConnection()\n  //\n  // scan connection list and removes idle connections from pool\n  //---------------------------------------------------------------------------\n  _scanIdleConnection() {\n    while ((this._usedConnectionList.size + this._freeConnectionList.length) >\n        this._poolMin && this._freeConnectionList.length > 0) {\n      const conn = this._freeConnectionList[0];\n      if (Date.now() - conn._lastTimeUsed < this._poolTimeout * 1000) {\n        break;\n      }\n\n      this.eventEmitter.emit('_removePoolConnection', conn);\n      this._freeConnectionList.shift();\n    }\n\n    this._schedulerJob = null;\n    this._setScheduler();\n  }\n\n  //---------------------------------------------------------------------------\n  // _getNumConnsToCreate()\n  //\n  // get number of connections need to be created\n  //---------------------------------------------------------------------------\n  _getNumConnsToCreate() {\n    const usedConns = this._freeConnectionList.length + this._usedConnectionList.size;\n    // less connections in the pool than poolMin? restore to poolMin\n    if (usedConns < this._poolMin) {\n      return this._poolMin - usedConns;\n    // connections need to be created? create up to poolIncrement without exceeding poolMax\n    } else if (this._pendingRequests.length > 0) {\n      return Math.min(this._poolIncrement, this._poolMax - usedConns);\n    // no pending requests and we are already at poolMin so nothing to do!\n    } else {\n      return 0;\n    }\n  }\n\n  //---------------------------------------------------------------------------\n  // bgThreadFunc()\n  //\n  // method which runs in a background thread and is used to create connections.\n  // When first started, it creates poolMin connections. After that, it creates\n  // poolIncrement connections up to the value of poolMax when needed.\n  // The thread terminates automatically when the pool is closed.\n  //---------------------------------------------------------------------------\n  async bgThreadFunc() {\n\n    // continue until a close request is received\n    while (!this._poolCloseWaiter) {\n      // eliminate connections that exceed the poolMax (this should only happen\n      // after a reconfiguration has taken place where the maximum number of\n      // connections is reduced)\n      let numToDestroy = this._poolMax - this.getConnectionsOpen();\n      while (numToDestroy > 0 && this._freeConnectionList.length > 0) {\n        const connToBeRemoved = this._freeConnectionList.shift();\n        this.eventEmitter.emit('_removePoolConnection', connToBeRemoved);\n        numToDestroy--;\n      }\n\n      const numToCreate = this._getNumConnsToCreate();\n      // connection creation is going on serially and not concurrently\n      for (let i = 0; i < numToCreate; i++) {\n        try {\n          // get deobfuscated value\n          const config = await this._getConnAttrs();\n          const conn = new ThinConnectionImpl();\n          conn._pool = this;\n          await conn.connect(config);\n          conn._newSession = true;\n          conn._dropSess = false;\n          conn._lastTimeUsed = Date.now();\n          this._freeConnectionList.push(conn);\n        } catch (err) {\n          this._bgErr = err;\n        }\n\n        if (this._poolIncrement > 1 && (this._poolMax - this._usedConnectionList.size\n            - this._freeConnectionList.length) > 1) {\n          this._setScheduler();\n        }\n\n        // resolve pending request\n        if (this._pendingRequests.length > 0) {\n          const payload = this._pendingRequests.shift();\n          payload.resolve();\n        }\n\n        // give an opportunity for other \"threads\" to do their work.\n        await new Promise((resolve) => Timers.setImmediate(resolve));\n\n        // break loop when pool is closing\n        if (this._poolCloseWaiter) {\n          break;\n        }\n      }\n\n      // when pool is closing, break from while loop\n      if (this._poolCloseWaiter) {\n        break;\n      }\n\n      // if no pending requests, wait for pending requests to appear!\n      if (this._pendingRequests.length == 0 || this._bgErr) {\n        await new Promise((resolve) => {\n          this.bgWaiter = resolve;\n        });\n        this.bgWaiter = null;\n      }\n    }\n\n    // notify the closer that the close can actually take place\n    this._poolCloseWaiter();\n  }\n\n  //---------------------------------------------------------------------------\n  // acquire()\n  //\n  // acquire a connection from connection pool\n  //---------------------------------------------------------------------------\n  async acquire() {\n\n    // return first connection from the free list that passes health checks\n    while (this._freeConnectionList.length > 0) {\n      const conn = this._freeConnectionList.pop();\n\n      // if connection is unhealthy, drop it from the pool\n      if (!conn.isHealthy()) {\n        this.eventEmitter.emit('_removePoolConnection', conn);\n        continue;\n      }\n\n      // perform a ping, if necessary; a ping interval less than 0 disables\n      // pings; a ping interval of 0 forces a ping for each use of the\n      // connection and a value greater than 0 will be performed if the\n      // connection has not been used for that period of time; if the ping is\n      // unsuccessful, drop the connection from the pool\n      let requiresPing = false;\n      if (this._poolPingInterval === 0) {\n        requiresPing = true;\n      } else if (this._poolPingInterval > 0) {\n        const elapsed = Date.now() - conn._lastTimeUsed;\n        if (elapsed > this._poolPingInterval * 1000)\n          requiresPing = true;\n      }\n      if (requiresPing) {\n        let pingTimer;\n        try {\n          if (this._poolPingTimeout) {\n            pingTimer = setTimeout(() => {\n              // force disconnect causes ping task to unblock\n              // and return.\n              conn.nscon.forceDisconnect();\n            }, this._poolPingTimeout);\n          }\n          await conn.ping();\n        } catch {\n          conn.nscon.forceDisconnect();\n          continue;\n        } finally {\n          clearTimeout(pingTimer);\n        }\n      }\n\n      // connection has passed health checks, return it immediately\n      this._usedConnectionList.add(conn);\n      return conn;\n\n    }\n\n    // no free connections exist at this point; if less than poolMin\n    // connections exist, grow the pool to poolMin again; otherwise, increase\n    // the pool by poolIncrement up to poolMax. We are deferring this\n    // to the background thread function!\n    await new Promise((resolve) => {\n      this._pendingRequests.push({resolve: resolve});\n      if (this.bgWaiter) {\n        // this wakes up the function to do some more work\n        this.bgWaiter();\n      }\n    });\n\n    if (this._bgErr) {\n      const err = this._bgErr;\n      this._bgErr = null;\n\n      // if an error has occurred in the background thread we clear it and then,\n      // if there are more pending requests we request the background thread\n      // function to try again.\n      if (this._pendingRequests.length > 0 && this.bgWaiter) {\n        this.bgWaiter();\n      }\n      throw err;\n    }\n    // return a connection from the ones that were just built\n    const conn = this._freeConnectionList.pop();\n    this._usedConnectionList.add(conn);\n    return conn;\n  }\n\n  // release connection to connection pool\n  release(conn) {\n    conn.warning = undefined;\n    this._usedConnectionList.delete(conn);\n    if (conn.nscon.connected) {\n      conn._lastTimeUsed = Date.now();\n      conn._newSession = false;\n      if ((this._freeConnectionList.length + this._usedConnectionList.size)\n        < this._poolMax) {\n        this._freeConnectionList.push(conn);\n      } else {\n        this.eventEmitter.emit('_removePoolConnection', conn);\n      }\n    }\n\n    this._setScheduler();\n  }\n\n  //---------------------------------------------------------------------------\n  // _generateConnectionClass()\n  //\n  // generate connection class for drcp if none is provided by user\n  //---------------------------------------------------------------------------\n  _generateConnectionClass() {\n    this._userConfig.connectionClass = crypto.randomBytes(16).toString('base64');\n    this._userConfig.connectionClass = \"NJS:\" + this._userConfig.connectionClass;\n  }\n\n  //---------------------------------------------------------------------------\n  // reconfigure()\n  //\n  // Reconfigures the pool with new parameters\n  //---------------------------------------------------------------------------\n  reconfigure(params) {\n    if (params.poolIncrement !== undefined) {\n      this._poolIncrement = params.poolIncrement;\n    }\n\n    if (params.poolTimeout !== undefined &&\n      this._poolTimeout !== params.poolTimeout) {\n      this._poolTimeout = params.poolTimeout;\n      // clear scheduled job\n      if (this._schedulerJob) {\n        clearTimeout(this._schedulerJob);\n        this._schedulerJob = null;\n      }\n    }\n\n    if (params.poolPingInterval !== undefined) {\n      this._poolPingInterval = params.poolPingInterval;\n    }\n\n    if (params.stmtCacheSize !== undefined) {\n      this._stmtCacheSize = params.stmtCacheSize;\n    }\n\n    if (params.poolMax !== undefined) {\n      this._poolMax = params.poolMax;\n    }\n\n    if (params.poolMin !== undefined) {\n      this._poolMin = params.poolMin;\n    }\n\n    if (this.bgWaiter) {\n      this.bgWaiter();\n    }\n  }\n}\n\nmodule.exports = ThinPoolImpl;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}