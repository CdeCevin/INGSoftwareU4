{"ast":null,"code":"// Copyright (c) 2024, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst {\n  BaseBuffer,\n  GrowableBuffer\n} = require('./buffer.js');\nconst {\n  Buffer\n} = require('buffer');\nconst constants = require(\"./constants.js\");\nconst errors = require(\"../../errors.js\");\n\n/**\n * Class used for decoding\n */\nclass VectorDecoder extends BaseBuffer {\n  //---------------------------------------------------------------------------\n  // decode()\n  //\n  // Decodes the VECTOR image and returns a JavaScript array corresponding to\n  // its contents.\n  //---------------------------------------------------------------------------\n  decode() {\n    // parse header\n    const magicByte = this.readUInt8();\n    if (magicByte != constants.TNS_VECTOR_MAGIC_BYTE) errors.throwErr(errors.ERR_UNEXPECTED_DATA, Buffer.from([magicByte]).toString('hex'));\n    const version = this.readUInt8();\n    if (version > constants.TNS_VECTOR_VERSION_WITH_BINARY) errors.throwErr(errors.ERR_VECTOR_VERSION_NOT_SUPPORTED, version);\n    const flags = this.readUInt16BE();\n    const vectorFormat = this.readUInt8();\n    let numElements = this.readUInt32BE();\n    let elementSize, result;\n    if (vectorFormat === constants.VECTOR_FORMAT_FLOAT32) {\n      elementSize = 4;\n      result = new Float32Array(numElements);\n    } else if (vectorFormat === constants.VECTOR_FORMAT_FLOAT64) {\n      elementSize = 8;\n      result = new Float64Array(numElements);\n    } else if (vectorFormat === constants.VECTOR_FORMAT_INT8) {\n      elementSize = 1;\n      result = new Int8Array(numElements);\n    } else if (vectorFormat === constants.VECTOR_FORMAT_BINARY) {\n      elementSize = 1;\n      // The number of dimensions are assumed to be multiple of 8.\n      numElements = numElements / 8;\n      result = new Uint8Array(numElements);\n    } else {\n      errors.throwErr(errors.ERR_VECTOR_FORMAT_NOT_SUPPORTED, vectorFormat);\n    }\n\n    // For binary vector, NORM will never be present but space for NORM is reserved to keep\n    // same header lengh across the different vector formats.\n    if (vectorFormat === constants.VECTOR_FORMAT_BINARY || flags & constants.TNS_VECTOR_FLAG_NORM) this.skipBytes(8);\n\n    // parse data\n    for (let i = 0; i < numElements; i++) {\n      const buf = this.readBytes(elementSize);\n      if (vectorFormat === constants.VECTOR_FORMAT_FLOAT32) {\n        result[i] = this.parseBinaryFloat(buf);\n      } else if (vectorFormat === constants.VECTOR_FORMAT_FLOAT64) {\n        result[i] = this.parseBinaryDouble(buf);\n      } else {\n        result[i] = buf[0];\n      }\n    }\n    return result;\n  }\n}\nclass VectorEncoder extends GrowableBuffer {\n  //---------------------------------------------------------------------------\n  // encode()\n  //\n  // Encodes the value as OSON and returns a buffer containing the OSON bytes.\n  //---------------------------------------------------------------------------\n  encode(value) {\n    // determine some basic information about the vector\n    let vectorFormat = constants.VECTOR_FORMAT_FLOAT32;\n    let writeFn = this.writeBinaryFloat.bind(this);\n    let numElements = value.length;\n    let vectorVersion = constants.TNS_VECTOR_VERSION_BASE;\n    let flags = constants.TNS_VECTOR_FLAG_NORMSRC | constants.TNS_VECTOR_FLAG_NORM; // NORM is present and reserve space.\n\n    if (Array.isArray(value) || value instanceof Float64Array) {\n      vectorFormat = constants.VECTOR_FORMAT_FLOAT64;\n      writeFn = this.writeBinaryDouble.bind(this);\n    } else if (value instanceof Int8Array) {\n      vectorFormat = constants.VECTOR_FORMAT_INT8;\n      writeFn = this.writeSB1.bind(this);\n    } else if (value.constructor.name === 'Uint8Array') {\n      vectorFormat = constants.VECTOR_FORMAT_BINARY;\n      // The number of dimensions are assumed to be multiple of 8.\n      numElements = numElements * 8;\n      vectorVersion = constants.TNS_VECTOR_VERSION_WITH_BINARY;\n      flags = constants.TNS_VECTOR_FLAG_NORMSRC; // only space is reserved.\n      writeFn = this.writeUInt8.bind(this);\n    }\n\n    // write header\n    this.writeUInt8(constants.TNS_VECTOR_MAGIC_BYTE);\n    this.writeUInt8(vectorVersion);\n    this.writeUInt16BE(flags);\n    this.writeUInt8(vectorFormat);\n    this.writeUInt32BE(numElements);\n    this.reserveBytes(8);\n\n    // write data\n    value.forEach(element => {\n      writeFn(element);\n    });\n    return this.buf.subarray(0, this.pos);\n  }\n}\nmodule.exports = {\n  VectorDecoder,\n  VectorEncoder\n};","map":{"version":3,"names":["BaseBuffer","GrowableBuffer","require","Buffer","constants","errors","VectorDecoder","decode","magicByte","readUInt8","TNS_VECTOR_MAGIC_BYTE","throwErr","ERR_UNEXPECTED_DATA","from","toString","version","TNS_VECTOR_VERSION_WITH_BINARY","ERR_VECTOR_VERSION_NOT_SUPPORTED","flags","readUInt16BE","vectorFormat","numElements","readUInt32BE","elementSize","result","VECTOR_FORMAT_FLOAT32","Float32Array","VECTOR_FORMAT_FLOAT64","Float64Array","VECTOR_FORMAT_INT8","Int8Array","VECTOR_FORMAT_BINARY","Uint8Array","ERR_VECTOR_FORMAT_NOT_SUPPORTED","TNS_VECTOR_FLAG_NORM","skipBytes","i","buf","readBytes","parseBinaryFloat","parseBinaryDouble","VectorEncoder","encode","value","writeFn","writeBinaryFloat","bind","length","vectorVersion","TNS_VECTOR_VERSION_BASE","TNS_VECTOR_FLAG_NORMSRC","Array","isArray","writeBinaryDouble","writeSB1","constructor","name","writeUInt8","writeUInt16BE","writeUInt32BE","reserveBytes","forEach","element","subarray","pos","module","exports"],"sources":["C:/Users/Koliv/Desktop/Software/my-react-app/node_modules/oracledb/lib/impl/datahandlers/vector.js"],"sourcesContent":["// Copyright (c) 2024, Oracle and/or its affiliates.\n\n//-----------------------------------------------------------------------------\n//\n// This software is dual-licensed to you under the Universal Permissive License\n// (UPL) 1.0 as shown at https://oss.oracle.com/licenses/upl and Apache License\n// 2.0 as shown at http://www.apache.org/licenses/LICENSE-2.0. You may choose\n// either license.\n//\n// If you elect to accept the software under the Apache License, Version 2.0,\n// the following applies:\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//    https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//\n//-----------------------------------------------------------------------------\n\n'use strict';\n\nconst { BaseBuffer, GrowableBuffer } = require('./buffer.js');\nconst { Buffer } = require('buffer');\nconst constants = require(\"./constants.js\");\nconst errors = require(\"../../errors.js\");\n\n/**\n * Class used for decoding\n */\nclass VectorDecoder extends BaseBuffer {\n\n  //---------------------------------------------------------------------------\n  // decode()\n  //\n  // Decodes the VECTOR image and returns a JavaScript array corresponding to\n  // its contents.\n  //---------------------------------------------------------------------------\n  decode() {\n\n    // parse header\n    const magicByte = this.readUInt8();\n    if (magicByte != constants.TNS_VECTOR_MAGIC_BYTE)\n      errors.throwErr(errors.ERR_UNEXPECTED_DATA,\n        Buffer.from([magicByte]).toString('hex'));\n    const version = this.readUInt8();\n    if (version > constants.TNS_VECTOR_VERSION_WITH_BINARY)\n      errors.throwErr(errors.ERR_VECTOR_VERSION_NOT_SUPPORTED, version);\n    const flags = this.readUInt16BE();\n    const vectorFormat = this.readUInt8();\n    let numElements = this.readUInt32BE();\n    let elementSize, result;\n    if (vectorFormat === constants.VECTOR_FORMAT_FLOAT32) {\n      elementSize = 4;\n      result = new Float32Array(numElements);\n    } else if (vectorFormat === constants.VECTOR_FORMAT_FLOAT64) {\n      elementSize = 8;\n      result = new Float64Array(numElements);\n    } else if (vectorFormat === constants.VECTOR_FORMAT_INT8) {\n      elementSize = 1;\n      result = new Int8Array(numElements);\n    } else if (vectorFormat === constants.VECTOR_FORMAT_BINARY) {\n      elementSize = 1;\n      // The number of dimensions are assumed to be multiple of 8.\n      numElements = numElements / 8;\n      result = new Uint8Array(numElements);\n    } else {\n      errors.throwErr(errors.ERR_VECTOR_FORMAT_NOT_SUPPORTED, vectorFormat);\n    }\n\n    // For binary vector, NORM will never be present but space for NORM is reserved to keep\n    // same header lengh across the different vector formats.\n    if (vectorFormat === constants.VECTOR_FORMAT_BINARY || flags & constants.TNS_VECTOR_FLAG_NORM)\n      this.skipBytes(8);\n\n    // parse data\n    for (let i = 0; i < numElements; i++) {\n      const buf = this.readBytes(elementSize);\n      if (vectorFormat === constants.VECTOR_FORMAT_FLOAT32) {\n        result[i] = this.parseBinaryFloat(buf);\n      } else if (vectorFormat === constants.VECTOR_FORMAT_FLOAT64)  {\n        result[i] = this.parseBinaryDouble(buf);\n      } else {\n        result[i] = buf[0];\n      }\n    }\n\n    return result;\n  }\n\n}\n\nclass VectorEncoder extends GrowableBuffer {\n\n  //---------------------------------------------------------------------------\n  // encode()\n  //\n  // Encodes the value as OSON and returns a buffer containing the OSON bytes.\n  //---------------------------------------------------------------------------\n  encode(value) {\n\n    // determine some basic information about the vector\n    let vectorFormat = constants.VECTOR_FORMAT_FLOAT32;\n    let writeFn = this.writeBinaryFloat.bind(this);\n    let numElements = value.length;\n    let vectorVersion = constants.TNS_VECTOR_VERSION_BASE;\n    let flags = constants.TNS_VECTOR_FLAG_NORMSRC\n      | constants.TNS_VECTOR_FLAG_NORM; // NORM is present and reserve space.\n\n    if (Array.isArray(value) || value instanceof Float64Array) {\n      vectorFormat = constants.VECTOR_FORMAT_FLOAT64;\n      writeFn = this.writeBinaryDouble.bind(this);\n    } else if (value instanceof Int8Array) {\n      vectorFormat = constants.VECTOR_FORMAT_INT8;\n      writeFn = this.writeSB1.bind(this);\n    } else if (value.constructor.name === 'Uint8Array') {\n      vectorFormat = constants.VECTOR_FORMAT_BINARY;\n      // The number of dimensions are assumed to be multiple of 8.\n      numElements = numElements * 8;\n      vectorVersion = constants.TNS_VECTOR_VERSION_WITH_BINARY;\n      flags = constants.TNS_VECTOR_FLAG_NORMSRC; // only space is reserved.\n      writeFn = this.writeUInt8.bind(this);\n    }\n\n    // write header\n    this.writeUInt8(constants.TNS_VECTOR_MAGIC_BYTE);\n    this.writeUInt8(vectorVersion);\n    this.writeUInt16BE(flags);\n    this.writeUInt8(vectorFormat);\n    this.writeUInt32BE(numElements);\n    this.reserveBytes(8);\n\n    // write data\n    value.forEach((element) => {\n      writeFn(element);\n    });\n\n    return this.buf.subarray(0, this.pos);\n  }\n\n}\n\nmodule.exports = {\n  VectorDecoder,\n  VectorEncoder\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}